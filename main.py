# -*- coding: utf-8 -*-
# åœ¨æœ€å¼€å§‹å°±ç¦ç”¨SSLè­¦å‘Š
import os
# è®¾ç½®ç¯å¢ƒå˜é‡ç¦ç”¨SSLè­¦å‘Š
os.environ['PYTHONWARNINGS'] = 'ignore:Unverified HTTPS request'
os.environ['URLLIB3_DISABLE_WARNINGS'] = '1'

import warnings
warnings.filterwarnings('ignore', message='Unverified HTTPS request')
warnings.filterwarnings('ignore', message='.*certificate verification.*')
warnings.filterwarnings('ignore', message='.*SSL.*')
warnings.filterwarnings('ignore', category=UserWarning, module='urllib3')

import logging.handlers
import os
import sys
import asyncio
import logging
import logging
logging.getLogger("telethon").setLevel(logging.WARNING)
from pathlib import Path
from urllib.parse import urlparse
from typing import Optional, Dict, Any
from enum import Enum
from dataclasses import dataclass
import time
import threading
import requests
import urllib3
# ç«‹å³ç¦ç”¨urllib3çš„SSLè­¦å‘Š
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# å°è¯•ç¦ç”¨å…¶ä»–å¯èƒ½å­˜åœ¨çš„SSLè­¦å‘Š
try:
    urllib3.disable_warnings(urllib3.exceptions.SubjectAltNameWarning)
except AttributeError:
    pass  # è¯¥è­¦å‘Šç±»å‹ä¸å­˜åœ¨ï¼Œå¿½ç•¥

try:
    urllib3.disable_warnings(urllib3.exceptions.InsecurePlatformWarning)
except AttributeError:
    pass  # è¯¥è­¦å‘Šç±»å‹ä¸å­˜åœ¨ï¼Œå¿½ç•¥

try:
    urllib3.disable_warnings(urllib3.exceptions.SNIMissingWarning)
except AttributeError:
    pass  # è¯¥è­¦å‘Šç±»å‹ä¸å­˜åœ¨ï¼Œå¿½ç•¥

import re
import uuid
import mimetypes
import json
import subprocess
from telethon import TelegramClient, types
from telethon.sessions import StringSession
from telegram import (
    Update,
    Bot,
    InputFile,
    Audio,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
)
try:
    from .bilibili_favsub import BilibiliFavSubscriptionManager
except ImportError:
    from bilibili_favsub import BilibiliFavSubscriptionManager
from telegram.constants import ParseMode
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    filters,
    ContextTypes,
    CallbackContext,
    CallbackQueryHandler,
)
import yt_dlp
import qbittorrentapi
import signal
import gc
from concurrent.futures import ThreadPoolExecutor

# ç½‘ç»œé”™è¯¯å¤„ç†ç›¸å…³å¯¼å…¥
import httpx
from telegram.error import NetworkError, TimedOut, RetryAfter

# å¥åº·æ£€æŸ¥åŠŸèƒ½å·²åˆ é™¤ï¼Œä½†ä¿ç•™ Telegram ä¼šè¯ç”ŸæˆåŠŸèƒ½
from flask import Flask, jsonify, request
import threading

# é…ç½®è¯»å–å™¨
try:
    from config_reader import load_toml_config, get_qbittorrent_config
except ImportError:
    load_toml_config = None
    get_qbittorrent_config = None

# ç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½å™¨
try:
    # å¼ºåˆ¶é‡æ–°åŠ è½½æ¨¡å—ä»¥é¿å…ç¼“å­˜é—®é¢˜
    import sys
    import importlib
    if 'neteasecloud_music' in sys.modules:
        importlib.reload(sys.modules['neteasecloud_music'])

    import neteasecloud_music as _ncm
    from neteasecloud_music import NeteaseDownloader
    NETEASE_MODULE_PATH = getattr(_ncm, '__file__', 'unknown')
except ImportError:
    # å¯¼å…¥å¤±è´¥åˆ™ç½®ç©ºï¼Œç”±åˆå§‹åŒ–é€»è¾‘å†³å®šç¦ç”¨è¯¥åŠŸèƒ½
    NeteaseDownloader = None
    NETEASE_MODULE_PATH = 'unavailable'

# å¯¼å…¥QQéŸ³ä¹ä¸‹è½½å™¨
try:
    from qqmusic_downloader import QQMusicDownloader
    QQMUSIC_MODULE_PATH = 'qqmusic_downloader.py'
except ImportError:
    # å¯¼å…¥å¤±è´¥åˆ™ç½®ç©ºï¼Œç”±åˆå§‹åŒ–é€»è¾‘å†³å®šç¦ç”¨è¯¥åŠŸèƒ½
    QQMusicDownloader = None
    QQMUSIC_MODULE_PATH = 'unavailable'

# å¯¼å…¥YouTube Musicä¸‹è½½å™¨
try:
    from youtubemusic_downloader import YouTubeMusicDownloader
    YOUTUBEMUSIC_MODULE_PATH = 'youtubemusic_downloader.py'
except ImportError:
    # å¯¼å…¥å¤±è´¥åˆ™ç½®ç©ºï¼Œç”±åˆå§‹åŒ–é€»è¾‘å†³å®šç¦ç”¨è¯¥åŠŸèƒ½
    YouTubeMusicDownloader = None
    YOUTUBEMUSIC_MODULE_PATH = 'unavailable'

# å¯¼å…¥é…ç½®ç®¡ç†å™¨
try:
    from config_manager import ConfigManager
    CONFIG_MANAGER_AVAILABLE = True
except ImportError:
    logger.error("âŒ æ— æ³•å¯¼å…¥é…ç½®ç®¡ç†å™¨ï¼Œç¨‹åºæ— æ³•ç»§ç»­è¿è¡Œ")
    ConfigManager = None
    CONFIG_MANAGER_AVAILABLE = False
    sys.exit(1)  # ç›´æ¥é€€å‡ºï¼Œå› ä¸ºæ²¡æœ‰é…ç½®ç®¡ç†å™¨ç¨‹åºæ— æ³•è¿è¡Œ

# å¯¼å…¥é…ç½®è¯»å–å™¨
try:
    from config_reader import (
        load_toml_config,
        get_telegram_config,
        get_proxy_config,
        print_config_summary
    )
    CONFIG_READER_AVAILABLE = True
except ImportError:
    logger.warning("âš ï¸ æ— æ³•å¯¼å…¥é…ç½®è¯»å–å™¨ï¼Œå°†ç¦ç”¨ TOML é…ç½®æ–‡ä»¶æ”¯æŒ")
    load_toml_config = None
    get_telegram_config = None
    get_proxy_config = None
    print_config_summary = None
    CONFIG_READER_AVAILABLE = False

# é€‚é…å™¨ï¼šä¸ºç¼ºå°‘ download_album_by_id çš„æ—§ç‰ˆ NeteaseDownloader æä¾›å…¼å®¹å®ç°
class _NeteaseDownloaderAdapter:
    def __init__(self, base):
        self._base = base

    def __getattr__(self, name):
        # å…¶ä»–å±æ€§ä¸æ–¹æ³•ç›´æ¥é€ä¼ 
        return getattr(self._base, name)

    def download_album_by_id(self, album_id: str, download_dir: str = "./downloads/netease", quality: str = '128k', progress_callback=None) -> dict:
        # å¦‚æœåŸå§‹å®ä¾‹å·²ç»å®ç°äº†è¯¥æ–¹æ³•ï¼Œç›´æ¥è°ƒç”¨
        try:
            method = getattr(self._base, 'download_album_by_id')
        except AttributeError:
            method = None
        if callable(method):
            return method(album_id, download_dir, quality, progress_callback)

        # å…¼å®¹å®ç°ï¼šåŸºäº get_album_songs + download_song_by_id
        import os
        try:
            songs = self._base.get_album_songs(album_id)
            if not songs:
                return {
                    'success': False,
                    'error': f'æ— æ³•è·å–ä¸“è¾‘ID {album_id} çš„æ­Œæ›²ä¿¡æ¯',
                    'album_name': '',
                    'total_songs': 0,
                    'downloaded_songs': 0,
                    'total_size_mb': 0,
                    'download_path': download_dir,
                    'songs': [],
                    'quality': quality
                }

            album_title = songs[0].get('album', f'ä¸“è¾‘_{album_id}')
            
            # ä½¿ç”¨neteasecloud_music.pyä¸­çš„é…ç½®
            dir_format = self._base.dir_format
            album_folder_format = self._base.album_folder_format
            
            # è·å–è‰ºæœ¯å®¶ä¿¡æ¯
            artist_name = songs[0].get('artist', 'æœªçŸ¥è‰ºæœ¯å®¶')
            
            # æ„å»ºä¸“è¾‘æ–‡ä»¶å¤¹åç§°ï¼ˆä½¿ç”¨NCM_ALBUM_FOLDER_FORMATï¼‰
            if '{AlbumName}' in album_folder_format:
                # æ›¿æ¢ä¸“è¾‘åç§°å ä½ç¬¦
                album_folder_name = album_folder_format.replace('{AlbumName}', album_title)
                
                # å¦‚æœæœ‰å‘å¸ƒæ—¥æœŸå ä½ç¬¦ï¼Œå°è¯•è·å–å‘å¸ƒæ—¥æœŸ
                if '{ReleaseDate}' in album_folder_name:
                    try:
                        # å°è¯•ä»æ­Œæ›²ä¿¡æ¯ä¸­è·å–å‘å¸ƒæ—¥æœŸ
                        release_date = songs[0].get('publishTime', '')
                        if release_date:
                            # è½¬æ¢æ—¶é—´æˆ³ä¸ºå¹´ä»½
                            import time
                            try:
                                year = time.strftime('%Y', time.localtime(int(release_date) / 1000))
                                album_folder_name = album_folder_name.replace('{ReleaseDate}', year)
                            except:
                                album_folder_name = album_folder_name.replace('{ReleaseDate}', '')
                        else:
                            album_folder_name = album_folder_name.replace('{ReleaseDate}', '')
                    except:
                        album_folder_name = album_folder_name.replace('{ReleaseDate}', '')
                
                # æ¸…ç†æ–‡ä»¶åä¸­çš„éæ³•å­—ç¬¦
                safe_album_folder_name = self._base.clean_filename(album_folder_name)
            else:
                # å¦‚æœæ²¡æœ‰å ä½ç¬¦ï¼Œç›´æ¥ä½¿ç”¨ä¸“è¾‘åç§°
                safe_album_folder_name = self._base.clean_filename(album_title)
            
            # æ„å»ºå®Œæ•´çš„ç›®å½•è·¯å¾„ï¼ˆä½¿ç”¨NCM_DIR_FORMATï¼‰
            if '{ArtistName}' in dir_format and '{AlbumName}' in dir_format:
                # æ ¼å¼ï¼š{ArtistName}/{AlbumName} - è‰ºæœ¯å®¶/ä¸“è¾‘
                safe_artist_name = self._base.clean_filename(artist_name)
                album_dir = os.path.join(download_dir, safe_artist_name, safe_album_folder_name)
                logger.info(f"ğŸ” ä½¿ç”¨è‰ºæœ¯å®¶/ä¸“è¾‘ç›®å½•ç»“æ„: {safe_artist_name}/{safe_album_folder_name}")
            elif '{AlbumName}' in dir_format:
                # æ ¼å¼ï¼š{AlbumName} - ç›´æ¥ä»¥ä¸“è¾‘å‘½å
                album_dir = os.path.join(download_dir, safe_album_folder_name)
                logger.info(f"ğŸ” ä½¿ç”¨ä¸“è¾‘ç›®å½•ç»“æ„: {safe_album_folder_name}")
            else:
                # é»˜è®¤æ ¼å¼ï¼šç›´æ¥ä»¥ä¸“è¾‘å‘½å
                album_dir = os.path.join(download_dir, safe_album_folder_name)
                logger.info(f"ğŸ” ä½¿ç”¨é»˜è®¤ä¸“è¾‘ç›®å½•ç»“æ„: {safe_album_folder_name}")
            os.makedirs(album_dir, exist_ok=True)

            songs_info = []
            total_size = 0
            downloaded = 0

            # ä½¿ç”¨neteasecloud_music.pyä¸­çš„é…ç½®
            song_file_format = self._base.song_file_format
            
            for i, song in enumerate(songs, 1):
                sid = str(song.get('id'))
                res = self._base.download_song_by_id(sid, album_dir, quality, progress_callback)
                if res and res.get('success'):
                    downloaded += 1
                    size_mb = res.get('size_mb', 0) or 0
                    try:
                        size_bytes = int(float(size_mb) * 1024 * 1024)
                    except Exception:
                        size_bytes = 0
                    total_size += size_bytes
                    
                    # è·å–æ­Œæ›²ä¿¡æ¯
                    song_title = res.get('song_title', song.get('name', 'Unknown'))
                    song_artist = res.get('song_artist', song.get('artist', 'Unknown'))
                    original_filename = res.get('filename', '')
                    
                    # æ„å»ºè‡ªå®šä¹‰æ–‡ä»¶å
                    if '{SongNumber}' in song_file_format or '{SongName}' in song_file_format or '{ArtistName}' in song_file_format:
                        # æ›¿æ¢å ä½ç¬¦
                        custom_filename = song_file_format
                        
                        # æ›¿æ¢æ­Œæ›²ç¼–å·
                        if '{SongNumber}' in custom_filename:
                            custom_filename = custom_filename.replace('{SongNumber}', f"{i:02d}")
                        
                        # æ›¿æ¢æ­Œæ›²åç§°
                        if '{SongName}' in custom_filename:
                            custom_filename = custom_filename.replace('{SongName}', song_title)
                        
                        # æ›¿æ¢è‰ºæœ¯å®¶åç§°
                        if '{ArtistName}' in custom_filename:
                            custom_filename = custom_filename.replace('{ArtistName}', song_artist)
                        
                        # æ·»åŠ æ–‡ä»¶æ‰©å±•å
                        if original_filename and '.' in original_filename:
                            file_ext = original_filename.split('.')[-1]
                            custom_filename = f"{custom_filename}.{file_ext}"
                        
                        # æ¸…ç†æ–‡ä»¶åä¸­çš„éæ³•å­—ç¬¦
                        safe_custom_filename = self._base.clean_filename(custom_filename)
                        
                        # é‡å‘½åæ–‡ä»¶
                        try:
                            original_filepath = os.path.join(album_dir, original_filename)
                            new_filepath = os.path.join(album_dir, safe_custom_filename)
                            
                            if os.path.exists(original_filepath) and original_filepath != new_filepath:
                                os.rename(original_filepath, new_filepath)
                                logger.info(f"âœ… é‡å‘½åæ­Œæ›²æ–‡ä»¶: {original_filename} -> {safe_custom_filename}")
                                final_filename = safe_custom_filename
                            else:
                                final_filename = original_filename
                        except Exception as e:
                            logger.warning(f"âš ï¸ é‡å‘½åæ–‡ä»¶å¤±è´¥: {e}")
                            final_filename = original_filename
                    else:
                        final_filename = original_filename
                    
                    songs_info.append({
                        'name': f"{song_title} - {song_artist}",
                        'size': size_bytes,
                        'filepath': os.path.join(album_dir, final_filename)
                    })
                else:
                    songs_info.append({
                        'name': f"{song.get('name', 'Unknown')} - {song.get('artist', 'Unknown')}",
                        'size': 0,
                        'filepath': ''
                    })

            return {
                'success': True,
                'album_name': album_title,
                'total_songs': len(songs),
                'downloaded_songs': downloaded,
                'total_size_mb': (total_size / (1024 * 1024)) if total_size else 0,
                'download_path': album_dir,
                'songs': songs_info,
                'quality': quality
            }
        except Exception as e:
            return {
                'success': False,
                'error': f'ä¸“è¾‘ä¸‹è½½å¤±è´¥: {e}',
                'album_name': '',
                'total_songs': 0,
                'downloaded_songs': 0,
                'total_size_mb': 0,
                'download_path': download_dir,
                'songs': [],
                'quality': quality
            }

def extract_xiaohongshu_url(text):
    import re
    # å…ˆå°è¯•æå–æ ‡å‡†http/httpsé“¾æ¥
    urls = re.findall(r'http[s]?://[^\s]+', text)
    for url in urls:
        if 'xhslink.com' in url or 'xiaohongshu.com' in url:
            return url

    # å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ ‡å‡†é“¾æ¥ï¼Œå°è¯•æå–å…¶ä»–æ ¼å¼çš„å°çº¢ä¹¦é“¾æ¥
    # åŒ¹é… p://ã€tp://ã€ttp:// ç­‰åè®®ï¼Œå¹¶è½¬æ¢ä¸ºhttps://
    non_http_urls = re.findall(r'(p|tp|ttp)://([^\s]+)', text)
    for protocol, url in non_http_urls:
        if 'xhslink.com' in url or 'xiaohongshu.com' in url:
            return f"https://{url}"

    # åŒ¹é…æ²¡æœ‰åè®®çš„å°çº¢ä¹¦åŸŸå
    domain_urls = re.findall(r'(xhslink\.com/[^\s]+|xiaohongshu\.com/[^\s]+)', text)
    for url in domain_urls:
        return f"https://{url}"

    return None
# æŠ–éŸ³å’Œå°çº¢ä¹¦ä¸‹è½½ç›¸å…³å¯¼å…¥
try:
    from playwright.async_api import async_playwright
    PLAYWRIGHT_AVAILABLE = True
except ImportError:
    PLAYWRIGHT_AVAILABLE = False
    print("è­¦å‘Š: playwright æœªå®‰è£…ï¼ŒæŠ–éŸ³å’Œå°çº¢ä¹¦ä¸‹è½½åŠŸèƒ½å°†ä¸å¯ç”¨")


# ç¨‹åºç‰ˆæœ¬ä¿¡æ¯
BOT_VERSION = "v0.4"

# åˆ›å»º Flask åº”ç”¨ï¼ˆä»…ç”¨äº Telegram ä¼šè¯ç”Ÿæˆï¼‰
app = Flask(__name__, static_folder="web", static_url_path="/web")

# æ³¨å†Œ Telethon Web è“å›¾ï¼ˆç”¨äºç”Ÿæˆ Session Stringï¼‰â€”â€”æŒ‰ä½ çš„è¦æ±‚ï¼Œå›ºå®šä½¿ç”¨ web/tg_setup.py
try:
    import os as _os
    _static_dir_abs = _os.path.join(_os.path.dirname(__file__), "web")
    from web.tg_setup import create_blueprint as _tg_create_bp
    app.register_blueprint(_tg_create_bp(static_dir=_static_dir_abs))
    logging.getLogger(__name__).info("âœ… /setup å·²ç”±ä¸»è¿›ç¨‹Flaskæ‰˜ç®¡ï¼ˆä½¿ç”¨ web/tg_setup.pyï¼‰")
except Exception as _e:
    logging.getLogger(__name__).warning(f"âš ï¸ æ³¨å†Œ /setup å¤±è´¥: {_e}")

# å°è¯•å¯¼å…¥ gallery-dl
try:
    import gallery_dl
    GALLERY_DL_AVAILABLE = True
except ImportError:
    GALLERY_DL_AVAILABLE = False
    print("è­¦å‘Š: gallery-dl æœªå®‰è£…ï¼ŒXå›¾ç‰‡ä¸‹è½½åŠŸèƒ½å°†ä¸å¯ç”¨")


# å¿ƒè·³æ›´æ–°åŠŸèƒ½å·²åˆ é™¤


# å¥åº·æ£€æŸ¥åŠŸèƒ½å·²åˆ é™¤


# å¥åº·æ£€æŸ¥åŠŸèƒ½å·²åˆ é™¤ï¼Œé¿å…äº‹ä»¶å¾ªç¯å†²çª


try:
    from telegram import Update
    from telegram.ext import (
        Application,
        CommandHandler,
        MessageHandler,
        filters,
        ContextTypes,
    )
    import yt_dlp
except ImportError as e:
    print(f"Error importing required packages: {e}")
    print("Please install: pip install python-telegram-bot yt-dlp requests")
    sys.exit(1)

# å·¥å…·å‡½æ•°å®šä¹‰
def _clean_filename_for_display_local(filename: str) -> str:
    try:
        import re, os
        # ç§»é™¤æ—¶é—´æˆ³å‰ç¼€(10ä½æ•°å­—+ä¸‹åˆ’çº¿)
        if filename and re.match(r"^\d{10}_", filename):
            display_name = filename[11:]
        else:
            display_name = filename or ""
        # æ™ºèƒ½æˆªæ–­è¿‡é•¿æ–‡ä»¶å
        if len(display_name) > 35:
            name, ext = os.path.splitext(display_name)
            display_name = name[:30] + "..." + ext
        return display_name
    except Exception:
        filename = filename or ""
        return filename if len(filename) <= 35 else filename[:32] + "..."

# é¡¶å±‚æä¾›è¿›åº¦æ¡å·¥å…·ï¼Œé¿å…åµŒå¥—å‡½æ•°åè§£æé—®é¢˜
def _create_progress_bar_local(percent: float, length: int = 20) -> str:
    filled_length = int(length * percent / 100)
    return "â–ˆ" * filled_length + "â–‘" * (length - filled_length)

# å…¨å±€å·¥å…·å‡½æ•°ï¼Œä¾›ç½‘æ˜“äº‘éŸ³ä¹è¿›åº¦å›è°ƒä½¿ç”¨
def _clean_filename_for_display(filename: str) -> str:
    try:
        import re, os
        # ç§»é™¤æ—¶é—´æˆ³å‰ç¼€(10ä½æ•°å­—+ä¸‹åˆ’çº¿)
        if filename and re.match(r"^\d{10}_", filename):
            display_name = filename[11:]
        else:
            display_name = filename or ""
        # æ™ºèƒ½æˆªæ–­è¿‡é•¿æ–‡ä»¶å
        if len(display_name) > 35:
            name, ext = os.path.splitext(display_name)
            display_name = name[:30] + "..." + ext
        return display_name
    except Exception:
        filename = filename or ""
        return filename if len(filename) <= 35 else filename[:32] + "..."

def _create_progress_bar(percent: float, length: int = 20) -> str:
    filled_length = int(length * percent / 100)
    return "â–ˆ" * filled_length + "â–‘" * (length - filled_length)

def _escape_markdown_v2(text: str) -> str:
    """ç‹¬ç«‹çš„MarkdownV2è½¬ä¹‰å‡½æ•°ï¼Œç”¨äºç½‘æ˜“äº‘è¿›åº¦æ¶ˆæ¯"""
    if not text:
        return text
    
    # å…ˆè½¬ä¹‰åæ–œæ ï¼Œé¿å…é‡å¤è½¬ä¹‰
    escaped_text = text.replace("\\", "\\\\")
    
    # è½¬ä¹‰MarkdownV2ç‰¹æ®Šå­—ç¬¦
    special_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
    for char in special_chars:
        escaped_text = escaped_text.replace(char, f"\\{char}")
    
    return escaped_text

# é…ç½®å¢å¼ºçš„æ—¥å¿—ç³»ç»Ÿ
def setup_logging():
    """é…ç½®å¢å¼ºçš„æ—¥å¿—ç³»ç»Ÿï¼Œæ”¯æŒè¿œç¨‹NASç›®å½•"""
    # ä»ç¯å¢ƒå˜é‡è·å–æ—¥å¿—é…ç½®
    log_level = os.getenv("LOG_LEVEL", "INFO").upper()
    log_dir = os.getenv("LOG_DIR", "./logs")  # æ”¹ä¸ºå½“å‰ç›®å½•ä¸‹çš„logs
    log_max_size = int(os.getenv("LOG_MAX_SIZE", "10")) * 1024 * 1024  # é»˜è®¤10MB
    log_backup_count = int(os.getenv("LOG_BACKUP_COUNT", "5"))
    log_to_console = os.getenv("LOG_TO_CONSOLE", "true").lower() == "true"
    log_to_file = os.getenv("LOG_TO_FILE", "true").lower() == "true"
    # åˆ›å»ºæ—¥å¿—ç›®å½•ï¼ˆæ”¯æŒè¿œç¨‹NASè·¯å¾„ï¼‰
    log_path = Path(log_dir)
    try:
        log_path.mkdir(parents=True, exist_ok=True)
    except Exception as e:
        print(f"è­¦å‘Šï¼šæ— æ³•åˆ›å»ºæ—¥å¿—ç›®å½• {log_path}: {e}")
        # å¦‚æœæ— æ³•åˆ›å»ºè¿œç¨‹ç›®å½•ï¼Œå›é€€åˆ°æœ¬åœ°ç›®å½•
        log_path = Path("./logs")  # æ”¹ä¸ºå½“å‰ç›®å½•ä¸‹çš„logs
        log_path.mkdir(parents=True, exist_ok=True)
        print(f"å·²å›é€€åˆ°æœ¬åœ°æ—¥å¿—ç›®å½•: {log_path}")
    # é…ç½®æ—¥å¿—æ ¼å¼
    log_format = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    date_format = "%Y-%m-%d %H:%M:%S"
    # åˆ›å»ºæ ¼å¼åŒ–å™¨
    formatter = logging.Formatter(log_format, date_format)
    # è·å–æ ¹æ—¥å¿—è®°å½•å™¨
    root_logger = logging.getLogger()
    root_logger.setLevel(getattr(logging, log_level))
    # æ¸…é™¤ç°æœ‰çš„å¤„ç†å™¨
    for handler in root_logger.handlers[:]:
        root_logger.removeHandler(handler)
    # æ–‡ä»¶æ—¥å¿—å¤„ç†å™¨ï¼ˆå¸¦è½®è½¬ï¼‰
    if log_to_file:
        try:
            file_handler = logging.handlers.RotatingFileHandler(
                log_path / "savextube.log",
                maxBytes=log_max_size,
                backupCount=log_backup_count,
                encoding="utf-8",
            )
            file_handler.setFormatter(formatter)
            file_handler.setLevel(getattr(logging, log_level))
            root_logger.addHandler(file_handler)
        except Exception as e:
            print(f"è­¦å‘Šï¼šæ— æ³•åˆ›å»ºæ–‡ä»¶æ—¥å¿—å¤„ç†å™¨: {e}")
            log_to_file = False
    # æ§åˆ¶å°æ—¥å¿—å¤„ç†å™¨
    if log_to_console:
        console_handler = logging.StreamHandler()
        console_handler.setFormatter(formatter)
        console_handler.setLevel(getattr(logging, log_level))
        root_logger.addHandler(console_handler)

    # è®¾ç½®ç¬¬ä¸‰æ–¹åº“çš„æ—¥å¿—çº§åˆ«ï¼Œå‡å°‘å†—ä½™è¾“å‡º
    # httpx - Telegram API è¯·æ±‚æ—¥å¿—
    logging.getLogger("httpx").setLevel(logging.WARNING)
    # urllib3 - HTTP è¯·æ±‚æ—¥å¿—
    logging.getLogger("urllib3").setLevel(logging.ERROR)
    logging.getLogger("urllib3.connectionpool").setLevel(logging.ERROR)
    logging.getLogger("urllib3.util.retry").setLevel(logging.ERROR)
    # ç¦ç”¨urllib3çš„æ‰€æœ‰è­¦å‘Š
    logging.getLogger("urllib3").disabled = True

# è®¾ç½®æ—¥å¿—
setup_logging()
logger = logging.getLogger("savextube")

# ç»Ÿä¸€çš„è¿›åº¦ç®¡ç†å‡½æ•°
def create_unified_progress_hook(message_updater=None, progress_data=None):
    """
    åˆ›å»ºç»Ÿä¸€çš„è¿›åº¦å›è°ƒå‡½æ•°ï¼Œé€‚ç”¨äºæ‰€æœ‰åŸºäº yt-dlp çš„ä¸‹è½½

    Args:
        message_updater: åŒæ­¥æˆ–å¼‚æ­¥æ¶ˆæ¯æ›´æ–°å‡½æ•°
        progress_data: è¿›åº¦æ•°æ®å­—å…¸ï¼Œç”¨äºå­˜å‚¨æœ€ç»ˆæ–‡ä»¶åç­‰ä¿¡æ¯

    Returns:
        progress_hook: ç»Ÿä¸€çš„è¿›åº¦å›è°ƒå‡½æ•°
    """
    def progress_hook(d):
        try:
            if d.get('status') == 'downloading':
                # å®‰å…¨åœ°è·å–ä¸‹è½½è¿›åº¦ä¿¡æ¯
                downloaded = d.get('downloaded_bytes', 0) or 0
                total = d.get('total_bytes') or d.get('total_bytes_estimate', 0) or 0

                # ç¡®ä¿æ•°å€¼æœ‰æ•ˆ
                if downloaded is None:
                    downloaded = 0
                if total is None or total <= 0:
                    total = 1  # é¿å…é™¤é›¶é”™è¯¯

                # è®¡ç®—è¿›åº¦ç™¾åˆ†æ¯”
                if total > 0:
                    percent = (downloaded / total) * 100
                else:
                    percent = 0

                # æ ¼å¼åŒ–é€Ÿåº¦
                speed = d.get('speed', 0) or 0
                if speed and speed > 0:
                    speed_str = f"{speed / 1024 / 1024:.2f} MB/s"
                else:
                    speed_str = "æœªçŸ¥"

                # æ ¼å¼åŒ–å‰©ä½™æ—¶é—´
                eta = d.get('eta', 0) or 0
                if eta and eta > 0:
                    eta_str = f"{eta}ç§’"
                else:
                    eta_str = "æœªçŸ¥"

                # è·å–æ–‡ä»¶å
                filename = os.path.basename(d.get('filename', '')) or "æ­£åœ¨ä¸‹è½½..."

                # æ›´æ–°è¿›åº¦æ•°æ®
                if progress_data:
                    progress_data.update({
                        'downloaded': downloaded,
                        'total': total,
                        'percent': percent,
                        'speed': speed_str,
                        'eta': eta_str,
                        'status': 'downloading',
                        'filename': filename
                    })

                # è®°å½•è¿›åº¦ä¿¡æ¯
                logger.info(f"ä¸‹è½½è¿›åº¦: {percent:.1f}% ({downloaded}/{total} bytes) - {speed_str} - å‰©ä½™: {eta_str}")

                # å¦‚æœæœ‰æ¶ˆæ¯æ›´æ–°å™¨ï¼Œè°ƒç”¨å®ƒ
                if message_updater:
                    try:
                        # æ£€æŸ¥æ˜¯å¦ä¸ºåç¨‹å¯¹è±¡ï¼ˆé”™è¯¯æƒ…å†µï¼‰
                        if asyncio.iscoroutine(message_updater):
                            logger.error(f"âŒ [progress_hook] message_updater æ˜¯åç¨‹å¯¹è±¡ï¼Œä¸æ˜¯å‡½æ•°ï¼")
                            return

                        # æ£€æŸ¥æ˜¯å¦ä¸ºå¼‚æ­¥å‡½æ•°
                        if asyncio.iscoroutinefunction(message_updater):
                            # å¼‚æ­¥å‡½æ•°ï¼Œä½¿ç”¨ run_coroutine_threadsafe
                            try:
                                loop = asyncio.get_running_loop()
                            except RuntimeError:
                                try:
                                    loop = asyncio.get_event_loop()
                                except RuntimeError:
                                    loop = asyncio.new_event_loop()
                                    asyncio.set_event_loop(loop)

                            # ç›´æ¥ä¼ é€’åŸå§‹è¿›åº¦æ•°æ®å­—å…¸
                            asyncio.run_coroutine_threadsafe(
                                message_updater(d), loop)
                        else:
                            # åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                            message_updater(d)
                    except Exception as e:
                        logger.warning(f"âš ï¸ æ›´æ–°è¿›åº¦æ¶ˆæ¯å¤±è´¥: {e}")
                        logger.warning(f"âš ï¸ å¼‚å¸¸ç±»å‹: {type(e)}")
                        import traceback
                        logger.warning(f"âš ï¸ å¼‚å¸¸å †æ ˆ: {traceback.format_exc()}")

            if d.get('status') == 'finished':
                logger.info("ä¸‹è½½å®Œæˆï¼Œå¼€å§‹åå¤„ç†...")

                # æ›´æ–°è¿›åº¦æ•°æ®
                if progress_data and isinstance(progress_data, dict):
                    progress_data['status'] = 'finished'

                # å®‰å…¨åœ°è·å–æ–‡ä»¶å
                filename = d.get('filename', '')
                if filename and progress_data and isinstance(progress_data, dict):
                    progress_data['final_filename'] = filename
                    logger.info(f"æœ€ç»ˆæ–‡ä»¶å: {filename}")

                    # ç›‘æ§æ–‡ä»¶åˆå¹¶çŠ¶æ€
                    if filename.endswith('.part'):
                        logger.warning(f"âš ï¸ æ–‡ä»¶åˆå¹¶å¯èƒ½å¤±è´¥: {filename}")
                    else:
                        logger.info(f"âœ… æ–‡ä»¶ä¸‹è½½å¹¶åˆå¹¶æˆåŠŸ: {filename}")
                else:
                    logger.warning("progress_hook ä¸­æœªè·å–åˆ°æ–‡ä»¶å")

                # å¦‚æœæœ‰æ¶ˆæ¯æ›´æ–°å™¨ï¼Œå‘é€å®Œæˆæ¶ˆæ¯
                if message_updater:
                    try:
                        # æ·»åŠ è¯¦ç»†çš„è°ƒè¯•æ—¥å¿—
                        logger.info(f"ğŸ” [progress_hook] finishedçŠ¶æ€ - message_updater ç±»å‹: {type(message_updater)}")

                        # æ£€æŸ¥æ˜¯å¦ä¸ºåç¨‹å¯¹è±¡ï¼ˆé”™è¯¯æƒ…å†µï¼‰
                        if asyncio.iscoroutine(message_updater):
                            logger.error(f"âŒ [progress_hook] finishedçŠ¶æ€ - message_updater æ˜¯åç¨‹å¯¹è±¡ï¼Œä¸æ˜¯å‡½æ•°ï¼")
                            return

                        # æ£€æŸ¥æ˜¯å¦ä¸ºå¼‚æ­¥å‡½æ•°
                        if asyncio.iscoroutinefunction(message_updater):
                            logger.info(f"ğŸ” [progress_hook] finishedçŠ¶æ€ - æ£€æµ‹åˆ°å¼‚æ­¥å‡½æ•°ï¼Œä½¿ç”¨ run_coroutine_threadsafe")
                            # å¼‚æ­¥å‡½æ•°ï¼Œä½¿ç”¨ run_coroutine_threadsafe
                            try:
                                loop = asyncio.get_running_loop()
                            except RuntimeError:
                                try:
                                    loop = asyncio.get_event_loop()
                                except RuntimeError:
                                    loop = asyncio.new_event_loop()
                                    asyncio.set_event_loop(loop)

                            # ç›´æ¥ä¼ é€’åŸå§‹è¿›åº¦æ•°æ®å­—å…¸
                            asyncio.run_coroutine_threadsafe(
                                message_updater(d), loop)
                        else:
                            logger.info(f"ğŸ” [progress_hook] finishedçŠ¶æ€ - æ£€æµ‹åˆ°åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨")
                            # åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                            message_updater(d)
                    except Exception as e:
                        logger.warning(f"âš ï¸ æ›´æ–°å®Œæˆæ¶ˆæ¯å¤±è´¥: {e}")
                        logger.warning(f"âš ï¸ å¼‚å¸¸ç±»å‹: {type(e)}")
                        import traceback
                        logger.warning(f"âš ï¸ å¼‚å¸¸å †æ ˆ: {traceback.format_exc()}")

        except Exception as e:
            logger.error(f"progress_hook å¤„ç†é”™è¯¯: {e}")
            import traceback
            logger.error(f"progress_hook å¼‚å¸¸å †æ ˆ: {traceback.format_exc()}")
            # ä¸ä¸­æ–­ä¸‹è½½ï¼Œåªè®°å½•é”™è¯¯

    return progress_hook
def create_bilibili_message_updater(status_message, context, progress_data):
    """
    ä¸“é—¨ä¸ºBç«™å¤šPä¸‹è½½åˆ›å»ºçš„æ¶ˆæ¯æ›´æ–°å™¨
    å®Œå…¨å¤åˆ¶YouTubeçš„æˆåŠŸé€»è¾‘
    """
    import time
    import asyncio

    # ç¼“å­˜ä¸Šæ¬¡å‘é€çš„å†…å®¹ï¼Œé¿å…é‡å¤å‘é€
    last_progress_text = {"text": None}

    # --- è¿›åº¦å›è°ƒ ---
    last_update_time = {"time": time.time()}
    last_progress_percent = {"value": 0}
    progress_state = {"last_stage": None, "last_percent": 0, "finished_shown": False}
    last_progress_text = {"text": ""}

    # åˆ›å»ºBç«™ä¸“ç”¨çš„æ¶ˆæ¯æ›´æ–°å™¨å‡½æ•°
    async def bilibili_message_updater(text_or_dict):
        try:
            logger.info(f"ğŸ” bilibili_message_updater è¢«è°ƒç”¨ï¼Œå‚æ•°ç±»å‹: {type(text_or_dict)}")
            logger.info(f"ğŸ” bilibili_message_updater å‚æ•°å†…å®¹: {text_or_dict}")

            # å¦‚æœå·²ç»æ˜¾ç¤ºå®ŒæˆçŠ¶æ€ï¼Œå¿½ç•¥æ‰€æœ‰åç»­è°ƒç”¨
            if progress_state["finished_shown"]:
                logger.info("Bç«™ä¸‹è½½å·²å®Œæˆï¼Œå¿½ç•¥bilibili_message_updateråç»­è°ƒç”¨")
                return

            # å¤„ç†å­—ç¬¦ä¸²ç±»å‹ï¼Œé¿å…é‡å¤å‘é€ç›¸åŒå†…å®¹
            if isinstance(text_or_dict, str):
                if text_or_dict == last_progress_text["text"]:
                    logger.info("ğŸ” è·³è¿‡é‡å¤å†…å®¹")
                    return  # è·³è¿‡é‡å¤å†…å®¹
                last_progress_text["text"] = text_or_dict
                await status_message.edit_text(text_or_dict, parse_mode=None)
                return

            # æ£€æŸ¥æ˜¯å¦ä¸ºå­—å…¸ç±»å‹ï¼ˆæ¥è‡ªprogress_hookçš„è¿›åº¦æ•°æ®ï¼‰
            if isinstance(text_or_dict, dict):
                logger.info(f"ğŸ” æ£€æµ‹åˆ°å­—å…¸ç±»å‹ï¼ŒçŠ¶æ€: {text_or_dict.get('status')}")

                # è®°å½•æ–‡ä»¶åï¼ˆç”¨äºæ–‡ä»¶æŸ¥æ‰¾ï¼‰
                if text_or_dict.get("status") == "finished":
                    filename = text_or_dict.get('filename', '')
                    if filename:
                        # è®°å½•åˆ°progress_dataä¸­
                        if progress_data and isinstance(progress_data, dict):
                            if 'downloaded_files' not in progress_data:
                                progress_data['downloaded_files'] = []
                            progress_data['downloaded_files'].append(filename)
                        logger.info(f"ğŸ“ Bç«™ä¸‹è½½å™¨è®°å½•å®Œæˆæ–‡ä»¶: {filename}")

                if text_or_dict.get("status") == "finished":
                    # å¯¹äºfinishedçŠ¶æ€ï¼Œä¸è°ƒç”¨update_progressï¼Œé¿å…æ˜¾ç¤ºé”™è¯¯çš„è¿›åº¦ä¿¡æ¯
                    logger.info("ğŸ” æ£€æµ‹åˆ°finishedçŠ¶æ€ï¼Œè·³è¿‡update_progressè°ƒç”¨")
                    return
                elif text_or_dict.get("status") == "downloading":
                    # è¿™æ˜¯æ¥è‡ªprogress_hookçš„ä¸‹è½½è¿›åº¦æ•°æ®
                    logger.info("ğŸ” æ£€æµ‹åˆ°ä¸‹è½½è¿›åº¦æ•°æ®ï¼Œå‡†å¤‡è°ƒç”¨ update_progress...")
                    # è¿™é‡Œéœ€è¦å®ç°update_progressé€»è¾‘ï¼Œæš‚æ—¶å…ˆè®°å½•
                    logger.info(f"ğŸ“Š Bç«™ä¸‹è½½è¿›åº¦: {text_or_dict}")
                else:
                    # å…¶ä»–å­—å…¸çŠ¶æ€ï¼Œè½¬æ¢ä¸ºæ–‡æœ¬
                    logger.info(f"ğŸ” å…¶ä»–å­—å…¸çŠ¶æ€: {text_or_dict}")
                    dict_text = str(text_or_dict)
                    if dict_text == last_progress_text["text"]:
                        logger.info("ğŸ” è·³è¿‡é‡å¤å­—å…¸å†…å®¹")
                        return  # è·³è¿‡é‡å¤å†…å®¹
                    last_progress_text["text"] = dict_text
                    await status_message.edit_text(dict_text, parse_mode=None)
            else:
                # æ™®é€šæ–‡æœ¬æ¶ˆæ¯
                logger.info(f"ğŸ” æ™®é€šæ–‡æœ¬æ¶ˆæ¯: {text_or_dict}")
                text_str = str(text_or_dict)
                if text_str == last_progress_text["text"]:
                    logger.info("ğŸ” è·³è¿‡é‡å¤æ–‡æœ¬å†…å®¹")
                    return  # è·³è¿‡é‡å¤å†…å®¹
                last_progress_text["text"] = text_str
                await status_message.edit_text(text_str, parse_mode=None)
        except Exception as e:
            logger.error(f"âŒ bilibili_message_updater å¤„ç†é”™è¯¯: {e}")
            logger.error(f"âŒ å¼‚å¸¸ç±»å‹: {type(e)}")
            import traceback
            logger.error(f"âŒ å¼‚å¸¸å †æ ˆ: {traceback.format_exc()}")
            if "Message is not modified" not in str(e):
                logger.warning(f"æ›´æ–°Bç«™çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")

    return bilibili_message_updater

def single_video_progress_hook(message_updater=None, progress_data=None, status_message=None, context=None):
    """
    é€‚ç”¨äºæ‰€æœ‰å•é›†ä¸‹è½½çš„ yt-dlp è¿›åº¦å›è°ƒï¼Œä¸‹è½½è¿‡ç¨‹ä¸­æ˜¾ç¤ºè¿›åº¦ï¼Œä¸‹è½½å®Œæˆåæ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯ã€‚
    æ•´åˆäº†å®Œæ•´çš„è¿›åº¦æ˜¾ç¤ºé€»è¾‘ï¼ŒåŒ…æ‹¬è¿›åº¦æ¡ã€é€Ÿåº¦ã€å‰©ä½™æ—¶é—´ç­‰ã€‚
    """
    import os  # å¯¼å…¥osæ¨¡å—ä»¥è§£å†³ä½œç”¨åŸŸé—®é¢˜
    import time
    import threading
    
    # å®šä¹‰å·¥å…·å‡½æ•°ï¼Œé¿å…ä½œç”¨åŸŸé—®é¢˜
    def _clean_filename_for_display_local(filename: str) -> str:
        try:
            import re
            # åªä¿ç•™æ–‡ä»¶åï¼Œç§»é™¤è·¯å¾„
            display_name = os.path.basename(filename) if filename else ""
            # ç§»é™¤æ—¶é—´æˆ³å‰ç¼€(10ä½æ•°å­—+ä¸‹åˆ’çº¿)
            if display_name and re.match(r"^\d{10}_", display_name):
                display_name = display_name[11:]
            # æ™ºèƒ½æˆªæ–­è¿‡é•¿æ–‡ä»¶å
            if len(display_name) > 35:
                name, ext = os.path.splitext(display_name)
                display_name = name[:30] + "..." + ext
            return display_name
        except Exception:
            filename = filename or ""
            # ç¡®ä¿åªè¿”å›æ–‡ä»¶å
            display_name = os.path.basename(filename)
            return display_name if len(display_name) <= 35 else display_name[:32] + "..."

    def _create_progress_bar_local(percent: float, length: int = 20) -> str:
        filled_length = int(length * percent / 100)
        return "â–ˆ" * filled_length + "â–‘" * (length - filled_length)

    # åˆå§‹åŒ–è¿›åº¦æ•°æ®
    if progress_data is None:
        progress_data = {"final_filename": None, "lock": threading.Lock()}

    # åˆå§‹åŒ–æ›´æ–°é¢‘ç‡æ§åˆ¶
    last_update_time = {"time": 0}

    def progress_hook(d):
        # æ˜¾ç¤ºè¿›åº¦æ—¥å¿—
        logger.info(f"ğŸ” [PROGRESS_HOOK] è¢«è°ƒç”¨: {d.get('status', 'unknown')}")
        logger.info(f"ğŸ” [PROGRESS_DEBUG] status_message: {status_message is not None}, context: {context is not None}")
        if isinstance(d, dict) and d.get('status') == 'downloading':
            progress = (d.get('downloaded_bytes', 0) / (d.get('total_bytes', 1))) * 100
            logger.info(f"ğŸ“Š ä¸‹è½½è¿›åº¦: {progress:.1f}%")
        elif isinstance(d, dict) and d.get('status') == 'finished':
            logger.info("âœ… ä¸‹è½½å®Œæˆ")
        
        # æ”¯æŒå­—ç¬¦ä¸²ç±»å‹ï¼Œç›´æ¥å‘åˆ°Telegram
        if isinstance(d, str):
            if message_updater and status_message:
                try:
                    loop = asyncio.get_running_loop()
                except RuntimeError:
                    try:
                        loop = asyncio.get_event_loop()
                    except RuntimeError:
                        loop = asyncio.new_event_loop()
                        asyncio.set_event_loop(loop)

                async def do_update():
                    try:
                        await status_message.edit_text(d, parse_mode=None)
                    except Exception as e:
                        logger.warning(f"å‘é€å­—ç¬¦ä¸²è¿›åº¦åˆ°TGå¤±è´¥: {e}")

                asyncio.run_coroutine_threadsafe(do_update(), loop)
            return

        # æ·»åŠ ç±»å‹æ£€æŸ¥ï¼Œç¡®ä¿dæ˜¯å­—å…¸ç±»å‹
        if not isinstance(d, dict):
            logger.warning(f"progress_hookæ¥æ”¶åˆ°éå­—å…¸ç±»å‹å‚æ•°: {type(d)}, å†…å®¹: {d}")
            return

        # æ›´æ–° progress_data
        try:
            if d['status'] == 'downloading':
                raw_filename = d.get('filename', '')
                display_filename = os.path.basename(raw_filename) if raw_filename else 'video.mp4'
                progress_data.update({
                    'filename': display_filename,
                    'total_bytes': d.get('total_bytes') or d.get('total_bytes_estimate', 0),
                    'downloaded_bytes': d.get('downloaded_bytes', 0),
                    'speed': d.get('speed', 0),
                    'status': 'downloading',
                    'progress': (d.get('downloaded_bytes', 0) / (d.get('total_bytes') or d.get('total_bytes_estimate', 1))) * 100 if (d.get('total_bytes') or d.get('total_bytes_estimate', 0)) > 0 else 0.0
                })
            elif d['status'] == 'finished':
                final_filename = d.get('filename', '')
                display_filename = os.path.basename(final_filename) if final_filename else 'video.mp4'
                progress_data.update({
                    'filename': display_filename,
                    'status': 'finished',
                    'final_filename': final_filename,
                    'progress': 100.0
                })
                logger.info(f"ğŸ“ è®°å½•æœ€ç»ˆæ–‡ä»¶å: {final_filename}")
        except Exception as e:
            logger.error(f"æ›´æ–° progress_data é”™è¯¯: {str(e)}")

        # å¦‚æœæ²¡æœ‰status_messageå’Œcontextï¼Œä½¿ç”¨ç®€å•çš„message_updater
        logger.info(f"ğŸ” [PROGRESS_DEBUG] status_message: {status_message is not None}, context: {context is not None}")
        if not status_message or not context:
            if message_updater:
                logger.info(f"ğŸ” single_video_progress_hook è°ƒç”¨ç®€å•æ¨¡å¼: status={d.get('status')}, async={asyncio.iscoroutinefunction(message_updater)}")

                if asyncio.iscoroutinefunction(message_updater):
                    # å¼‚æ­¥å‡½æ•°ï¼Œåœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­åˆ›å»ºæ–°çš„äº‹ä»¶å¾ªç¯æ¥è¿è¡Œ
                    try:
                        logger.info(f"ğŸ” æ£€æµ‹åˆ°å¼‚æ­¥è¿›åº¦æ›´æ–°å™¨ï¼Œåˆ›å»ºæ–°çº¿ç¨‹å¤„ç†")

                        def run_async_in_thread():
                            try:
                                # åœ¨æ–°çº¿ç¨‹ä¸­åˆ›å»ºäº‹ä»¶å¾ªç¯
                                loop = asyncio.new_event_loop()
                                asyncio.set_event_loop(loop)

                                # è¿è¡Œå¼‚æ­¥å‡½æ•°
                                loop.run_until_complete(message_updater(d))
                                loop.close()

                                logger.info(f"âœ… çº¿ç¨‹ä¸­å¼‚æ­¥è¿›åº¦å›è°ƒè°ƒç”¨æˆåŠŸ")
                            except Exception as e:
                                logger.warning(f"çº¿ç¨‹ä¸­å¼‚æ­¥è¿›åº¦å›è°ƒè°ƒç”¨å¤±è´¥: {e}")

                        # å¯åŠ¨çº¿ç¨‹ï¼ˆä¸ç­‰å¾…å®Œæˆï¼‰
                        import threading
                        thread = threading.Thread(target=run_async_in_thread, daemon=True)
                        thread.start()

                    except Exception as e:
                        logger.warning(f"åˆ›å»ºå¼‚æ­¥è¿›åº¦å›è°ƒçº¿ç¨‹å¤±è´¥: {e}")
                else:
                    try:
                        result = message_updater(d)
                        logger.info(f"âœ… åŒæ­¥è¿›åº¦å›è°ƒè°ƒç”¨æˆåŠŸ: {result}")
                    except Exception as e:
                        logger.warning(f"è¿›åº¦å›è°ƒè°ƒç”¨å¤±è´¥: {e}")
            else:
                logger.warning("âš ï¸ message_updater ä¸ºç©ºï¼Œè·³è¿‡è¿›åº¦å›è°ƒ")
            return

        # å®Œæ•´çš„è¿›åº¦æ˜¾ç¤ºé€»è¾‘
        now = time.time()

        # åŠ¨æ€æ›´æ–°é¢‘ç‡æ§åˆ¶ï¼šæ›´å®½æ¾çš„é¢‘ç‡æ§åˆ¶
        total_bytes = d.get('total_bytes') or d.get('total_bytes_estimate', 0)
        if total_bytes > 0 and total_bytes < 5 * 1024 * 1024:  # å°äº5MBçš„æ–‡ä»¶
            update_interval = 0.01  # 10msæ›´æ–°ä¸€æ¬¡ï¼Œç¡®ä¿å°æ–‡ä»¶ä¹Ÿèƒ½çœ‹åˆ°è¿›åº¦
        else:
            update_interval = 0.1  # å¤§æ–‡ä»¶0.1ç§’æ›´æ–°ä¸€æ¬¡

        time_since_last = now - last_update_time['time']
        
        # è®¡ç®—å½“å‰è¿›åº¦
        current_progress = 0
        if total_bytes > 0:
            current_progress = (d.get('downloaded_bytes', 0) / total_bytes) * 100
        
        # è·å–ä¸Šæ¬¡çš„è¿›åº¦
        if progress_data and isinstance(progress_data, dict):
            last_progress = progress_data.get('last_progress', 0)
        else:
            last_progress = 0
        
        # å¼ºåˆ¶æ›´æ–°æ¡ä»¶ï¼š
        # 1. è¶…è¿‡1ç§’æ²¡æœ‰æ›´æ–°
        # 2. è¿›åº¦å˜åŒ–è¶…è¿‡1%
        # 3. ä¸‹è½½å®Œæˆ
        force_update = (time_since_last > 1.0 or 
                       abs(current_progress - last_progress) >= 1.0 or
                       d.get('status') == 'finished')
        
        if time_since_last < update_interval and not force_update:
            logger.info(f"â° è·³è¿‡æ›´æ–°ï¼Œè·ç¦»ä¸Šæ¬¡æ›´æ–°ä»… {time_since_last:.2f}ç§’ï¼Œéœ€è¦ç­‰å¾… {update_interval}ç§’")
            return
        
        if force_update:
            if time_since_last > 1.0:
                logger.info(f"ğŸ”„ å¼ºåˆ¶æ›´æ–°ï¼Œè·ç¦»ä¸Šæ¬¡æ›´æ–°å·² {time_since_last:.2f}ç§’")
            elif abs(current_progress - last_progress) >= 1.0:
                logger.info(f"ğŸ”„ å¼ºåˆ¶æ›´æ–°ï¼Œè¿›åº¦å˜åŒ– {last_progress:.1f}% -> {current_progress:.1f}%")
            elif d.get('status') == 'finished':
                logger.info(f"ğŸ”„ å¼ºåˆ¶æ›´æ–°ï¼Œä¸‹è½½å®Œæˆ")
        
        # æ›´æ–°è¿›åº¦è®°å½•
        if progress_data and isinstance(progress_data, dict):
            progress_data['last_progress'] = current_progress

        # å¤„ç†ä¸‹è½½å®ŒæˆçŠ¶æ€ - ç›´æ¥æ˜¾ç¤ºå®Œæˆä¿¡æ¯å¹¶è¿”å›
        if d.get('status') == 'finished':
            logger.info("yt-dlpä¸‹è½½å®Œæˆï¼Œæ˜¾ç¤ºå®Œæˆä¿¡æ¯")

            # è·å–è¿›åº¦ä¿¡æ¯
            if progress_data and isinstance(progress_data, dict):
                filename = progress_data.get('filename', 'video.mp4')
                total_bytes = progress_data.get('total_bytes', 0)
                downloaded_bytes = progress_data.get('downloaded_bytes', 0)
            else:
                filename = 'video.mp4'
                total_bytes = 0
                downloaded_bytes = 0

            # ç›‘æ§æ–‡ä»¶åˆå¹¶çŠ¶æ€
            actual_filename = d.get('filename', filename)
            if actual_filename.endswith('.part'):
                logger.warning(f"âš ï¸ æ–‡ä»¶åˆå¹¶å¯èƒ½å¤±è´¥: {actual_filename}")
            else:
                logger.info(f"âœ… æ–‡ä»¶ä¸‹è½½å¹¶åˆå¹¶æˆåŠŸ: {actual_filename}")

            # æ˜¾ç¤ºå®Œæˆä¿¡æ¯
            display_filename = _clean_filename_for_display_local(filename)
            progress_bar = _create_progress_bar_local(100.0)
            size_mb = total_bytes / (1024 * 1024) if total_bytes > 0 else downloaded_bytes / (1024 * 1024)

            completion_text = (
                f"ğŸ“ æ–‡ä»¶ï¼š{display_filename}\n"
                f"ğŸ’¾ å¤§å°ï¼š{size_mb:.2f}MB\n"
                f"âš¡ é€Ÿåº¦ï¼šå®Œæˆ\n"
                f"â³ é¢„è®¡å‰©ä½™ï¼š0ç§’\n"
                f"ğŸ“Š è¿›åº¦ï¼š{progress_bar} (100.0%)"
            )

            async def do_update():
                try:
                    await status_message.edit_text(completion_text, parse_mode=None)
                    logger.info("ğŸ“± æ˜¾ç¤ºä¸‹è½½å®Œæˆè¿›åº¦ä¿¡æ¯")
                except Exception as e:
                    logger.warning(f"æ˜¾ç¤ºå®Œæˆè¿›åº¦ä¿¡æ¯å¤±è´¥: {e}")

            try:
                loop = asyncio.get_running_loop()
            except RuntimeError:
                try:
                    loop = asyncio.get_event_loop()
                except RuntimeError:
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)

            asyncio.run_coroutine_threadsafe(do_update(), loop)
            return

        # å¤„ç†ä¸‹è½½ä¸­çŠ¶æ€ - è¿™æ˜¯å…³é”®éƒ¨åˆ†ï¼Œéœ€è¦å‘é€åˆ°Telegram
        if d.get('status') == 'downloading':
            logger.info(f"ğŸ” [DOWNLOADING_DEBUG] è¿›å…¥ä¸‹è½½ä¸­çŠ¶æ€å¤„ç†")
            logger.info(f"ğŸ” [DOWNLOADING_DEBUG] status_message: {status_message is not None}, context: {context is not None}")
            last_update_time['time'] = now

            total_bytes = d.get('total_bytes') or d.get('total_bytes_estimate', 0)
            downloaded_bytes = d.get('downloaded_bytes', 0)
            speed_bytes_s = d.get('speed', 0)
            eta_seconds = d.get('eta', 0)
            filename = d.get('filename', '') or "æ­£åœ¨ä¸‹è½½..."
            logger.info(f"ğŸ” [DOWNLOADING_DEBUG] æ–‡ä»¶ä¿¡æ¯: {filename}, æ€»å¤§å°: {total_bytes}, å·²ä¸‹è½½: {downloaded_bytes}")

            # è®¡ç®—è¿›åº¦
            logger.info(f"ğŸ” [TOTAL_BYTES_DEBUG] total_bytes: {total_bytes}, æ¡ä»¶æ£€æŸ¥: {total_bytes > 0}")
            if total_bytes > 0:
                progress = (downloaded_bytes / total_bytes) * 100
                progress_bar = _create_progress_bar_local(progress)
                size_mb = total_bytes / (1024 * 1024)
                speed_mb = (speed_bytes_s or 0) / (1024 * 1024)

                # è®¡ç®—é¢„è®¡å‰©ä½™æ—¶é—´
                eta_text = ""
                if speed_bytes_s and total_bytes and downloaded_bytes < total_bytes:
                    remaining = total_bytes - downloaded_bytes
                    eta = int(remaining / speed_bytes_s)
                    mins, secs = divmod(eta, 60)
                    if mins > 0:
                        eta_text = f"{mins}åˆ†{secs}ç§’"
                    else:
                        eta_text = f"{secs}ç§’"
                elif speed_bytes_s:
                    eta_text = "è®¡ç®—ä¸­"
                else:
                    eta_text = "æœªçŸ¥"

                display_filename = _clean_filename_for_display_local(filename)
                progress_text = (
                    f"ğŸ“ æ–‡ä»¶ï¼š{display_filename}\n"
                    f"ğŸ’¾ å¤§å°ï¼š{size_mb:.2f}MB\n"
                    f"âš¡ é€Ÿåº¦ï¼š{speed_mb:.2f}MB/s\n"
                    f"â³ é¢„è®¡å‰©ä½™ï¼š{eta_text}\n"
                    f"ğŸ“Š è¿›åº¦ï¼š{progress_bar} ({progress:.1f}%)"
                )

                async def do_update():
                    try:
                        logger.info(f"ğŸ” [DO_UPDATE_DEBUG] å¼€å§‹æ›´æ–°Telegramæ¶ˆæ¯")
                        logger.info(f"ğŸ” [DO_UPDATE_DEBUG] status_message: {status_message is not None}")
                        logger.info(f"ğŸ” [DO_UPDATE_DEBUG] progress_text: {progress_text[:100]}...")
                        await status_message.edit_text(progress_text, parse_mode=None)
                        logger.info(f"ğŸ“± æ›´æ–°Telegramè¿›åº¦: {progress:.1f}% - æ–‡ä»¶: {display_filename}")
                    except Exception as e:
                        logger.error(f"ğŸ” [DO_UPDATE_ERROR] æ›´æ–°Telegramå¤±è´¥: {e}")
                        if "Message is not modified" not in str(e):
                            logger.warning(f"æ›´æ–°Telegramè¿›åº¦å¤±è´¥: {e}")
                        else:
                            logger.info(f"ğŸ“± Telegramæ¶ˆæ¯æœªä¿®æ”¹ï¼Œè·³è¿‡æ›´æ–°")
                
                logger.info(f"ğŸ” [DO_UPDATE_DEFINED] do_update åç¨‹å·²å®šä¹‰")

                try:
                    loop = asyncio.get_running_loop()
                except RuntimeError:
                    try:
                        loop = asyncio.get_event_loop()
                    except RuntimeError:
                        loop = asyncio.new_event_loop()
                        asyncio.set_event_loop(loop)

                logger.info(f"ğŸ” [ASYNC_DEBUG] è°ƒç”¨ asyncio.run_coroutine_threadsafe (ä¸‹è½½ä¸­çŠ¶æ€)")
                logger.info(f"ğŸ” [ASYNC_DEBUG] loop: {loop is not None}")
                logger.info(f"ğŸ” [ASYNC_DEBUG] do_update å‡½æ•°: {do_update}")
                
                # æ£€æŸ¥äº‹ä»¶å¾ªç¯æ˜¯å¦æ­£åœ¨è¿è¡Œ
                try:
                    if loop.is_running():
                        logger.info(f"ğŸ” [ASYNC_DEBUG] äº‹ä»¶å¾ªç¯æ­£åœ¨è¿è¡Œï¼Œä½¿ç”¨ run_coroutine_threadsafe")
                        future = asyncio.run_coroutine_threadsafe(do_update(), loop)
                        logger.info(f"ğŸ” [ASYNC_DEBUG] asyncio.run_coroutine_threadsafe è°ƒç”¨å®Œæˆ, future: {future}")
                        logger.info(f"ğŸ” [ASYNC_DEBUG] future.done(): {future.done()}")
                    else:
                        logger.info(f"ğŸ” [ASYNC_DEBUG] äº‹ä»¶å¾ªç¯æœªè¿è¡Œï¼Œç›´æ¥è¿è¡Œåç¨‹")
                        # å¦‚æœäº‹ä»¶å¾ªç¯æ²¡æœ‰è¿è¡Œï¼Œç›´æ¥è¿è¡Œåç¨‹
                        asyncio.run(do_update())
                        logger.info(f"ğŸ” [ASYNC_DEBUG] åç¨‹ç›´æ¥è¿è¡Œå®Œæˆ")
                except Exception as e:
                    logger.error(f"ğŸ” [ASYNC_ERROR] å¼‚æ­¥è°ƒç”¨å¤±è´¥: {e}")
                    # å¤‡ç”¨æ–¹æ¡ˆï¼šä½¿ç”¨çº¿ç¨‹æ± 
                    import concurrent.futures
                    with concurrent.futures.ThreadPoolExecutor() as executor:
                        future = executor.submit(asyncio.run, do_update())
                        logger.info(f"ğŸ” [ASYNC_DEBUG] ä½¿ç”¨çº¿ç¨‹æ± è¿è¡Œåç¨‹: {future}")
            else:
                # æ²¡æœ‰æ€»å¤§å°ä¿¡æ¯æ—¶çš„å¤„ç†
                display_filename = _clean_filename_for_display_local(filename)
                speed_mb = (speed_bytes_s or 0) / (1024 * 1024)
                progress_text = (
                    f"ğŸ“ æ–‡ä»¶ï¼š{display_filename}\n"
                    f"ğŸ’¾ å¤§å°ï¼šè®¡ç®—ä¸­...\n"
                    f"âš¡ é€Ÿåº¦ï¼š{speed_mb:.2f}MB/s\n"
                    f"â³ é¢„è®¡å‰©ä½™ï¼šæœªçŸ¥\n"
                    f"ğŸ“Š è¿›åº¦ï¼šä¸‹è½½ä¸­..."
                )

                async def do_update():
                    try:
                        await status_message.edit_text(progress_text, parse_mode=None)
                        logger.info(f"ğŸ“± æ›´æ–°Telegramè¿›åº¦ï¼ˆæ— å¤§å°ä¿¡æ¯ï¼‰- æ–‡ä»¶: {display_filename}")
                    except Exception as e:
                        if "Message is not modified" not in str(e):
                            logger.warning(f"æ›´æ–°Telegramè¿›åº¦å¤±è´¥: {e}")
                        else:
                            logger.info(f"ğŸ“± Telegramæ¶ˆæ¯æœªä¿®æ”¹ï¼Œè·³è¿‡æ›´æ–°")

                try:
                    loop = asyncio.get_running_loop()
                except RuntimeError:
                    try:
                        loop = asyncio.get_event_loop()
                    except RuntimeError:
                        loop = asyncio.new_event_loop()
                        asyncio.set_event_loop(loop)

                asyncio.run_coroutine_threadsafe(do_update(), loop)

    return progress_hook


def apple_music_progress_hook(message_updater=None, progress_data=None, status_message=None, context=None):
    """
    Apple Music ä¸‹è½½è¿›åº¦å›è°ƒï¼Œæ”¯æŒä¸‹è½½å’Œè§£å¯†ä¸¤ä¸ªé˜¶æ®µçš„è¿›åº¦æ˜¾ç¤º
    """
    import os
    import time
    import threading

    # åˆå§‹åŒ–è¿›åº¦æ•°æ®
    if progress_data is None:
        progress_data = {"final_filename": None, "lock": threading.Lock()}

    # åˆå§‹åŒ–æ›´æ–°é¢‘ç‡æ§åˆ¶
    last_update_time = {"time": 0}
    last_message_content = {"text": ""}

    def progress_hook(progress_info):
        # å¤„ç†æ–°çš„è¿›åº¦ä¿¡æ¯æ ¼å¼
        if isinstance(progress_info, dict):
            try:
                phase = progress_info.get('phase', 'unknown')
                
                if phase == 'downloading':
                    # ä¸‹è½½é˜¶æ®µ
                    percentage = progress_info.get('percentage', 0)
                    downloaded = progress_info.get('downloaded', 0)
                    total = progress_info.get('total', 0)
                    unit = progress_info.get('unit', 'MB')
                    speed = progress_info.get('speed', '0 MB/s')
                    
                    # è®¡ç®—é¢„è®¡å‰©ä½™æ—¶é—´
                    if speed and 'MB/s' in speed:
                        try:
                            speed_value = float(speed.replace(' MB/s', ''))
                            if speed_value > 0:
                                remaining_mb = total - downloaded
                                remaining_seconds = remaining_mb / speed_value
                                if remaining_seconds < 60:
                                    remaining_time = f"00:{int(remaining_seconds):02d}"
                                else:
                                    minutes = int(remaining_seconds // 60)
                                    seconds = int(remaining_seconds % 60)
                                    remaining_time = f"{minutes:02d}:{seconds:02d}"
                            else:
                                remaining_time = "00:00"
                        except:
                            remaining_time = "00:00"
                    else:
                        remaining_time = "00:00"
                    
                    # åˆ›å»ºè¿›åº¦æ¡
                    progress_bar_length = 20
                    filled_length = int(progress_bar_length * percentage / 100)
                    progress_bar = "â–ˆ" * filled_length + "â–‘" * (progress_bar_length - filled_length)
                    
                    # è·å–æ–‡ä»¶åï¼ˆå¦‚æœå¯ç”¨ï¼‰
                    filename = progress_info.get('filename', 'æœªçŸ¥æ–‡ä»¶')
                    
                    # åˆ¤æ–­æ˜¯ä¸“è¾‘è¿˜æ˜¯å•æ›²ï¼ˆé€šè¿‡æ£€æŸ¥æ–‡ä»¶åæ˜¯å¦åŒ…å«æ‰©å±•åï¼‰
                    if '.' in filename and filename.endswith(('.flac', '.m4a', '.aac')):
                        # å•æ›²ï¼šæ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯
                        file_display = f"ğŸ“ æ–‡ä»¶: {filename}"
                        progress_text = (
                            f"ğŸ Apple Music ä¸‹è½½ä¸­\n\n"
                            f"{file_display}\n"
                            f"ğŸ’¾ å¤§å°: {downloaded:.2f}{unit} / {total:.2f}{unit}\n"
                            f"âš¡ï¸ ä¸‹è½½é€Ÿåº¦: {speed}\n"
                            f"â³ é¢„è®¡å‰©ä½™: {remaining_time}\n"
                            f"ğŸ“Š è¿›åº¦: {progress_bar} {percentage}%"
                        )
                    else:
                        # ä¸“è¾‘ï¼šæ˜¾ç¤ºä¸“è¾‘ä¿¡æ¯å’Œæ–‡ä»¶ä¿¡æ¯
                        # ä¸“è¾‘ä¸‹è½½æ—¶ï¼Œéœ€è¦æ˜¾ç¤ºå½“å‰æ­£åœ¨ä¸‹è½½çš„å•æ›²åç§°
                        album_name = filename
                        current_track = progress_info.get('current_track', None)
                        
                        if current_track:
                            # å¦‚æœæœ‰å½“å‰å•æ›²åç§°ï¼Œæ˜¾ç¤ºä¸º "ä¸“è¾‘å + å½“å‰å•æ›² + .m4aæ ¼å¼"
                            file_display = f"ğŸ“€ ä¸“è¾‘: {album_name}\nğŸ“ æ–‡ä»¶: {current_track}.m4a"
                        else:
                            # å¦‚æœæ²¡æœ‰å½“å‰å•æ›²åç§°ï¼Œæ˜¾ç¤ºä¸“è¾‘å
                            file_display = f"ğŸ“€ ä¸“è¾‘: {album_name}\nğŸ“ æ–‡ä»¶: æ­£åœ¨è·å–å•æ›²ä¿¡æ¯..."
                        
                        progress_text = (
                            f"ğŸ Apple Music ä¸‹è½½ä¸­\n\n"
                            f"{file_display}\n"
                            f"ğŸ’¾ å¤§å°: {downloaded:.2f}{unit} / {total:.2f}{unit}\n"
                            f"âš¡ï¸ ä¸‹è½½é€Ÿåº¦: {speed}\n"
                            f"â³ é¢„è®¡å‰©ä½™: {remaining_time}\n"
                            f"ğŸ“Š è¿›åº¦: {progress_bar} {percentage}%"
                        )
                    
                    # å‘é€è¿›åº¦ä¿¡æ¯åˆ°Telegram
                    if message_updater and status_message:
                        try:
                            loop = asyncio.get_running_loop()
                        except RuntimeError:
                            try:
                                loop = asyncio.get_event_loop()
                            except RuntimeError:
                                loop = asyncio.new_event_loop()
                                asyncio.set_event_loop(loop)

                        async def do_update():
                            try:
                                await status_message.edit_text(progress_text, parse_mode='Markdown')
                            except Exception as e:
                                logger.warning(f"å‘é€Apple Musicè¿›åº¦åˆ°TGå¤±è´¥: {e}")

                        asyncio.run_coroutine_threadsafe(do_update(), loop)
                    return
                    
                else:
                    # å…¶ä»–é˜¶æ®µï¼Œç®€åŒ–å¤„ç†ï¼Œé¿å…å¾ªç¯
                    logger.debug(f"ğŸ Apple Music é˜¶æ®µ: {phase}")
                    return
                
            except Exception as e:
                logger.error(f"å¤„ç†Apple Musicè¿›åº¦ä¿¡æ¯æ—¶å‡ºé”™: {e}")
                return
        
        # å…¼å®¹æ—§çš„å­—ç¬¦ä¸²ç±»å‹ï¼Œç›´æ¥å‘åˆ°Telegram
        if isinstance(progress_info, str):
            text = progress_info
            if message_updater and status_message:
                try:
                    loop = asyncio.get_running_loop()
                except RuntimeError:
                    try:
                        loop = asyncio.get_event_loop()
                    except RuntimeError:
                        loop = asyncio.new_event_loop()
                        asyncio.set_event_loop(loop)

                async def do_update():
                    try:
                        await status_message.edit_text(progress_info)
                    except Exception as e:
                        logger.warning(f"å‘é€å­—ç¬¦ä¸²è¿›åº¦åˆ°TGå¤±è´¥: {e}")

                asyncio.run_coroutine_threadsafe(do_update(), loop)
            return

    return progress_hook

# å…¨å±€å˜é‡ï¼Œåœ¨å‡½æ•°å¤–éƒ¨å®šä¹‰ï¼Œç¡®ä¿çŠ¶æ€æŒä¹…åŒ–
_netease_last_update_time = {"time": 0}

def netease_music_progress_hook(message_updater=None, progress_data=None, status_message=None, context=None):
    """
    ç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½è¿›åº¦å›è°ƒï¼Œå‚è€ƒYouTubeå•é›†ä¸‹è½½çš„è¿›åº¦æ˜¾ç¤ºæ ·å¼
    """
    import os
    import time
    import threading
    
    # å®šä¹‰å·¥å…·å‡½æ•°ï¼Œé¿å…ä½œç”¨åŸŸé—®é¢˜
    def _clean_filename_for_display_local(filename: str) -> str:
        try:
            import re
            # åªä¿ç•™æ–‡ä»¶åï¼Œç§»é™¤è·¯å¾„
            display_name = os.path.basename(filename) if filename else ""
            # ç§»é™¤æ—¶é—´æˆ³å‰ç¼€(10ä½æ•°å­—+ä¸‹åˆ’çº¿)
            if display_name and re.match(r"^\d{10}_", display_name):
                display_name = display_name[11:]
            # æ™ºèƒ½æˆªæ–­è¿‡é•¿æ–‡ä»¶å
            if len(display_name) > 35:
                name, ext = os.path.splitext(display_name)
                display_name = name[:30] + "..." + ext
            return display_name
        except Exception:
            filename = filename or ""
            # ç¡®ä¿åªè¿”å›æ–‡ä»¶å
            display_name = os.path.basename(filename)
            return display_name if len(display_name) <= 35 else display_name[:32] + "..."
    
    def _create_progress_bar_local(percent: float, length: int = 20) -> str:
        filled_length = int(length * percent / 100)
        return "â–ˆ" * filled_length + "â–‘" * (length - filled_length)
    


    # åˆå§‹åŒ–è¿›åº¦æ•°æ®
    if progress_data is None:
        progress_data = {"final_filename": None, "lock": threading.Lock()}

    # ä½¿ç”¨å…¨å±€å˜é‡ï¼Œç¡®ä¿çŠ¶æ€åœ¨å¤šæ¬¡è°ƒç”¨é—´æŒä¹…åŒ–
    global _netease_last_update_time
    last_update_time = _netease_last_update_time

    def progress_hook(d):
        # æ·»åŠ è°ƒè¯•æ—¥å¿—
        logger.info(f"ğŸ” [NETEASE_PROGRESS] æ”¶åˆ°è¿›åº¦å›è°ƒ: {d}")
        logger.info(f"ğŸ” [NETEASE_PROGRESS] status_message: {status_message is not None}, context: {context is not None}, message_updater: {message_updater is not None}")
        
        # æ”¯æŒå­—ç¬¦ä¸²ç±»å‹ï¼Œç›´æ¥å‘åˆ°Telegram
        if isinstance(d, str):
            if message_updater and status_message:
                try:
                    loop = asyncio.get_running_loop()
                except RuntimeError:
                    try:
                        loop = asyncio.get_event_loop()
                    except RuntimeError:
                        loop = asyncio.new_event_loop()
                        asyncio.set_event_loop(loop)

                async def do_update():
                    try:
                        await status_message.edit_text(d, parse_mode=None)
                    except Exception as e:
                        logger.warning(f"å‘é€å­—ç¬¦ä¸²è¿›åº¦åˆ°TGå¤±è´¥: {e}")

                asyncio.run_coroutine_threadsafe(do_update(), loop)
            return

        # æ·»åŠ ç±»å‹æ£€æŸ¥ï¼Œç¡®ä¿dæ˜¯å­—å…¸ç±»å‹
        if not isinstance(d, dict):
            logger.warning(f"netease_progress_hookæ¥æ”¶åˆ°éå­—å…¸ç±»å‹å‚æ•°: {type(d)}, å†…å®¹: {d}")
            return

        # æ›´æ–° progress_data
        try:
            if d['status'] == 'downloading':
                raw_filename = d.get('filename', '')
                display_filename = os.path.basename(raw_filename) if raw_filename else 'music.mp3'
                progress_data.update({
                    'filename': display_filename,
                    'total_bytes': d.get('total_bytes', 0),
                    'downloaded_bytes': d.get('downloaded_bytes', 0),
                    'speed': d.get('speed', 0),
                    'status': 'downloading',
                    'progress': (d.get('downloaded_bytes', 0) / d.get('total_bytes', 1)) * 100 if d.get('total_bytes', 0) > 0 else 0.0
                })
            elif d['status'] == 'finished':
                final_filename = d.get('filename', '')
                display_filename = os.path.basename(final_filename) if final_filename else 'music.mp3'
                progress_data.update({
                    'filename': display_filename,
                    'status': 'finished',
                    'final_filename': final_filename,
                    'progress': 100.0
                })
                logger.info(f"ğŸ“ ç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½å®Œæˆ: {final_filename}")
        except Exception as e:
            logger.error(f"æ›´æ–°ç½‘æ˜“äº‘éŸ³ä¹è¿›åº¦æ•°æ®é”™è¯¯: {str(e)}")

        # å¦‚æœæ²¡æœ‰status_messageå’Œcontextï¼Œä½¿ç”¨ç®€å•çš„message_updaterï¼ˆä½†ä»è¦æ‰§è¡Œå®Œæ•´çš„è¿›åº¦æ˜¾ç¤ºé€»è¾‘ï¼‰
        simple_mode = not status_message or not context
        logger.info(f"ğŸ” [NETEASE_PROGRESS] simple_mode: {simple_mode}")
        
        if simple_mode and message_updater:
            logger.info(f"ğŸ” netease_progress_hook ç®€å•æ¨¡å¼: status={d.get('status')}")

            # ç®€å•æ¨¡å¼ï¼ˆå‚è€ƒApple Musicå®ç°ï¼Œç§»é™¤é¢‘ç‡æ§åˆ¶ï¼‰
            # ä¸ºç®€å•æ¨¡å¼åˆ›å»ºæ ¼å¼åŒ–çš„è¿›åº¦æ–‡æœ¬
            try:
                if isinstance(d, dict) and d.get('status') == 'downloading':
                    downloaded_bytes = d.get('downloaded_bytes', 0)
                    speed = d.get('speed', 0)
                    filename = d.get('filename', 'music.mp3')
                    total_bytes = d.get('total_bytes', 0)
                    
                    if total_bytes > 0:
                        progress = (downloaded_bytes / total_bytes) * 100
                        speed_mb = speed / (1024 * 1024) if speed > 0 else 0
                        total_mb = total_bytes / (1024 * 1024)
                        downloaded_mb = downloaded_bytes / (1024 * 1024)
                        
                        # è®¡ç®—é¢„è®¡å‰©ä½™æ—¶é—´
                        if speed > 0 and total_bytes > downloaded_bytes:
                            remaining = total_bytes - downloaded_bytes
                            eta_seconds = int(remaining / speed)
                            mins, secs = divmod(eta_seconds, 60)
                            if mins > 0:
                                eta_str = f"{mins:02d}:{secs:02d}"
                            else:
                                eta_str = f"00:{secs:02d}"
                        else:
                            eta_str = "æœªçŸ¥"
                        
                        # åˆ›å»ºè¿›åº¦æ¡ï¼ˆå’Œå•é›†ä¸‹è½½ä¸€æ ·çš„æ ·å¼ï¼‰
                        progress_bar = _create_progress_bar(progress)
                        
                        # ä½¿ç”¨å’Œå•é›†ä¸‹è½½ç›¸åŒçš„æ ¼å¼
                        display_filename = _clean_filename_for_display(filename)
                        progress_text = (
                            f"ğŸ“ æ–‡ä»¶: `{display_filename}`\n"
                            f"ğŸ’¾ å¤§å°: `{downloaded_mb:.2f}MB / {total_mb:.2f}MB`\n"
                            f"âš¡ é€Ÿåº¦: `{speed_mb:.2f}MB/s`\n"
                            f"â³ é¢„è®¡å‰©ä½™: `{eta_str}`\n"
                            f"ğŸ“Š è¿›åº¦: {progress_bar} `{progress:.1f}%`"
                        )
                    else:
                        display_filename = _clean_filename_for_display(filename)
                        progress_text = (
                            f"ğŸ“ æ–‡ä»¶: `{display_filename}`\n"
                            f"ğŸ’¾ å¤§å°: æœªçŸ¥\n"
                            f"âš¡ é€Ÿåº¦: æœªçŸ¥\n"
                            f"â³ é¢„è®¡å‰©ä½™: æœªçŸ¥\n"
                            f"ğŸ“Š è¿›åº¦: ä¸‹è½½ä¸­..."
                        )
                        
                    # ä½¿ç”¨æ™®é€šæ–‡æœ¬
                    simple_message = progress_text
                    
                    # å‘é€æ¶ˆæ¯åˆ°Telegram
                    try:
                        loop = asyncio.get_running_loop()
                    except RuntimeError:
                        try:
                            loop = asyncio.get_event_loop()
                        except RuntimeError:
                            loop = asyncio.new_event_loop()
                            asyncio.set_event_loop(loop)

                    async def do_update():
                        try:
                            await status_message.edit_text(simple_message, parse_mode=None)
                        except Exception as e:
                            logger.warning(f"å‘é€ç®€å•æ¨¡å¼è¿›åº¦åˆ°TGå¤±è´¥: {e}")

                    asyncio.run_coroutine_threadsafe(do_update(), loop)
                    
                elif isinstance(d, dict) and d.get('status') == 'finished':
                    filename = d.get('filename', 'music.mp3')
                    total_bytes = d.get('total_bytes', 0)
                    total_mb = total_bytes / (1024 * 1024) if total_bytes > 0 else 0
                    
                    # ä½¿ç”¨å’Œå•é›†ä¸‹è½½ç›¸åŒçš„å®Œæˆæ ¼å¼
                    display_filename = _clean_filename_for_display(filename)
                    progress_bar = _create_progress_bar(100.0)
                    finish_text = (
                        f"ğŸ“ æ–‡ä»¶: `{display_filename}`\n"
                        f"ğŸ’¾ å¤§å°: `{total_mb:.2f}MB`\n"
                        f"âš¡ é€Ÿåº¦: å®Œæˆ\n"
                        f"â³ é¢„è®¡å‰©ä½™: 0ç§’\n"
                        f"ğŸ“Š è¿›åº¦: {progress_bar} `100.0%`"
                    )
                    # ä½¿ç”¨æ™®é€šæ–‡æœ¬
                    simple_message = finish_text
                    
                    # å‘é€æ¶ˆæ¯åˆ°Telegram
                    try:
                        loop = asyncio.get_running_loop()
                    except RuntimeError:
                        try:
                            loop = asyncio.get_event_loop()
                        except RuntimeError:
                            loop = asyncio.new_event_loop()
                            asyncio.set_event_loop(loop)

                    async def do_update():
                        try:
                            await status_message.edit_text(simple_message, parse_mode=None)
                        except Exception as e:
                            logger.warning(f"å‘é€ç®€å•æ¨¡å¼å®Œæˆæ¶ˆæ¯åˆ°TGå¤±è´¥: {e}")

                    asyncio.run_coroutine_threadsafe(do_update(), loop)
                
            except Exception as e:
                logger.warning(f"ç½‘æ˜“äº‘éŸ³ä¹ç®€å•æ¨¡å¼å›è°ƒå¤±è´¥: {e}")
        elif simple_mode:
            logger.warning("âš ï¸ ç½‘æ˜“äº‘éŸ³ä¹ç®€å•æ¨¡å¼ä½†æ— message_updater")
        
        # ç»§ç»­æ‰§è¡Œå®Œæ•´çš„è¿›åº¦æ˜¾ç¤ºé€»è¾‘ï¼ˆæ— è®ºæ˜¯å¦ä¸ºç®€å•æ¨¡å¼ï¼‰

        # å®Œæ•´çš„è¿›åº¦æ˜¾ç¤ºé€»è¾‘ï¼ˆå‚è€ƒApple Musicå®ç°ï¼Œç§»é™¤é¢‘ç‡æ§åˆ¶ï¼‰
        logger.info(f"ğŸ” [NETEASE_PROGRESS] è¿›å…¥å®Œæ•´è¿›åº¦æ˜¾ç¤ºé€»è¾‘: status={d.get('status')}")

        # å¤„ç†ä¸‹è½½ä¸­çŠ¶æ€
        if d.get('status') == 'downloading':
            logger.info(f"ğŸ” [NETEASE_PROGRESS] å¤„ç†ä¸‹è½½ä¸­çŠ¶æ€")

            total_bytes = d.get('total_bytes', 0)
            downloaded_bytes = d.get('downloaded_bytes', 0)
            speed_bytes_s = d.get('speed', 0)
            eta_seconds = d.get('eta', 0)
            filename = d.get('filename', '') or "æ­£åœ¨ä¸‹è½½..."
            now = time.time()

            # è®¡ç®—è¿›åº¦
            if total_bytes > 0:
                progress = (downloaded_bytes / total_bytes) * 100
                progress_bar = _create_progress_bar(progress)
                size_mb = total_bytes / (1024 * 1024)
                speed_mb = (speed_bytes_s or 0) / (1024 * 1024)

                # è®¡ç®—é¢„è®¡å‰©ä½™æ—¶é—´
                eta_text = ""
                if speed_bytes_s and total_bytes and downloaded_bytes < total_bytes:
                    remaining = total_bytes - downloaded_bytes
                    eta = int(remaining / speed_bytes_s)
                    mins, secs = divmod(eta, 60)
                    if mins > 0:
                        eta_text = f"{mins}åˆ†{secs}ç§’"
                    else:
                        eta_text = f"{secs}ç§’"
                elif speed_bytes_s:
                    eta_text = "è®¡ç®—ä¸­"
                else:
                    eta_text = "æœªçŸ¥"

                display_filename = _clean_filename_for_display(filename)
                progress_text = (
                    f"ğŸµ éŸ³ä¹ï¼š{display_filename}\n"
                    f"ğŸ’¾ å¤§å°ï¼š{downloaded_bytes/(1024*1024):.2f}MB / {size_mb:.2f}MB\n"
                    f"âš¡ é€Ÿåº¦ï¼š{speed_mb:.2f}MB/s\n"
                    f"â³ é¢„è®¡å‰©ä½™ï¼š{eta_text}\n"
                    f"ğŸ“Š è¿›åº¦ï¼š{progress_bar} ({progress:.1f}%)"
                )

                async def do_update():
                    try:
                        await status_message.edit_text(progress_text)
                        logger.info(f"ğŸ“± æ›´æ–°Telegramè¿›åº¦: {progress:.1f}% - æ–‡ä»¶: {display_filename}")
                        # æ›´æ–°æˆåŠŸåæ‰æ›´æ–°æ—¶é—´æˆ³
                        last_update_time['time'] = now
                    except Exception as e:
                        logger.warning(f"ğŸ” [NETEASE_PROGRESS] æ›´æ–°ç½‘æ˜“äº‘éŸ³ä¹è¿›åº¦å¤±è´¥: {e}")
                        if "Message is not modified" not in str(e):
                            # å¤‡ç”¨ï¼šå¦‚æœstatus_messageæ›´æ–°å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨message_updater
                            if message_updater:
                                try:
                                    logger.info(f"ğŸ” [NETEASE_PROGRESS] å°è¯•ä½¿ç”¨å¤‡ç”¨message_updater")
                                    if asyncio.iscoroutinefunction(message_updater):
                                        await message_updater(progress_text)
                                    else:
                                        message_updater(progress_text)
                                    logger.info("âœ… ä½¿ç”¨å¤‡ç”¨message_updateræ›´æ–°æˆåŠŸ")
                                    # å¤‡ç”¨æ–¹æ¡ˆæˆåŠŸä¹Ÿæ›´æ–°æ—¶é—´æˆ³
                                    last_update_time['time'] = now
                                except Exception as backup_e:
                                    logger.warning(f"å¤‡ç”¨message_updaterä¹Ÿå¤±è´¥: {backup_e}")

                try:
                    loop = asyncio.get_running_loop()
                except RuntimeError:
                    try:
                        loop = asyncio.get_event_loop()
                    except RuntimeError:
                        loop = asyncio.new_event_loop()
                        asyncio.set_event_loop(loop)

                if loop.is_running():
                    # äº‹ä»¶å¾ªç¯æ­£åœ¨è¿è¡Œï¼Œä½¿ç”¨ run_coroutine_threadsafe
                    try:
                        future = asyncio.run_coroutine_threadsafe(do_update(), loop)
                        # å°è¯•è·å–ç»“æœï¼Œè®¾ç½®çŸ­è¶…æ—¶
                        try:
                            result = future.result(timeout=0.1)
                        except asyncio.TimeoutError:
                            pass  # è¶…æ—¶æ˜¯æ­£å¸¸çš„ï¼Œä»»åŠ¡åœ¨åå°æ‰§è¡Œ
                        except Exception as e:
                            logger.error(f"ğŸ” [NETEASE_PROGRESS] è¿›åº¦æ›´æ–°ä»»åŠ¡æ‰§è¡Œå¤±è´¥: {e}")
                    except Exception as e:
                        logger.error(f"ğŸ” [NETEASE_PROGRESS] æäº¤è¿›åº¦æ›´æ–°ä»»åŠ¡å¤±è´¥: {e}")
                else:
                    # äº‹ä»¶å¾ªç¯æ²¡æœ‰è¿è¡Œï¼Œç›´æ¥è¿è¡Œåç¨‹
                    try:
                        asyncio.run(do_update())
                    except Exception as e:
                        logger.error(f"ğŸ” [NETEASE_PROGRESS] ç›´æ¥è¿è¡Œåç¨‹å¤±è´¥: {e}")
            return

        # å¤„ç†ä¸‹è½½å®ŒæˆçŠ¶æ€ - ç›´æ¥æ˜¾ç¤ºå®Œæˆä¿¡æ¯å¹¶è¿”å›
        if d.get('status') == 'finished':
            logger.info("ğŸµ ç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½å®Œæˆï¼Œæ˜¾ç¤ºå®Œæˆä¿¡æ¯")

            # è·å–è¿›åº¦ä¿¡æ¯
            filename = progress_data.get('filename', 'music.mp3')
            total_bytes = progress_data.get('total_bytes', 0)
            downloaded_bytes = progress_data.get('downloaded_bytes', 0)

            # æ˜¾ç¤ºå®Œæˆä¿¡æ¯
            display_filename = _clean_filename_for_display(filename)
            progress_bar = _create_progress_bar(100.0)
            size_mb = total_bytes / (1024 * 1024) if total_bytes > 0 else downloaded_bytes / (1024 * 1024)

            completion_text = (
                f"ğŸµ éŸ³ä¹ï¼š{display_filename}\n"
                f"ğŸ’¾ å¤§å°ï¼š{size_mb:.2f}MB\n"
                f"âš¡ é€Ÿåº¦ï¼šå®Œæˆ\n"
                f"â³ é¢„è®¡å‰©ä½™ï¼š0ç§’\n"
                f"ğŸ“Š è¿›åº¦ï¼š{progress_bar} (100.0%)"
            )

            async def do_update():
                try:
                    await status_message.edit_text(completion_text)
                    logger.info("ğŸµ æ˜¾ç¤ºç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½å®Œæˆè¿›åº¦ä¿¡æ¯")
                    # æ›´æ–°æˆåŠŸåæ‰æ›´æ–°æ—¶é—´æˆ³
                    last_update_time['time'] = now
                except Exception as e:
                    logger.warning(f"æ˜¾ç¤ºç½‘æ˜“äº‘éŸ³ä¹å®Œæˆè¿›åº¦ä¿¡æ¯å¤±è´¥: {e}")
                    # å¤‡ç”¨ï¼šå¦‚æœstatus_messageæ›´æ–°å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨message_updater
                    if message_updater:
                        try:
                            if asyncio.iscoroutinefunction(message_updater):
                                await message_updater(completion_text)
                            else:
                                message_updater(completion_text)
                            logger.info("âœ… ä½¿ç”¨å¤‡ç”¨message_updateræ˜¾ç¤ºå®Œæˆä¿¡æ¯æˆåŠŸ")
                            # å¤‡ç”¨æ–¹æ¡ˆæˆåŠŸä¹Ÿæ›´æ–°æ—¶é—´æˆ³
                            last_update_time['time'] = now
                        except Exception as backup_e:
                            logger.warning(f"å¤‡ç”¨message_updateræ˜¾ç¤ºå®Œæˆä¿¡æ¯ä¹Ÿå¤±è´¥: {backup_e}")

            try:
                loop = asyncio.get_running_loop()
            except RuntimeError:
                try:
                    loop = asyncio.get_event_loop()
                except RuntimeError:
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)

            if loop.is_running():
                # äº‹ä»¶å¾ªç¯æ­£åœ¨è¿è¡Œï¼Œä½¿ç”¨ run_coroutine_threadsafe
                try:
                    future = asyncio.run_coroutine_threadsafe(do_update(), loop)
                    # å°è¯•è·å–ç»“æœï¼Œè®¾ç½®çŸ­è¶…æ—¶
                    try:
                        result = future.result(timeout=0.1)
                    except asyncio.TimeoutError:
                        pass  # è¶…æ—¶æ˜¯æ­£å¸¸çš„ï¼Œä»»åŠ¡åœ¨åå°æ‰§è¡Œ
                    except Exception as e:
                        logger.error(f"ğŸ” [NETEASE_PROGRESS] å®ŒæˆçŠ¶æ€æ›´æ–°ä»»åŠ¡æ‰§è¡Œå¤±è´¥: {e}")
                except Exception as e:
                    logger.error(f"ğŸ” [NETEASE_PROGRESS] æäº¤å®ŒæˆçŠ¶æ€æ›´æ–°ä»»åŠ¡å¤±è´¥: {e}")
            else:
                # äº‹ä»¶å¾ªç¯æ²¡æœ‰è¿è¡Œï¼Œç›´æ¥è¿è¡Œåç¨‹
                try:
                    asyncio.run(do_update())
                except Exception as e:
                    logger.error(f"ğŸ” [NETEASE_PROGRESS] ç›´æ¥è¿è¡Œå®ŒæˆçŠ¶æ€åç¨‹å¤±è´¥: {e}")
            return

        # å¤„ç†ä¸‹è½½ä¸­çŠ¶æ€
        if d.get('status') == 'downloading':
            last_update_time['time'] = now

            total_bytes = d.get('total_bytes', 0)
            downloaded_bytes = d.get('downloaded_bytes', 0)
            speed_bytes_s = d.get('speed', 0)
            eta_seconds = d.get('eta', 0)
            filename = d.get('filename', '') or "æ­£åœ¨ä¸‹è½½..."

            # è®¡ç®—è¿›åº¦
            if total_bytes > 0:
                progress = (downloaded_bytes / total_bytes) * 100
                progress_bar = _create_progress_bar(progress)
                size_mb = total_bytes / (1024 * 1024)
                speed_mb = (speed_bytes_s or 0) / (1024 * 1024)

                # è®¡ç®—é¢„è®¡å‰©ä½™æ—¶é—´
                eta_text = ""
                if speed_bytes_s and total_bytes and downloaded_bytes < total_bytes:
                    remaining = total_bytes - downloaded_bytes
                    eta = int(remaining / speed_bytes_s)
                    mins, secs = divmod(eta, 60)
                    if mins > 0:
                        eta_text = f"{mins}åˆ†{secs}ç§’"
                    else:
                        eta_text = f"{secs}ç§’"
                elif speed_bytes_s:
                    eta_text = "è®¡ç®—ä¸­"
                else:
                    eta_text = "æœªçŸ¥"

                display_filename = _clean_filename_for_display(filename)
                progress_text = (
                    f"ğŸµ éŸ³ä¹ï¼š{display_filename}\n"
                    f"ğŸ’¾ å¤§å°ï¼š{downloaded_bytes/(1024*1024):.2f}MB / {size_mb:.2f}MB\n"
                    f"âš¡ é€Ÿåº¦ï¼š{speed_mb:.2f}MB/s\n"
                    f"â³ é¢„è®¡å‰©ä½™ï¼š{eta_text}\n"
                    f"ğŸ“Š è¿›åº¦ï¼š{progress_bar} ({progress:.1f}%)"
                )

                async def do_update():
                    try:
                        await status_message.edit_text(progress_text)
                    except Exception as e:
                        if "Message is not modified" not in str(e):
                            logger.warning(f"æ›´æ–°ç½‘æ˜“äº‘éŸ³ä¹è¿›åº¦å¤±è´¥: {e}")
                            # å¤‡ç”¨ï¼šå¦‚æœstatus_messageæ›´æ–°å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨message_updater
                            if message_updater:
                                try:
                                    if asyncio.iscoroutinefunction(message_updater):
                                        await message_updater(progress_text)
                                    else:
                                        message_updater(progress_text)
                                    logger.info("âœ… ä½¿ç”¨å¤‡ç”¨message_updateræ›´æ–°æˆåŠŸ")
                                except Exception as backup_e:
                                    logger.warning(f"å¤‡ç”¨message_updaterä¹Ÿå¤±è´¥: {backup_e}")

                try:
                    loop = asyncio.get_running_loop()
                except RuntimeError:
                    try:
                        loop = asyncio.get_event_loop()
                    except RuntimeError:
                        loop = asyncio.new_event_loop()
                        asyncio.set_event_loop(loop)

                asyncio.run_coroutine_threadsafe(do_update(), loop)

        # å¤„ç†ä¸‹è½½å®ŒæˆçŠ¶æ€ - ç›´æ¥æ˜¾ç¤ºå®Œæˆä¿¡æ¯å¹¶è¿”å›
        if d.get('status') == 'finished':
            logger.info("ğŸµ ç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½å®Œæˆï¼Œæ˜¾ç¤ºå®Œæˆä¿¡æ¯")

            # è·å–è¿›åº¦ä¿¡æ¯
            if progress_data and isinstance(progress_data, dict):
                filename = progress_data.get('filename', 'music.mp3')
                total_bytes = progress_data.get('total_bytes', 0)
                downloaded_bytes = progress_data.get('downloaded_bytes', 0)
            else:
                filename = 'music.mp3'
                total_bytes = 0
                downloaded_bytes = 0

            # æ˜¾ç¤ºå®Œæˆä¿¡æ¯
            display_filename = _clean_filename_for_display_local(filename)
            progress_bar = _create_progress_bar_local(100.0)
            size_mb = total_bytes / (1024 * 1024) if total_bytes > 0 else downloaded_bytes / (1024 * 1024)

            completion_text = (
                f"ğŸµ éŸ³ä¹ï¼š{display_filename}\n"
                f"ğŸ’¾ å¤§å°ï¼š{size_mb:.2f}MB\n"
                f"âš¡ é€Ÿåº¦ï¼šå®Œæˆ\n"
                f"â³ é¢„è®¡å‰©ä½™ï¼š0ç§’\n"
                f"ğŸ“Š è¿›åº¦ï¼š{progress_bar} (100.0%)"
            )

            async def do_update():
                try:
                    await status_message.edit_text(completion_text, parse_mode=None)
                    logger.info("ğŸµ æ˜¾ç¤ºç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½å®Œæˆè¿›åº¦ä¿¡æ¯")
                except Exception as e:
                    logger.warning(f"æ˜¾ç¤ºç½‘æ˜“äº‘éŸ³ä¹å®Œæˆè¿›åº¦ä¿¡æ¯å¤±è´¥: {e}")
                    # å¤‡ç”¨ï¼šå¦‚æœstatus_messageæ›´æ–°å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨message_updater
                    if message_updater:
                        try:
                            if asyncio.iscoroutinefunction(message_updater):
                                await message_updater(completion_text)
                            else:
                                message_updater(completion_text)
                            logger.info("âœ… ä½¿ç”¨å¤‡ç”¨message_updateræ˜¾ç¤ºå®Œæˆä¿¡æ¯æˆåŠŸ")
                        except Exception as backup_e:
                            logger.warning(f"å¤‡ç”¨message_updateræ˜¾ç¤ºå®Œæˆä¿¡æ¯ä¹Ÿå¤±è´¥: {backup_e}")

            try:
                loop = asyncio.get_running_loop()
            except RuntimeError:
                try:
                    loop = asyncio.get_event_loop()
                except RuntimeError:
                    loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(loop)

            asyncio.run_coroutine_threadsafe(do_update(), loop)
            return

        # å¤„ç†ä¸‹è½½ä¸­çŠ¶æ€
        if d.get('status') == 'downloading':
            last_update_time['time'] = now

            total_bytes = d.get('total_bytes', 0)
            downloaded_bytes = d.get('downloaded_bytes', 0)
            speed_bytes_s = d.get('speed', 0)
            eta_seconds = d.get('eta', 0)
            filename = d.get('filename', '') or "æ­£åœ¨ä¸‹è½½..."

            # è®¡ç®—è¿›åº¦
            if total_bytes > 0:
                progress = (downloaded_bytes / total_bytes) * 100
                progress_bar = _create_progress_bar_local(progress)
                size_mb = total_bytes / (1024 * 1024)
                speed_mb = (speed_bytes_s or 0) / (1024 * 1024)

                # è®¡ç®—é¢„è®¡å‰©ä½™æ—¶é—´
                eta_text = ""
                if speed_bytes_s and total_bytes and downloaded_bytes < total_bytes:
                    remaining = total_bytes - downloaded_bytes
                    eta = int(remaining / speed_bytes_s)
                    mins, secs = divmod(eta, 60)
                    if mins > 0:
                        eta_text = f"{mins}åˆ†{secs}ç§’"
                    else:
                        eta_text = f"{secs}ç§’"
                elif speed_bytes_s:
                    eta_text = "è®¡ç®—ä¸­"
                else:
                    eta_text = "æœªçŸ¥"

                display_filename = _clean_filename_for_display_local(filename)
                progress_text = (
                    f"ğŸµ éŸ³ä¹ï¼š{display_filename}\n"
                    f"ğŸ’¾ å¤§å°ï¼š{size_mb:.2f}MB\n"
                    f"âš¡ é€Ÿåº¦ï¼š{speed_mb:.2f}MB/s\n"
                    f"â³ é¢„è®¡å‰©ä½™ï¼š{eta_text}\n"
                    f"ğŸ“Š è¿›åº¦ï¼š{progress_bar} ({progress:.1f}%)"
                )

                async def do_update():
                    try:
                        await status_message.edit_text(progress_text, parse_mode=None)
                    except Exception as e:
                        if "Message is not modified" not in str(e):
                            logger.warning(f"æ›´æ–°ç½‘æ˜“äº‘éŸ³ä¹è¿›åº¦å¤±è´¥: {e}")
                            # å¤‡ç”¨ï¼šå¦‚æœstatus_messageæ›´æ–°å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨message_updater
                            if message_updater:
                                try:
                                    if asyncio.iscoroutinefunction(message_updater):
                                        await message_updater(progress_text)
                                    else:
                                        message_updater(progress_text)
                                    logger.info("âœ… ä½¿ç”¨å¤‡ç”¨message_updateræ›´æ–°æˆåŠŸ")
                                except Exception as backup_e:
                                    logger.warning(f"å¤‡ç”¨message_updaterä¹Ÿå¤±è´¥: {backup_e}")

                try:
                    loop = asyncio.get_running_loop()
                except RuntimeError:
                    try:
                        loop = asyncio.get_event_loop()
                    except RuntimeError:
                        loop = asyncio.new_event_loop()
                        asyncio.set_event_loop(loop)

                asyncio.run_coroutine_threadsafe(do_update(), loop)

    return progress_hook
class VideoDownloader:
    # å¹³å°æšä¸¾å®šä¹‰
    class Platform(str, Enum):
        DOUYIN = "douyin"
        KUAISHOU = "kuaishou"
        XIAOHONGSHU = "xiaohongshu"
        UNKNOWN = "unknown"

    def __init__(
        self,
        base_download_path: str,
        x_cookies_path: str = None,
        b_cookies_path: str = None,
        youtube_cookies_path: str = None,
        douyin_cookies_path: str = None,
        kuaishou_cookies_path: str = None,
        facebook_cookies_path: str = None,
        instagram_cookies_path: str = None,
    ):
        self.download_path = Path(base_download_path).resolve()
        self.x_download_path = self.download_path / "X"
        self.bilibili_download_path = self.download_path / "Bilibili"
        self.youtube_download_path = self.download_path / "YouTube"
        self.music_download_path = self.download_path / "Music"
        self.pornhub_download_path = self.download_path / "Pornhub"
        self.telegram_download_path = self.download_path / "Telegram"
        self.telegraph_download_path = self.download_path / "Telegraph"
        self.douyin_download_path = self.download_path / "Douyin"
        self.kuaishou_download_path = self.download_path / "Kuaishou"
        self.toutiao_download_path = self.download_path / "Toutiao"
        self.facebook_download_path = self.download_path / "Facebook"
        self.weibo_download_path = self.download_path / "Weibo"
        self.instagram_download_path = self.download_path / "Instagram"
        self.tiktok_download_path = self.download_path / "TikTok"
        self.netease_download_path = self.download_path / "NeteaseCloudMusic"
        self.qqmusic_download_path = self.download_path / "QQMusic"
        self.youtubemusic_download_path = Path("/downloads/YouTubeMusic")
        self.apple_music_download_path = self.download_path / "AppleMusic"
        self.x_cookies_path = x_cookies_path
        self.b_cookies_path = b_cookies_path
        self.youtube_cookies_path = youtube_cookies_path
        self.douyin_cookies_path = douyin_cookies_path
        self.kuaishou_cookies_path = kuaishou_cookies_path
        self.facebook_cookies_path = facebook_cookies_path
        self.instagram_cookies_path = instagram_cookies_path
        self.apple_music_cookies_path = os.environ.get("APPLEMUSIC_COOKIES") or os.environ.get("APPLEMUSIC_COOKIE_FILE") or "/app/cookies/apple_music_cookies.txt"
        self.proxy_host = os.environ.get("PROXY_HOST")
        
        # åˆå§‹åŒ– Instagram ä¸‹è½½å™¨
        try:
            from Instagram_downloader import InstagramPicDownloaderSimple
            self.instagram_downloader = InstagramPicDownloaderSimple(
                cookies_path=self.instagram_cookies_path or "/app/cookies/instagram_cookies.txt"
            )
            logger.info("âœ… Instagram ä¸‹è½½å™¨åˆå§‹åŒ–æˆåŠŸ")
        except ImportError as e:
            logger.warning(f"âš ï¸ Instagram ä¸‹è½½å™¨å¯¼å…¥å¤±è´¥: {e}")
            self.instagram_downloader = None
        except Exception as e:
            logger.error(f"âŒ Instagram ä¸‹è½½å™¨åˆå§‹åŒ–å¤±è´¥: {e}")
            self.instagram_downloader = None

        # åˆå§‹åŒ– Apple Music ä¸‹è½½å™¨
        try:
            # æ£€æŸ¥ç¯å¢ƒå˜é‡ï¼Œå†³å®šä½¿ç”¨å“ªä¸ªä¸‹è½½å™¨
            # å¦‚æœæ²¡æœ‰è®¾ç½®AMDPç¯å¢ƒå˜é‡ï¼Œå°è¯•è‡ªåŠ¨æ£€æµ‹AMDä¸‹è½½å™¨æ˜¯å¦å¯ç”¨
            amdp_env = os.environ.get("AMDP", "")
            if not amdp_env:
                # è‡ªåŠ¨æ£€æµ‹ï¼šæ£€æŸ¥AMDå·¥å…·æ˜¯å¦å¯ç”¨
                amd_tool_path = "/app/amdp/amd"
                if os.path.exists(amd_tool_path) and os.access(amd_tool_path, os.X_OK):
                    logger.info("ğŸ” æ£€æµ‹åˆ°AMDå·¥å…·å¯ç”¨ï¼Œè‡ªåŠ¨å¯ç”¨AMDä¸‹è½½å™¨")
                    os.environ["AMDP"] = "true"
                    use_amd = True
                else:
                    logger.info("ğŸ” æœªæ£€æµ‹åˆ°AMDå·¥å…·ï¼Œä½¿ç”¨GAMDLä¸‹è½½å™¨")
                    use_amd = False
            else:
                use_amd = amdp_env.lower() == "true"
            
            logger.info(f"ğŸ”§ Apple Music ä¸‹è½½å™¨ç¯å¢ƒå˜é‡ AMDP: {os.environ.get('AMDP', 'æœªè®¾ç½®')} -> ä½¿ç”¨AMD: {use_amd}")
            
            # å¯¼å…¥ asyncio æ¨¡å—
            import asyncio
            
            # æ£€æŸ¥å½“å‰äº‹ä»¶å¾ªç¯çŠ¶æ€
            try:
                current_loop = asyncio.get_running_loop()
                logger.info(f"ğŸ” æ£€æµ‹åˆ°è¿è¡Œä¸­çš„äº‹ä»¶å¾ªç¯: {current_loop}")
                has_running_loop = True
            except RuntimeError:
                logger.info("âœ… æ²¡æœ‰è¿è¡Œä¸­çš„äº‹ä»¶å¾ªç¯")
                has_running_loop = False
            
            if use_amd:
                # ä½¿ç”¨æ–°çš„ apple-music-downloader åç«¯
                logger.info("ğŸš€ å°è¯•åˆå§‹åŒ– Apple Music Plus ä¸‹è½½å™¨ (AMD)")
                
                # åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­åˆå§‹åŒ–ä¸‹è½½å™¨ï¼Œé¿å…äº‹ä»¶å¾ªç¯å†²çª
                def init_apple_music_downloader():
                    """åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­åˆå§‹åŒ–Apple Musicä¸‹è½½å™¨"""
                    try:
                        from applemusic_downloader_plus import AppleMusicDownloaderPlus
                        
                        # æ£€æŸ¥è¾“å‡ºç›®å½•
                        output_dir = str(self.apple_music_download_path)
                        if not os.path.exists(output_dir):
                            os.makedirs(output_dir, exist_ok=True)
                        
                        # ç¡®ä¿AMDå·¥å…·ç›®å½•å­˜åœ¨
                        amd_dir = "/app/amdp"
                        if not os.path.exists(amd_dir):
                            os.makedirs(amd_dir, exist_ok=True)
                            logger.info(f"âœ… åˆ›å»ºAMDå·¥å…·ç›®å½•: {amd_dir}")
                        
                        # æ£€æŸ¥AMDå·¥å…·æ˜¯å¦å¯ç”¨
                        amd_tool_path = os.path.join(amd_dir, "amd")
                        if not os.path.exists(amd_tool_path):
                            logger.warning(f"âš ï¸ AMDå·¥å…·ä¸å­˜åœ¨: {amd_tool_path}")
                        elif not os.access(amd_tool_path, os.X_OK):
                            logger.warning(f"âš ï¸ AMDå·¥å…·ä¸å¯æ‰§è¡Œ: {amd_tool_path}")
                            try:
                                os.chmod(amd_tool_path, 0o755)
                                logger.info("âœ… ä¿®å¤AMDå·¥å…·æƒé™æˆåŠŸ")
                            except Exception as e:
                                logger.error(f"âŒ ä¿®å¤AMDå·¥å…·æƒé™å¤±è´¥: {e}")
                        
                        downloader = AppleMusicDownloaderPlus(
                            output_dir=output_dir,
                            cookies_path=self.apple_music_cookies_path
                        )
                        
                        # æ£€æŸ¥ä¸‹è½½å™¨æ˜¯å¦çœŸæ­£å¯ç”¨
                        if hasattr(downloader, 'is_available'):
                            is_available = downloader.is_available()
                            if not is_available:
                                logger.error("âŒ Apple Music Plus ä¸‹è½½å™¨åˆå§‹åŒ–å¤±è´¥ï¼šå·¥å…·ä¸å¯ç”¨")
                                return None
                        
                        # é¢å¤–æ£€æŸ¥ï¼šç¡®ä¿æœ‰å¯ç”¨çš„åç«¯
                        if hasattr(downloader, 'backends'):
                            available_backends = [b for b in downloader.backends if b.is_available()]
                            if not available_backends:
                                logger.error("âŒ Apple Music Plus ä¸‹è½½å™¨åˆå§‹åŒ–å¤±è´¥ï¼šæ²¡æœ‰å¯ç”¨çš„åç«¯")
                                return None
                            logger.info(f"âœ… Apple Music Plus ä¸‹è½½å™¨åç«¯æ£€æŸ¥é€šè¿‡: {[b.name for b in available_backends]}")
                        
                        # éªŒè¯é…ç½®æ–‡ä»¶æ˜¯å¦æ­£ç¡®åˆ›å»º
                        config_path = os.path.join(amd_dir, "config.yaml")
                        if os.path.exists(config_path):
                            try:
                                with open(config_path, 'r', encoding='utf-8') as f:
                                    config_content = f.read()
                                if "alac-save-folder:" in config_content:
                                    logger.info("âœ… AMDé…ç½®æ–‡ä»¶éªŒè¯æˆåŠŸ")
                                else:
                                    logger.warning("âš ï¸ AMDé…ç½®æ–‡ä»¶å†…å®¹å¯èƒ½ä¸æ­£ç¡®")
                            except Exception as e:
                                logger.warning(f"âš ï¸ æ— æ³•è¯»å–AMDé…ç½®æ–‡ä»¶: {e}")
                        else:
                            logger.warning(f"âš ï¸ AMDé…ç½®æ–‡ä»¶ä¸å­˜åœ¨: {config_path}")
                        
                        return downloader
                        
                    except Exception as e:
                        logger.error(f"âŒ Apple Music Plus ä¸‹è½½å™¨åˆå§‹åŒ–å¤±è´¥: {e}")
                        import traceback
                        logger.error(f"ğŸ“‹ é”™è¯¯å †æ ˆ: {traceback.format_exc()}")
                        return None
                
                # å¦‚æœæœ‰è¿è¡Œçš„äº‹ä»¶å¾ªç¯ï¼Œä½¿ç”¨çº¿ç¨‹æ± åˆå§‹åŒ–
                if has_running_loop:
                    logger.info("ğŸ”„ åœ¨è¿è¡Œçš„äº‹ä»¶å¾ªç¯ä¸­ï¼Œä½¿ç”¨çº¿ç¨‹æ± åˆå§‹åŒ–ä¸‹è½½å™¨...")
                    with ThreadPoolExecutor(max_workers=1) as executor:
                        future = executor.submit(init_apple_music_downloader)
                        self.apple_music_downloader = future.result()
                else:
                    # æ²¡æœ‰è¿è¡Œçš„äº‹ä»¶å¾ªç¯ï¼Œç›´æ¥åˆå§‹åŒ–
                    logger.info("âœ… ç›´æ¥åˆå§‹åŒ–ä¸‹è½½å™¨...")
                    self.apple_music_downloader = init_apple_music_downloader()
                
                if self.apple_music_downloader:
                    logger.info("âœ… Apple Music Plus ä¸‹è½½å™¨(AMD)åˆå§‹åŒ–æˆåŠŸ")
                else:
                    logger.error("âŒ Apple Music Plus ä¸‹è½½å™¨åˆå§‹åŒ–å¤±è´¥")
                    
            else:
                # ä½¿ç”¨åŸæœ‰çš„ gamdl åç«¯
                logger.info("ğŸš€ å°è¯•åˆå§‹åŒ– Apple Music ä¸‹è½½å™¨ (GAMDL)")
                
                def init_gamdl_downloader():
                    """åœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­åˆå§‹åŒ–GAMDLä¸‹è½½å™¨"""
                    try:
                        from applemusic_downloader import AppleMusicDownloader
                        downloader = AppleMusicDownloader(
                            output_dir=str(self.apple_music_download_path),
                            cookies_path=self.apple_music_cookies_path
                        )
                        return downloader if downloader.gamdl_available else None
                    except Exception as e:
                        logger.error(f"âŒ GAMDLä¸‹è½½å™¨åˆå§‹åŒ–å¤±è´¥: {e}")
                        return None
                
                # å¦‚æœæœ‰è¿è¡Œçš„äº‹ä»¶å¾ªç¯ï¼Œä½¿ç”¨çº¿ç¨‹æ± åˆå§‹åŒ–
                if has_running_loop:
                    logger.info("ğŸ”„ åœ¨è¿è¡Œçš„äº‹ä»¶å¾ªç¯ä¸­ï¼Œä½¿ç”¨çº¿ç¨‹æ± åˆå§‹åŒ–GAMDLä¸‹è½½å™¨...")
                    with ThreadPoolExecutor(max_workers=1) as executor:
                        future = executor.submit(init_gamdl_downloader)
                        self.apple_music_downloader = future.result()
                else:
                    # æ²¡æœ‰è¿è¡Œçš„äº‹ä»¶å¾ªç¯ï¼Œç›´æ¥åˆå§‹åŒ–
                    logger.info("âœ… ç›´æ¥åˆå§‹åŒ–GAMDLä¸‹è½½å™¨...")
                    self.apple_music_downloader = init_gamdl_downloader()
                
                if self.apple_music_downloader:
                    logger.info("âœ… Apple Music ä¸‹è½½å™¨ (GAMDL) åˆå§‹åŒ–æˆåŠŸ")
                else:
                    logger.warning("âš ï¸ Apple Music ä¸‹è½½å™¨åˆå§‹åŒ–å¤±è´¥ï¼šgamdl ä¸å¯ç”¨")
                    
        except ImportError as e:
            logger.error(f"âŒ Apple Music ä¸‹è½½å™¨å¯¼å…¥å¤±è´¥: {e}")
            logger.error(f"ğŸ” è¯¦ç»†é”™è¯¯ä¿¡æ¯: {type(e).__name__}: {str(e)}")
            self.apple_music_downloader = None
        except Exception as e:
            logger.error(f"âŒ Apple Music ä¸‹è½½å™¨åˆå§‹åŒ–å¤±è´¥: {e}")
            logger.error(f"ğŸ” è¯¦ç»†é”™è¯¯ä¿¡æ¯: {type(e).__name__}: {str(e)}")
            import traceback
            logger.error(f"ğŸ“‹ é”™è¯¯å †æ ˆ: {traceback.format_exc()}")
            self.apple_music_downloader = None
        self._main_loop = None
        try:
            import asyncio

            self._main_loop = asyncio.get_running_loop()
        except Exception:
            self._main_loop = None
        # ä»ç¯å¢ƒå˜é‡è·å–æ˜¯å¦è½¬æ¢æ ¼å¼çš„é…ç½®
        self.convert_to_mp4 = (
            os.getenv("YOUTUBE_CONVERT_TO_MP4", "true").lower() == "true"
        )
        logger.info(f"è§†é¢‘æ ¼å¼è½¬æ¢: {'å¼€å¯' if self.convert_to_mp4 else 'å…³é—­'}")
        # è®¾ç½®å„å¹³å°ä¸‹è½½è·¯å¾„ï¼ˆä½¿ç”¨é»˜è®¤ç»“æ„ï¼‰
        self.x_download_path = self.download_path / "X"
        self.youtube_download_path = self.download_path / "YouTube"
        self.xvideos_download_path = self.download_path / "Xvideos"
        self.pornhub_download_path = self.download_path / "Pornhub"
        self.bilibili_download_path = self.download_path / "Bilibili"
        self.music_download_path = self.download_path / "Music"
        self.telegram_download_path = self.download_path / "Telegram"
        self.telegraph_download_path = self.download_path / "Telegraph"
        self.douyin_download_path = self.download_path / "Douyin"
        self.kuaishou_download_path = self.download_path / "Kuaishou"
        self.facebook_download_path = self.download_path / "Facebook"
        self.xiaohongshu_download_path = self.download_path / "Xiaohongshu"
        self.weibo_download_path = self.download_path / "Weibo"
        self.instagram_download_path = self.download_path / "Instagram"
        self.tiktok_download_path = self.download_path / "TikTok"
        self.netease_download_path = self.download_path / "NeteaseCloudMusic"
        self.qqmusic_download_path = self.download_path / "QQMusic"
        self.youtubemusic_download_path = Path("/downloads/YouTubeMusic")
        self.apple_music_download_path = self.download_path / "AppleMusic"
        # åˆ›å»ºæ‰€æœ‰ä¸‹è½½ç›®å½•
        for path in [
            self.x_download_path,
            self.youtube_download_path,
            self.xvideos_download_path,
            self.pornhub_download_path,
            self.bilibili_download_path,
            self.music_download_path,
            self.telegram_download_path,
            self.telegraph_download_path,
            self.douyin_download_path,
            self.kuaishou_download_path,
            self.facebook_download_path,
            self.xiaohongshu_download_path,
            self.weibo_download_path,
            self.instagram_download_path,
            self.tiktok_download_path,
            self.netease_download_path,
            self.qqmusic_download_path,
            self.youtubemusic_download_path,
            self.apple_music_download_path,
        ]:
            path.mkdir(parents=True, exist_ok=True)
        logger.info(f"X ä¸‹è½½è·¯å¾„: {self.x_download_path}")
        logger.info(f"YouTube ä¸‹è½½è·¯å¾„: {self.youtube_download_path}")
        logger.info(f"Xvideos ä¸‹è½½è·¯å¾„: {self.xvideos_download_path}")
        logger.info(f"Pornhub ä¸‹è½½è·¯å¾„: {self.pornhub_download_path}")
        logger.info(f"Bilibili ä¸‹è½½è·¯å¾„: {self.bilibili_download_path}")
        logger.info(f"éŸ³ä¹ä¸‹è½½è·¯å¾„: {self.music_download_path}")
        logger.info(f"Telegram æ–‡ä»¶ä¸‹è½½è·¯å¾„: {self.telegram_download_path}")
        logger.info(f"Telegraph æ–‡ä»¶ä¸‹è½½è·¯å¾„: {self.telegraph_download_path}")
        logger.info(f"æŠ–éŸ³ä¸‹è½½è·¯å¾„: {self.douyin_download_path}")
        logger.info(f"å¿«æ‰‹ä¸‹è½½è·¯å¾„: {self.kuaishou_download_path}")
        logger.info(f"Facebookä¸‹è½½è·¯å¾„: {self.facebook_download_path}")
        logger.info(f"å°çº¢ä¹¦ä¸‹è½½è·¯å¾„: {self.xiaohongshu_download_path}")
        logger.info(f"å¾®åšä¸‹è½½è·¯å¾„: {self.weibo_download_path}")
        logger.info(f"Instagramä¸‹è½½è·¯å¾„: {self.instagram_download_path}")
        logger.info(f"TikTokä¸‹è½½è·¯å¾„: {self.tiktok_download_path}")
        logger.info(f"ç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½è·¯å¾„: {self.netease_download_path}")
        logger.info(f"QQéŸ³ä¹ä¸‹è½½è·¯å¾„: {self.qqmusic_download_path}")
        logger.info(f"YouTube Musicä¸‹è½½è·¯å¾„: {self.youtubemusic_download_path}")
        logger.info(f"Apple Musicä¸‹è½½è·¯å¾„: {self.apple_music_download_path}")
        # å¦‚æœè®¾ç½®äº† Bilibili cookiesï¼Œè®°å½•æ—¥å¿—
        if self.b_cookies_path:
            logger.info(f"Bilibili Cookies è·¯å¾„: {self.b_cookies_path}")
        # å¦‚æœè®¾ç½®äº† YouTube cookiesï¼Œè®°å½•æ—¥å¿—
        if self.youtube_cookies_path:
            logger.info(f"ğŸª ä½¿ç”¨YouTube cookies: {self.youtube_cookies_path}")

        # å¦‚æœè®¾ç½®äº†æŠ–éŸ³ cookiesï¼Œè®°å½•æ—¥å¿—
        if self.douyin_cookies_path:
            logger.info(f"ğŸª ä½¿ç”¨æŠ–éŸ³ cookies: {self.douyin_cookies_path}")

        # å¦‚æœè®¾ç½®äº†å¿«æ‰‹ cookiesï¼Œè®°å½•æ—¥å¿—
        if self.kuaishou_cookies_path:
            logger.info(f"ğŸª ä½¿ç”¨å¿«æ‰‹ cookies: {self.kuaishou_cookies_path}")

        # å¦‚æœè®¾ç½®äº†Instagram cookiesï¼Œè®°å½•æ—¥å¿—
        if self.instagram_cookies_path:
            logger.info(f"ğŸª ä½¿ç”¨Instagram cookies: {self.instagram_cookies_path}")

        # æµ‹è¯•ä»£ç†è¿æ¥
        if self.proxy_host:
            if self._test_proxy_connection():
                logger.info(f"ä»£ç†æœåŠ¡å™¨å·²é…ç½®å¹¶è¿æ¥æˆåŠŸ: {self.proxy_host}")
                logger.info(f"yt-dlp ä½¿ç”¨ä»£ç†: {self.proxy_host}")
                # è®¾ç½®ç³»ç»Ÿä»£ç†ç¯å¢ƒå˜é‡
                os.environ['HTTP_PROXY'] = self.proxy_host
                os.environ['HTTPS_PROXY'] = self.proxy_host
                os.environ['NO_PROXY'] = 'localhost,127.0.0.1'
            else:
                logger.warning(f"ä»£ç†æœåŠ¡å™¨å·²é…ç½®ä½†è¿æ¥å¤±è´¥: {self.proxy_host}")
                logger.info("yt-dlp ç›´æ¥è¿æ¥")
                self.proxy_host = None  # è¿æ¥å¤±è´¥æ—¶ç¦ç”¨ä»£ç†
                # æ¸…é™¤ç³»ç»Ÿä»£ç†ç¯å¢ƒå˜é‡
                os.environ.pop('HTTP_PROXY', None)
                os.environ.pop('HTTPS_PROXY', None)
                os.environ.pop('NO_PROXY', None)
        else:
            logger.info("ä»£ç†æœåŠ¡å™¨æœªé…ç½®ï¼Œå°†ç›´æ¥è¿æ¥")
            logger.info("yt-dlp ç›´æ¥è¿æ¥")

        # åˆ›å»º gallery-dl.conf é…ç½®æ–‡ä»¶
        try:
            self._create_gallery_dl_config()
        except Exception as e:
            logger.warning(f"åˆ›å»º gallery-dl é…ç½®æ–‡ä»¶å¤±è´¥: {e}")

        # åˆå§‹åŒ–ç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½å™¨
        try:
            if NeteaseDownloader is None:
                raise ImportError("neteasecloud_music æ¨¡å—ä¸å¯ç”¨")
            base_downloader = NeteaseDownloader(bot=self)
            # ä½¿ç”¨é€‚é…å™¨åŒ…è£…ï¼Œå…¼å®¹æ—§ç‰ˆæœ¬ç¼ºå°‘çš„æ–¹æ³•
            self.netease_downloader = _NeteaseDownloaderAdapter(base_downloader)
            logger.info(f"ğŸµ ç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½å™¨åˆå§‹åŒ–æˆåŠŸ (æ¨¡å—: {NETEASE_MODULE_PATH})")
        except Exception as e:
            logger.warning(f"ç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½å™¨åˆå§‹åŒ–å¤±è´¥: {e}")
            self.netease_downloader = None

        # åˆå§‹åŒ–QQéŸ³ä¹ä¸‹è½½å™¨
        try:
            if QQMusicDownloader is None:
                raise ImportError("qqmusic_downloader æ¨¡å—ä¸å¯ç”¨")
            self.qqmusic_downloader = QQMusicDownloader(bot=self)
            logger.info(f"ğŸµ QQéŸ³ä¹ä¸‹è½½å™¨åˆå§‹åŒ–æˆåŠŸ (æ¨¡å—: {QQMUSIC_MODULE_PATH})")
        except Exception as e:
            logger.warning(f"QQéŸ³ä¹ä¸‹è½½å™¨åˆå§‹åŒ–å¤±è´¥: {e}")
            self.qqmusic_downloader = None

        # åˆå§‹åŒ–YouTube Musicä¸‹è½½å™¨
        try:
            if YouTubeMusicDownloader is None:
                raise ImportError("youtubemusic_downloader æ¨¡å—ä¸å¯ç”¨")
            self.youtubemusic_downloader = YouTubeMusicDownloader(bot=self)
            logger.info(f"ğŸµ YouTube Musicä¸‹è½½å™¨åˆå§‹åŒ–æˆåŠŸ (æ¨¡å—: {YOUTUBEMUSIC_MODULE_PATH})")
        except Exception as e:
            logger.warning(f"YouTube Musicä¸‹è½½å™¨åˆå§‹åŒ–å¤±è´¥: {e}")
            self.youtubemusic_downloader = None

    def _parse_cookies_file(self, cookies_path: str) -> dict:
        """è§£æ Netscape æ ¼å¼çš„ X cookies æ–‡ä»¶å¹¶è½¬æ¢ä¸º JSON æ ¼å¼"""
        try:
            cookies_dict = {}

            with open(cookies_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    # è·³è¿‡æ³¨é‡Šè¡Œå’Œç©ºè¡Œ
                    if line.startswith('#') or not line:
                        continue

                    # Netscape æ ¼å¼: domain, domain_specified, path, secure, expiry, name, value
                    parts = line.split('\t')
                    if len(parts) >= 7:
                        domain = parts[0]
                        secure = parts[3] == 'TRUE'
                        expiry = parts[4]
                        name = parts[5]
                        value = parts[6]

                        # åªå¤„ç† twitter.com å’Œ x.com çš„ cookies
                        if domain in ['.twitter.com', '.x.com', 'twitter.com', 'x.com']:
                            cookies_dict[name] = value
                            logger.debug(f"è§£æ X cookie: {name} = {value[:10]}...")

            logger.info(f"æˆåŠŸè§£æ {len(cookies_dict)} ä¸ª X cookies")
            return cookies_dict

        except Exception as e:
            logger.error(f"è§£æ X cookies æ–‡ä»¶å¤±è´¥: {e}")
            return {}

    def _parse_douyin_cookies_file(self, cookies_path: str) -> dict:
        """è§£æ Netscape æ ¼å¼çš„æŠ–éŸ³ cookies æ–‡ä»¶å¹¶è½¬æ¢ä¸º JSON æ ¼å¼"""
        try:
            cookies_dict = {}

            with open(cookies_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    # è·³è¿‡æ³¨é‡Šè¡Œå’Œç©ºè¡Œ
                    if line.startswith('#') or not line:
                        continue

                    # Netscape æ ¼å¼: domain, domain_specified, path, secure, expiry, name, value
                    parts = line.split('\t')
                    if len(parts) >= 7:
                        domain = parts[0]
                        secure = parts[3] == 'TRUE'
                        expiry = parts[4]
                        name = parts[5]
                        value = parts[6]

                        # åªå¤„ç†æŠ–éŸ³ç›¸å…³çš„ cookies
                        if domain in ['.douyin.com', 'douyin.com', 'www.douyin.com', 'v.douyin.com', 'www.iesdouyin.com', 'iesdouyin.com']:
                            cookies_dict[name] = value
                            logger.debug(f"è§£ææŠ–éŸ³ cookie: {name} = {value[:10]}...")

            logger.info(f"æˆåŠŸè§£æ {len(cookies_dict)} ä¸ªæŠ–éŸ³ cookies")
            return cookies_dict

        except Exception as e:
            logger.error(f"è§£ææŠ–éŸ³ cookies æ–‡ä»¶å¤±è´¥: {e}")
            return {}

    def _parse_kuaishou_cookies_file(self, cookies_path: str) -> dict:
        """è§£æ Netscape æ ¼å¼çš„å¿«æ‰‹ cookies æ–‡ä»¶å¹¶è½¬æ¢ä¸º JSON æ ¼å¼"""
        try:
            cookies_dict = {}

            with open(cookies_path, 'r', encoding='utf-8') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        parts = line.split('\t')
                        if len(parts) >= 7:
                            domain = parts[0]
                            flag = parts[1] == 'TRUE'
                            path = parts[2]
                            secure = parts[3] == 'TRUE'
                            expiry = parts[4]
                            name = parts[5]
                            value = parts[6]

                            # åªå¤„ç†å¿«æ‰‹ç›¸å…³çš„ cookies
                            if domain in ['.kuaishou.com', 'kuaishou.com', 'www.kuaishou.com', 'v.kuaishou.com']:
                                cookies_dict[name] = value
                                logger.debug(f"è§£æå¿«æ‰‹ cookie: {name} = {value[:10]}...")

            logger.info(f"æˆåŠŸè§£æ {len(cookies_dict)} ä¸ªå¿«æ‰‹ cookies")
            return cookies_dict

        except Exception as e:
            logger.error(f"è§£æå¿«æ‰‹ cookies æ–‡ä»¶å¤±è´¥: {e}")
            return {}

    def _test_proxy_connection(self) -> bool:
        """æµ‹è¯•ä»£ç†æœåŠ¡å™¨è¿æ¥"""
        if not self.proxy_host:
            return False
        try:
            # è§£æä»£ç†åœ°å€
            proxy_url = urlparse(self.proxy_host)
            proxies = {"http": self.proxy_host, "https": self.proxy_host}
            # è®¾ç½®è¶…æ—¶æ—¶é—´ä¸º5ç§’
            response = requests.get(
                "http://www.google.com", proxies=proxies, timeout=5, verify=False
            )
            return response.status_code == 200
        except Exception as e:
            logger.error(f"ä»£ç†è¿æ¥æµ‹è¯•å¤±è´¥: {str(e)}")
            return False

    def is_x_url(self, url: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸º X (Twitter) URL"""
        parsed = urlparse(url)
        return parsed.netloc.lower() in [
            "twitter.com",
            "x.com",
            "www.twitter.com",
            "www.x.com",
        ]

    def is_youtube_url(self, url: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸º YouTube URL"""
        parsed = urlparse(url)
        return parsed.netloc.lower() in [
            "youtube.com",
            "www.youtube.com",
            "youtu.be",
            "m.youtube.com",
        ]

    def is_facebook_url(self, url: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸º Facebook URL"""
        parsed = urlparse(url)
        return parsed.netloc.lower() in [
            "facebook.com",
            "www.facebook.com",
            "m.facebook.com",
            "fb.watch",
            "fb.com",
        ]

    def is_xvideos_url(self, url: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸º xvideos URL"""
        parsed = urlparse(url)
        return any(
            domain in parsed.netloc for domain in ["xvideos.com", "www.xvideos.com"]
        )

    def is_pornhub_url(self, url: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸º pornhub URL"""
        parsed = urlparse(url)
        return any(
            domain in parsed.netloc
            for domain in ["pornhub.com", "www.pornhub.com", "cn.pornhub.com"]
        )

    def _get_bilibili_best_format(self) -> str:
        """
        è·å–Bç«™æœ€ä½³æ ¼å¼é€‰æ‹©ç­–ç•¥ï¼Œæ™ºèƒ½æ ¹æ®ä¼šå‘˜çŠ¶æ€é€‰æ‹©æœ€é«˜ç”»è´¨
        - æœ‰ä¼šå‘˜ï¼šä¼˜å…ˆ4Kï¼Œå›é€€åˆ°2Kã€1080pé«˜ç ç‡
        - æ— ä¼šå‘˜ï¼šä¼˜å…ˆ1080pï¼Œå›é€€åˆ°720p
        """
        # æ™ºèƒ½Bç«™æ ¼å¼ç­–ç•¥ï¼šæ ¹æ®ä¼šå‘˜çŠ¶æ€è‡ªåŠ¨é€‰æ‹©æœ€é«˜å¯ç”¨ç”»è´¨
        bilibili_format = (
            # ç­–ç•¥1: 4K (éœ€è¦å¤§ä¼šå‘˜)
            "bestvideo[height>=2160]+bestaudio/"
            # ç­–ç•¥2: 2K (éœ€è¦å¤§ä¼šå‘˜)
            "bestvideo[height>=1440]+bestaudio/"
            # ç­–ç•¥3: 1080pé«˜ç ç‡ (éœ€è¦å¤§ä¼šå‘˜)
            "bestvideo[height>=1080][tbr>2000]+bestaudio/"
            # ç­–ç•¥4: 1080pæ™®é€š (å…è´¹)
            "bestvideo[height>=1080]+bestaudio/"
            # ç­–ç•¥5: 720p (å…è´¹)
            "bestvideo[height>=720]+bestaudio/"
            # ç­–ç•¥6: æœ€ç»ˆå›é€€
            "bestvideo+bestaudio/best"
        )
        logger.info("ğŸ¯ ä½¿ç”¨æ™ºèƒ½Bç«™æ ¼å¼ç­–ç•¥ï¼šæœ‰ä¼šå‘˜ä¼˜å…ˆ4Kï¼Œæ— ä¼šå‘˜ä¼˜å…ˆ1080p")
        logger.info(f"ğŸ”§ æ ¼å¼é€‰æ‹©å­—ç¬¦ä¸²: {bilibili_format}")
        return bilibili_format

    def check_bilibili_member_status(self) -> Dict[str, Any]:
        """æ£€æŸ¥Bç«™ä¼šå‘˜çŠ¶æ€"""
        try:
            if not self.b_cookies_path or not os.path.exists(self.b_cookies_path):
                return {
                    "success": False,
                    "is_member": False,
                    "message": "æœªè®¾ç½®Bç«™cookiesï¼Œæ— æ³•æ£€æµ‹ä¼šå‘˜çŠ¶æ€"
                }
            
            # è¿™é‡Œå¯ä»¥æ·»åŠ å®é™…çš„Bç«™APIè°ƒç”¨æ¥æ£€æµ‹ä¼šå‘˜çŠ¶æ€
            # ç›®å‰è¿”å›é»˜è®¤çŠ¶æ€
            return {
                "success": True,
                "is_member": False,
                "message": "éä¼šå‘˜ç”¨æˆ·ï¼Œæœ€é«˜å¯ä¸‹è½½480p-720p"
            }
        except Exception as e:
            return {
                "success": False,
                "is_member": False,
                "message": f"æ£€æµ‹ä¼šå‘˜çŠ¶æ€å¤±è´¥: {e}"
            }

    def debug_bilibili_formats(self, url: str) -> Dict[str, Any]:
        """è°ƒè¯•Bç«™è§†é¢‘æ ¼å¼ï¼Œæ˜¾ç¤ºå¯ç”¨åˆ†è¾¨ç‡"""
        try:
            ydl_opts = {
                "quiet": True,
                "no_warnings": True,
                "listformats": True,
            }
            
            # æ·»åŠ Bç«™cookies
            if self.b_cookies_path and os.path.exists(self.b_cookies_path):
                ydl_opts["cookiefile"] = self.b_cookies_path
                
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=False)
                formats = info.get("formats", [])
                
                video_formats = []
                for fmt in formats:
                    if fmt.get("vcodec", "none") != "none":  # è§†é¢‘æ ¼å¼
                        format_info = {
                            "id": fmt.get("format_id", "unknown"),
                            "height": fmt.get("height", 0),
                            "width": fmt.get("width", 0),
                            "tbr": fmt.get("tbr", 0),
                            "ext": fmt.get("ext", "unknown"),
                            "format_note": fmt.get("format_note", "unknown"),
                            "filesize": fmt.get("filesize", 0),
                        }
                        video_formats.append(format_info)
                
                # æŒ‰åˆ†è¾¨ç‡æ’åº
                video_formats.sort(key=lambda x: x["height"], reverse=True)
                
                logger.info("ğŸ” Bç«™å¯ç”¨è§†é¢‘æ ¼å¼:")
                for fmt in video_formats:
                    logger.info(f"  ID: {fmt['id']}, åˆ†è¾¨ç‡: {fmt['width']}x{fmt['height']}, ç ç‡: {fmt['tbr']}kbps, æ ¼å¼: {fmt['ext']}, è¯´æ˜: {fmt['format_note']}")
                
                return {
                    "success": True,
                    "formats": video_formats,
                    "max_height": max([f["height"] for f in video_formats]) if video_formats else 0
                }
                
        except Exception as e:
            logger.error(f"è°ƒè¯•Bç«™æ ¼å¼å¤±è´¥: {e}")
            return {"success": False, "error": str(e)}

    def is_bilibili_url(self, url: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸º Bilibili URL"""
        parsed = urlparse(url)
        return parsed.netloc.lower() in [
            "bilibili.com",
            "www.bilibili.com",
            "space.bilibili.com",
            "b23.tv",
        ]

    def is_telegraph_url(self, url: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸º Telegraph URL"""
        parsed = urlparse(url)
        return parsed.netloc.lower() in ["telegra.ph", "telegraph.co"]

    def is_douyin_url(self, url: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºæŠ–éŸ³ URL"""
        parsed = urlparse(url)
        return parsed.netloc.lower() in [
            "douyin.com",
            "www.douyin.com",
            "v.douyin.com",
            "www.iesdouyin.com",
            "iesdouyin.com"
        ]

    def is_kuaishou_url(self, url: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºå¿«æ‰‹ URL"""
        parsed = urlparse(url)
        # æ”¯æŒå¤šç§å¿«æ‰‹URLæ ¼å¼
        if parsed.netloc.lower() in [
            "kuaishou.com",
            "www.kuaishou.com",
            "v.kuaishou.com",
            "m.kuaishou.com",
            "f.kuaishou.com"
        ]:
            return True

        # æ£€æŸ¥URLè·¯å¾„æ˜¯å¦åŒ…å«å¿«æ‰‹ç‰¹å¾
        if 'kuaishou.com' in url.lower():
            return True

        return False

    def is_toutiao_url(self, url: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºå¤´æ¡è§†é¢‘ URL"""
        parsed = urlparse(url)
        return parsed.netloc.lower() in [
            "toutiao.com",
            "www.toutiao.com",
            "m.toutiao.com",
        ]

    def extract_urls_from_text(self, text: str) -> list:
        """ä»æ–‡æœ¬ä¸­æå–æ‰€æœ‰URL - æ”¹è¿›ç‰ˆæœ¬æ”¯æŒæ›´å¤šæ ¼å¼"""
        urls = []

        # åŸºç¡€URLæ­£åˆ™æ¨¡å¼ - æ”¯æŒä¸­æ–‡æ–‡æœ¬ä¸­çš„URL
        url_patterns = [
            # æ ‡å‡†HTTP/HTTPS URL
            r'https?://[^\s\u4e00-\u9fff]+',
            # å¿«æ‰‹çŸ­é“¾æ¥ç‰¹æ®Šå¤„ç†
            r'v\.kuaishou\.com/[A-Za-z0-9]+',
            # æŠ–éŸ³çŸ­é“¾æ¥
            r'v\.douyin\.com/[A-Za-z0-9]+',
            # Facebooké“¾æ¥
            r'facebook\.com/[A-Za-z0-9/._-]+',
            r'fb\.watch/[A-Za-z0-9]+',
            # å…¶ä»–çŸ­é“¾æ¥æ ¼å¼
            r'[a-zA-Z0-9.-]+\.com/[A-Za-z0-9/]+',
        ]

        for pattern in url_patterns:
            matches = re.findall(pattern, text)
            for match in matches:
                # æ¸…ç†URLæœ«å°¾çš„æ ‡ç‚¹ç¬¦å·
                clean_url = match.rstrip('.,;!?ã€‚ï¼Œï¼›ï¼ï¼Ÿ')
                # ç¡®ä¿URLæœ‰åè®®å‰ç¼€
                if not clean_url.startswith(('http://', 'https://')):
                    clean_url = 'https://' + clean_url
                urls.append(clean_url)

        # å»é‡å¹¶ä¿æŒé¡ºåº
        seen = set()
        unique_urls = []
        for url in urls:
            if url not in seen:
                seen.add(url)
                unique_urls.append(url)

        return unique_urls

    def _extract_clean_url_from_text(self, text: str) -> str:
        """ä»åŒ…å«æè¿°æ–‡æœ¬çš„å­—ç¬¦ä¸²ä¸­æå–çº¯å‡€çš„URL"""
        try:
            # ä½¿ç”¨å·²æœ‰çš„URLæå–æ–¹æ³•
            urls = self.extract_urls_from_text(text)
            if urls:
                return urls[0]  # è¿”å›ç¬¬ä¸€ä¸ªæ‰¾åˆ°çš„URL

            # å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œå¯èƒ½æ–‡æœ¬æœ¬èº«å°±æ˜¯ä¸€ä¸ªURL
            text = text.strip()
            if text.startswith(('http://', 'https://')):
                # æå–URLéƒ¨åˆ†ï¼ˆåˆ°ç¬¬ä¸€ä¸ªç©ºæ ¼ä¸ºæ­¢ï¼‰
                url_part = text.split()[0] if ' ' in text else text
                return url_part

            return None
        except Exception as e:
            logger.warning(f"æå–çº¯å‡€URLå¤±è´¥: {e}")
            return None

    def _clean_netease_url_special(self, text: str) -> str:
        """
        ä¸“é—¨ä¸ºç½‘æ˜“äº‘éŸ³ä¹æ¸…ç†URLï¼Œä»åŒ…å«ä¸­æ–‡æè¿°çš„æ–‡æœ¬ä¸­æå–çº¯å‡€çš„ç½‘æ˜“äº‘éŸ³ä¹é“¾æ¥
        
        Args:
            text: åŒ…å«ä¸­æ–‡æè¿°çš„æ–‡æœ¬ï¼Œå¦‚"åˆ†äº«G.E.M.é‚“ç´«æ£‹çš„ä¸“è¾‘ã€ŠT.I.M.E.ã€‹https://163cn.tv/jKbaG97 (@ç½‘æ˜“äº‘éŸ³ä¹)"
            
        Returns:
            str: æ¸…ç†åçš„çº¯å‡€URLï¼Œå¦‚æœæ²¡æ‰¾åˆ°åˆ™è¿”å›None
        """
        try:
            # ç½‘æ˜“äº‘éŸ³ä¹URLçš„æ­£åˆ™æ¨¡å¼
            netease_patterns = [
                # çŸ­é“¾æ¥æ ¼å¼
                r'https?://163cn\.tv/[A-Za-z0-9]+',
                r'https?://music\.163\.cn/[A-Za-z0-9/]+',
                # å®˜æ–¹é“¾æ¥æ ¼å¼
                r'https?://music\.163\.com/#/[^\\s\u4e00-\u9fff]+',
                r'https?://y\.music\.163\.com/[^\\s\u4e00-\u9fff]+',
                r'https?://m\.music\.163\.com/[^\\s\u4e00-\u9fff]+',
            ]
            
            for pattern in netease_patterns:
                matches = re.findall(pattern, text)
                if matches:
                    # å–ç¬¬ä¸€ä¸ªåŒ¹é…çš„URL
                    clean_url = matches[0]
                    # æ¸…ç†URLæœ«å°¾çš„æ ‡ç‚¹ç¬¦å·
                    clean_url = clean_url.rstrip('.,;!?ã€‚ï¼Œï¼›ï¼ï¼Ÿ')
                    logger.info(f"ğŸµ ç½‘æ˜“äº‘éŸ³ä¹URLæ¸…ç†æˆåŠŸ: {text[:50]}... -> {clean_url}")
                    return clean_url
            
            # å¦‚æœæ²¡æœ‰æ‰¾åˆ°ï¼Œå°è¯•ä»æ–‡æœ¬ä¸­æå–ä»»ä½•çœ‹èµ·æ¥åƒURLçš„å†…å®¹
            url_pattern = r'https?://[^\s\u4e00-\u9fff]+'
            matches = re.findall(url_pattern, text)
            for match in matches:
                if '163cn.tv' in match or 'music.163.com' in match:
                    clean_url = match.rstrip('.,;!?ã€‚ï¼Œï¼›ï¼ï¼Ÿ')
                    logger.info(f"ğŸµ ç½‘æ˜“äº‘éŸ³ä¹URLæ¸…ç†æˆåŠŸ(å¤‡ç”¨): {text[:50]}... -> {clean_url}")
                    return clean_url
            
            logger.warning(f"âš ï¸ æœªåœ¨æ–‡æœ¬ä¸­æ‰¾åˆ°ç½‘æ˜“äº‘éŸ³ä¹é“¾æ¥: {text[:50]}...")
            return None
            
        except Exception as e:
            logger.error(f"âŒ ç½‘æ˜“äº‘éŸ³ä¹URLæ¸…ç†å¤±è´¥: {e}")
            return None

    def is_xiaohongshu_url(self, url: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºå°çº¢ä¹¦ URL"""
        parsed = urlparse(url)
        return parsed.netloc.lower() in [
            "xiaohongshu.com",
            "www.xiaohongshu.com",
            "xhslink.com",
        ]

    async def _detect_xiaohongshu_content_type(self, url: str) -> str:
        """æ£€æµ‹å°çº¢ä¹¦å†…å®¹ç±»å‹ï¼ˆå›¾ç‰‡æˆ–è§†é¢‘ï¼‰"""
        try:
            # å¯¹äºçŸ­é“¾æ¥ï¼Œå…ˆå±•å¼€å†æ£€æµ‹
            if 'xhslink.com' in url:
                logger.info(f"ğŸ”— æ£€æµ‹åˆ°å°çº¢ä¹¦çŸ­é“¾æ¥ï¼Œå…ˆå±•å¼€: {url}")
                # ä½¿ç”¨ xiaohongshu_downloader å±•å¼€çŸ­é“¾æ¥
                try:
                    from xiaohongshu_downloader import XiaohongshuDownloader
                    downloader = XiaohongshuDownloader()
                    # å…ˆå±•å¼€çŸ­é“¾æ¥è·å–å®Œæ•´URL
                    expanded_url = downloader._expand_short_url(url)
                    if expanded_url and expanded_url != url:
                        logger.info(f"âœ… çŸ­é“¾æ¥å±•å¼€æˆåŠŸ: {expanded_url}")
                        url = expanded_url
                    else:
                        logger.warning(f"âš ï¸ çŸ­é“¾æ¥å±•å¼€å¤±è´¥ï¼Œä½¿ç”¨åŸURL")
                except Exception as e:
                    logger.warning(f"âš ï¸ çŸ­é“¾æ¥å±•å¼€å¼‚å¸¸: {e}")
            
            # ä½¿ç”¨ç®€å•çš„å¯å‘å¼æ–¹æ³•æ£€æµ‹
            # å¦‚æœURLåŒ…å«ç‰¹å®šå…³é”®è¯ï¼Œå¯èƒ½æ˜¯å›¾ç‰‡
            if any(keyword in url.lower() for keyword in ['/explore/', '/discovery/item/']):
                # è¿›ä¸€æ­¥æ£€æµ‹é¡µé¢å†…å®¹
                import httpx
                async with httpx.AsyncClient() as client:
                    headers = {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                        'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
                        'Referer': 'https://www.xiaohongshu.com/'
                    }
                    
                    response = await client.get(url, headers=headers, follow_redirects=True, timeout=10)
                    html_content = response.text.lower()
                    
                    # æ£€æŸ¥HTMLå†…å®¹ä¸­çš„å…³é”®è¯
                    if any(keyword in html_content for keyword in ['å›¾ç‰‡', 'image', 'photo', 'å£çº¸', 'å¤´åƒ']):
                        return "image"
                    elif any(keyword in html_content for keyword in ['è§†é¢‘', 'video', 'æ’­æ”¾']):
                        return "video"
                    
                    # é»˜è®¤è¿”å›å›¾ç‰‡ç±»å‹ï¼Œå› ä¸ºå°çº¢ä¹¦å¤§éƒ¨åˆ†å†…å®¹æ˜¯å›¾ç‰‡
                    return "image"
            else:
                # å¯¹äºå…¶ä»–URLï¼ˆåŒ…æ‹¬çŸ­é“¾æ¥ï¼‰ï¼Œé»˜è®¤è¿”å›å›¾ç‰‡ç±»å‹
                logger.info(f"ğŸ” URLä¸åŒ…å«ç‰¹å®šå…³é”®è¯ï¼Œé»˜è®¤è¿”å›å›¾ç‰‡ç±»å‹: {url}")
                return "image"
                    
        except Exception as e:
            logger.warning(f"âš ï¸ æ£€æµ‹å°çº¢ä¹¦å†…å®¹ç±»å‹å¤±è´¥: {e}")
            # é»˜è®¤è¿”å›å›¾ç‰‡ç±»å‹
            return "image"

    def is_weibo_url(self, url: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºå¾®åš URL"""
        parsed = urlparse(url)
        return parsed.netloc.lower() in [
            "weibo.com",
            "www.weibo.com",
            "m.weibo.com",
            "video.weibo.com",
            "t.cn",  # å¾®åšçŸ­é“¾æ¥
            "weibo.cn",  # å¾®åšçŸ­é“¾æ¥
            "sinaurl.cn",  # æ–°æµªçŸ­é“¾æ¥
        ]

    def _expand_weibo_short_url(self, url: str) -> str:
        """å±•å¼€å¾®åšçŸ­é“¾æ¥ä¸ºé•¿é“¾æ¥"""
        import requests
        import re

        try:
            # æ£€æŸ¥æ˜¯å¦ä¸ºå¾®åšçŸ­é“¾æ¥
            parsed = urlparse(url)
            short_domains = ["t.cn", "weibo.cn", "sinaurl.cn"]

            if parsed.netloc.lower() in short_domains:
                logger.info(f"ğŸ”„ æ£€æµ‹åˆ°å¾®åšçŸ­é“¾æ¥ï¼Œå¼€å§‹å±•å¼€: {url}")

                # ä¼˜å…ˆä½¿ç”¨ç§»åŠ¨ç«¯User-Agentï¼Œé¿å…é‡å®šå‘åˆ°ç™»å½•é¡µé¢
                mobile_headers = {
                    'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 14_7_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.1.2 Mobile/15E148 Safari/604.1',
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                    'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
                    'Connection': 'keep-alive',
                    'Upgrade-Insecure-Requests': '1'
                }

                # æ¡Œé¢ç«¯User-Agentä½œä¸ºå¤‡ç”¨
                desktop_headers = {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                    'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
                    'Accept-Encoding': 'gzip, deflate, br',
                    'Connection': 'keep-alive',
                    'Upgrade-Insecure-Requests': '1'
                }

                # å…ˆå°è¯•ç§»åŠ¨ç«¯User-Agentçš„GETè¯·æ±‚
                expanded_url = None
                try:
                    logger.info(f"ğŸ”„ ä½¿ç”¨ç§»åŠ¨ç«¯User-Agentè¯·æ±‚...")
                    response = requests.get(url, headers=mobile_headers, allow_redirects=True, timeout=10)
                    expanded_url = response.url
                    logger.info(f"ğŸ”„ ç§»åŠ¨ç«¯è¯·æ±‚é‡å®šå‘åˆ°: {expanded_url}")

                    # æ£€æŸ¥æ˜¯å¦å¾—åˆ°äº†æœ‰æ•ˆçš„å¾®åšè§†é¢‘URL
                    if "weibo.com" in expanded_url and ("tv/show" in expanded_url or "video" in expanded_url):
                        logger.info(f"âœ… ç§»åŠ¨ç«¯è¯·æ±‚æˆåŠŸè·å–å¾®åšè§†é¢‘URL")
                        # å¦‚æœæ˜¯h5.video.weibo.comï¼Œè½¬æ¢ä¸ºæ ‡å‡†çš„weibo.comæ ¼å¼
                        if "h5.video.weibo.com" in expanded_url:
                            expanded_url = expanded_url.replace("h5.video.weibo.com", "weibo.com/tv")
                            logger.info(f"ğŸ”„ è½¬æ¢ä¸ºæ ‡å‡†æ ¼å¼: {expanded_url}")
                    else:
                        logger.info(f"âš ï¸ ç§»åŠ¨ç«¯è¯·æ±‚æœªè·å–åˆ°æ ‡å‡†å¾®åšè§†é¢‘URLï¼Œå°è¯•æ¡Œé¢ç«¯...")
                        raise Exception("ç§»åŠ¨ç«¯æœªè·å–åˆ°æ ‡å‡†URL")

                except Exception as e:
                    logger.warning(f"âš ï¸ ç§»åŠ¨ç«¯è¯·æ±‚å¤±è´¥: {e}")
                    # å¦‚æœç§»åŠ¨ç«¯è¯·æ±‚å¤±è´¥ï¼Œå°è¯•æ¡Œé¢ç«¯è¯·æ±‚
                    try:
                        logger.info(f"ğŸ”„ ä½¿ç”¨æ¡Œé¢ç«¯User-Agentè¯·æ±‚...")
                        response = requests.get(url, headers=desktop_headers, allow_redirects=True, timeout=10)
                        expanded_url = response.url
                        logger.info(f"ğŸ”„ æ¡Œé¢ç«¯è¯·æ±‚é‡å®šå‘åˆ°: {expanded_url}")
                    except Exception as e2:
                        logger.warning(f"âš ï¸ æ¡Œé¢ç«¯è¯·æ±‚ä¹Ÿå¤±è´¥: {e2}")
                        return url

                # æ£€æŸ¥å±•å¼€åçš„URLæ˜¯å¦æœ‰æ•ˆ
                if expanded_url and expanded_url != url:
                    # è¿›ä¸€æ­¥å¤„ç†å¯èƒ½çš„ä¸­é—´è·³è½¬é¡µé¢
                    if "passport.weibo.com" in expanded_url and "url=" in expanded_url:
                        # ä»è·³è½¬é¡µé¢URLä¸­æå–çœŸå®çš„ç›®æ ‡URL
                        import urllib.parse
                        try:
                            # å°è¯•å¤šç§URLå‚æ•°æå–æ–¹å¼
                            match = re.search(r'url=([^&]+)', expanded_url)
                            if match:
                                encoded_url = match.group(1)
                                # å¤šæ¬¡URLè§£ç ï¼Œå› ä¸ºå¯èƒ½è¢«å¤šæ¬¡ç¼–ç 
                                real_url = urllib.parse.unquote(encoded_url)
                                real_url = urllib.parse.unquote(real_url)  # å†æ¬¡è§£ç 

                                # æ¸…ç†URLå‚æ•°ï¼Œç§»é™¤ä¸å¿…è¦çš„å‚æ•°
                                if '?' in real_url:
                                    base_url, params = real_url.split('?', 1)
                                    # ä¿ç•™é‡è¦å‚æ•°ï¼Œç§»é™¤è·Ÿè¸ªå‚æ•°
                                    important_params = []
                                    for param in params.split('&'):
                                        if '=' in param:
                                            key, value = param.split('=', 1)
                                            if key in ['fid', 'id', 'video_id']:  # ä¿ç•™é‡è¦çš„è§†é¢‘IDå‚æ•°
                                                important_params.append(param)

                                    if important_params:
                                        real_url = base_url + '?' + '&'.join(important_params)
                                    else:
                                        real_url = base_url

                                logger.info(f"ğŸ”„ ä»è·³è½¬é¡µé¢æå–çœŸå®URL: {real_url}")
                                expanded_url = real_url
                        except Exception as e:
                            logger.warning(f"âš ï¸ æå–çœŸå®URLå¤±è´¥: {e}")
                            # å¦‚æœæå–å¤±è´¥ï¼Œå°è¯•ç›´æ¥ä½¿ç”¨åŸå§‹çŸ­é“¾æ¥
                            logger.info(f"ğŸ”„ å›é€€åˆ°åŸå§‹çŸ­é“¾æ¥: {url}")
                            expanded_url = url

                    logger.info(f"âœ… å¾®åšçŸ­é“¾æ¥å±•å¼€æˆåŠŸ: {url} -> {expanded_url}")
                    return expanded_url
                else:
                    logger.warning(f"âš ï¸ çŸ­é“¾æ¥å±•å¼€åURLæ— å˜åŒ–ï¼Œä½¿ç”¨åŸURL: {url}")
                    return url
            else:
                # ä¸æ˜¯çŸ­é“¾æ¥ï¼Œç›´æ¥è¿”å›åŸURL
                return url

        except Exception as e:
            logger.warning(f"âš ï¸ å±•å¼€å¾®åšçŸ­é“¾æ¥å¤±è´¥: {e}")
            logger.warning(f"âš ï¸ å°†ä½¿ç”¨åŸå§‹URL: {url}")
            return url

    def is_instagram_url(self, url: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºInstagram URL"""
        parsed = urlparse(url)
        return parsed.netloc.lower() in [
            "instagram.com",
            "www.instagram.com",
            "m.instagram.com",
        ]

    def is_tiktok_url(self, url: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºTikTok URL"""
        parsed = urlparse(url)
        return parsed.netloc.lower() in [
            "tiktok.com",
            "www.tiktok.com",
            "m.tiktok.com",
            "vm.tiktok.com",
        ]

    def is_netease_url(self, url: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºç½‘æ˜“äº‘éŸ³ä¹ URL"""
        parsed = urlparse(url)
        # æ£€æŸ¥å®˜æ–¹åŸŸå
        if parsed.netloc.lower() in [
            "music.163.com",
            "y.music.163.com",
            "m.music.163.com",
        ]:
            return True
        
        # æ£€æŸ¥çŸ­é“¾æ¥åŸŸå
        if parsed.netloc.lower() in [
            "163cn.tv",
            "music.163.cn",
        ]:
            return True
        
        return False

    def is_qqmusic_url(self, url: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸ºQQéŸ³ä¹ URL"""
        parsed = urlparse(url)
        # æ£€æŸ¥å®˜æ–¹åŸŸå
        if parsed.netloc.lower() in [
            "y.qq.com",
            "music.qq.com",
            "c.y.qq.com",
            "c6.y.qq.com",
            "i.y.qq.com",
        ]:
            return True
        
        # æ£€æŸ¥çŸ­é“¾æ¥åŸŸå
        if parsed.netloc.lower() in [
            "qq.cn",
            "qq.com",
        ]:
            return True
        
        return False

    def is_apple_music_url(self, url: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸º Apple Music URL"""
        parsed = urlparse(url)
        return parsed.netloc.lower() in [
            "music.apple.com",
        ]

    def is_youtube_music_url(self, url: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦ä¸º YouTube Music URL"""
        parsed = urlparse(url)
        # æ£€æŸ¥YouTube Musicä¸“ç”¨åŸŸå
        if parsed.netloc.lower() in [
            "music.youtube.com",
        ]:
            return True
        
        # æ£€æŸ¥æ™®é€šYouTubeé“¾æ¥ä½†åŒ…å«æ’­æ”¾åˆ—è¡¨æ ‡è¯†ï¼ˆå¯èƒ½æ˜¯YouTube Musicæ’­æ”¾åˆ—è¡¨ï¼‰
        if parsed.netloc.lower() in [
            "youtube.com",
            "www.youtube.com",
            "youtu.be",
            "m.youtube.com",
        ]:
            # æ£€æŸ¥URLä¸­æ˜¯å¦åŒ…å«æ’­æ”¾åˆ—è¡¨å‚æ•°
            if 'list=' in url:
                return True
        
        return False

    def is_x_playlist_url(self, url: str) -> tuple:
        """
        æ£€æŸ¥æ˜¯å¦ä¸ºXæ’­æ”¾åˆ—è¡¨URLï¼Œå¹¶æå–æ’­æ”¾åˆ—è¡¨ä¿¡æ¯
        Returns:
            tuple: (is_playlist, playlist_info) æˆ– (False, None)
        """
        import yt_dlp

        try:
            # é¦–å…ˆæ£€æŸ¥æ˜¯å¦ä¸ºX URL
            if not self.is_x_url(url):
                return False, None

            # ä½¿ç”¨yt-dlpæ£€æŸ¥æ˜¯å¦ä¸ºæ’­æ”¾åˆ—è¡¨
            ydl_opts = {
                'quiet': True,
                'no_warnings': True,
                'extract_flat': True,
            }

            if self.proxy_host:
                ydl_opts['proxy'] = self.proxy_host

            if self.x_cookies_path:
                ydl_opts['cookiefile'] = self.x_cookies_path

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=False)

                # æ£€æŸ¥æ˜¯å¦ä¸ºæ’­æ”¾åˆ—è¡¨
                if info and '_type' in info and info['_type'] == 'playlist':
                    entries = info.get('entries', [])
                    if len(entries) > 1:
                        playlist_info = {
                            'total_videos': len(entries),
                            'playlist_title': info.get('title', 'Xæ’­æ”¾åˆ—è¡¨'),
                            'playlist_url': url,
                            'entries': entries
                        }
                        logger.info(f"æ£€æµ‹åˆ°Xæ’­æ”¾åˆ—è¡¨: {playlist_info['playlist_title']}, å…±{len(entries)}ä¸ªè§†é¢‘")
                        return True, playlist_info

                # æ£€æŸ¥æ˜¯å¦æœ‰å¤šä¸ªæ¡ç›®
                if info and 'entries' in info and len(info['entries']) > 1:
                    playlist_info = {
                        'total_videos': len(info['entries']),
                        'playlist_title': info.get('title', 'Xæ’­æ”¾åˆ—è¡¨'),
                        'playlist_url': url,
                        'entries': info['entries']
                    }
                    logger.info(f"æ£€æµ‹åˆ°Xæ’­æ”¾åˆ—è¡¨: {playlist_info['playlist_title']}, å…±{len(info['entries'])}ä¸ªè§†é¢‘")
                    return True, playlist_info

            return False, None
        except Exception as e:
            logger.warning(f"æ£€æŸ¥Xæ’­æ”¾åˆ—è¡¨æ—¶å‡ºé”™: {e}")
            return False, None

    def is_bilibili_list_url(self, url: str) -> tuple:
        """
        æ£€æŸ¥æ˜¯å¦ä¸ºBç«™ç”¨æˆ·åˆ—è¡¨URLï¼Œå¹¶æå–ç”¨æˆ·IDå’Œåˆ—è¡¨ID
        Returns:
            tuple: (is_list, uid, list_id) æˆ– (False, None, None)
        """
        import re

        # åŒ¹é…Bç«™ç”¨æˆ·åˆ—è¡¨URL:
        # https://space.bilibili.com/477348669/lists/2111173?type=season
        pattern = r"space\.bilibili\.com/(\d+)/lists/(\d+)"
        match = re.search(pattern, url)
        if match:
            uid = match.group(1)
            list_id = match.group(2)
            return True, uid, list_id
        return False, None, None

    def is_bilibili_user_lists_url(self, url: str) -> tuple:
        """
        æ£€æŸ¥æ˜¯å¦ä¸ºBç«™ç”¨æˆ·åˆé›†åˆ—è¡¨é¡µé¢URLï¼Œå¹¶æå–ç”¨æˆ·ID
        Returns:
            tuple: (is_user_lists, uid) æˆ– (False, None)
        """
        import re

        # åŒ¹é…Bç«™ç”¨æˆ·åˆé›†åˆ—è¡¨é¡µé¢URL:
        # https://space.bilibili.com/3546380987533935/lists
        pattern = r"space\.bilibili\.com/(\d+)/lists/?$"
        match = re.search(pattern, url)
        if match:
            uid = match.group(1)
            return True, uid
        return False, None



    def is_bilibili_ugc_season(self, url: str) -> tuple:
        """
        æ£€æŸ¥æ˜¯å¦ä¸ºBç«™UGCåˆé›†ï¼Œå¹¶æå–BVå·å’Œåˆé›†ID
        Returns:
            tuple: (is_ugc_season, bv_id, season_id) æˆ– (False, None, None)
        """
        import re
        import requests

        try:
            # é¦–å…ˆå°è¯•ä»URLä¸­æå–BVå·å’Œseason_id
            bv_pattern = r'BV[a-zA-Z0-9]+'
            season_pattern = r'season_id=(\d+)'

            bv_match = re.search(bv_pattern, url)
            season_match = re.search(season_pattern, url)

            # å¦‚æœURLä¸­æ²¡æœ‰BVå·ï¼Œå¯èƒ½æ˜¯çŸ­é“¾æ¥ï¼Œéœ€è¦å…ˆè§£æ
            if not bv_match and ("b23.tv" in url or "b23.wtf" in url):
                logger.info(f"ğŸ”„ æ£€æµ‹UGCåˆé›†ï¼šè§£æçŸ­é“¾æ¥ {url}")
                try:
                    headers = {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                    }
                    response = requests.get(url, headers=headers, allow_redirects=True, timeout=10)
                    real_url = response.url
                    logger.info(f"ğŸ”„ çŸ­é“¾æ¥è§£æç»“æœ: {real_url}")

                    # é‡æ–°æå–BVå·å’Œseason_id
                    bv_match = re.search(bv_pattern, real_url)
                    season_match = re.search(season_pattern, real_url)
                    url = real_url  # æ›´æ–°URLä¸ºçœŸå®URL
                except Exception as e:
                    logger.warning(f"âš ï¸ è§£æçŸ­é“¾æ¥å¤±è´¥: {e}")
                    return False, None, None

            if not bv_match:
                return False, None, None

            bv_id = bv_match.group(0)

            # å¦‚æœURLä¸­æœ‰season_idï¼Œç›´æ¥ä½¿ç”¨
            if season_match:
                season_id = season_match.group(1)
                logger.info(f"ğŸ” ä»URLä¸­æ£€æµ‹åˆ°UGCåˆé›†: BV={bv_id}, Season={season_id}")
                return True, bv_id, season_id

            # å¦‚æœURLä¸­æ²¡æœ‰season_idï¼Œå°è¯•é€šè¿‡APIè·å–
            logger.info(f"ğŸ” æ£€æŸ¥BVå·æ˜¯å¦å±äºUGCåˆé›†: {bv_id}")
            api_url = f"https://api.bilibili.com/x/web-interface/view?bvid={bv_id}"
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                'Referer': 'https://www.bilibili.com/',
            }

            response = requests.get(api_url, headers=headers, timeout=10)
            data = response.json()

            if data.get('code') == 0:
                ugc_season = data.get('data', {}).get('ugc_season')
                if ugc_season:
                    season_id = str(ugc_season.get('id'))
                    season_title = ugc_season.get('title', 'æœªçŸ¥åˆé›†')
                    logger.info(f"âœ… æ£€æµ‹åˆ°UGCåˆé›†: {season_title} (Season ID: {season_id})")
                    return True, bv_id, season_id

            return False, None, None

        except Exception as e:
            logger.warning(f"âš ï¸ æ£€æµ‹UGCåˆé›†æ—¶å‡ºé”™: {e}")
            return False, None, None

    def is_bilibili_multi_part_video(self, url: str) -> tuple:
        """
        æ£€æŸ¥æ˜¯å¦ä¸ºBç«™å¤šPè§†é¢‘ï¼Œå¹¶æå–BVå·
        Returns:
            tuple: (is_multi_part, bv_id) æˆ– (False, None)
        """
        import re
        import yt_dlp
        try:
            # é¦–å…ˆå°è¯•ä»URLä¸­æå–BVå·
            bv_pattern = r'BV[a-zA-Z0-9]+'
            bv_match = re.search(bv_pattern, url)

            # å¦‚æœURLä¸­æ²¡æœ‰BVå·ï¼Œå¯èƒ½æ˜¯çŸ­é“¾æ¥ï¼Œéœ€è¦å…ˆè§£æ
            if not bv_match and ("b23.tv" in url or "b23.wtf" in url):
                logger.info(f"ğŸ”„ æ£€æµ‹åˆ°Bç«™çŸ­é“¾æ¥ï¼Œå…ˆè§£æè·å–çœŸå®URL: {url}")
                try:
                    # ä½¿ç”¨yt-dlpè§£æçŸ­é“¾æ¥
                    temp_opts = {
                        'quiet': True,
                        'no_warnings': True,
                    }
                    with yt_dlp.YoutubeDL(temp_opts) as ydl:
                        temp_info = ydl.extract_info(url, download=False)

                    if temp_info.get('webpage_url'):
                        real_url = temp_info['webpage_url']
                        logger.info(f"ğŸ”„ çŸ­é“¾æ¥è§£æç»“æœ: {real_url}")
                        # ä»çœŸå®URLä¸­æå–BVå·
                        bv_match = re.search(bv_pattern, real_url)
                        if bv_match:
                            logger.info(f"âœ… ä»çŸ­é“¾æ¥ä¸­æå–åˆ°BVå·: {bv_match.group(0)}")
                except Exception as e:
                    logger.warning(f"âš ï¸ è§£æçŸ­é“¾æ¥å¤±è´¥: {e}")

            if not bv_match:
                return False, None

            bv_id = bv_match.group(0)

            # ä½¿ç”¨yt-dlpæ£€æŸ¥æ˜¯å¦ä¸ºå¤šPè§†é¢‘æˆ–åˆé›†
            # å…ˆå°è¯•å¿«é€Ÿæ£€æµ‹ï¼ˆextract_flat=Trueï¼‰
            ydl_opts_flat = {
                'quiet': True,
                'no_warnings': True,
                'extract_flat': True,
                'flat_playlist': True,
            }

            try:
                with yt_dlp.YoutubeDL(ydl_opts_flat) as ydl:
                    info = ydl.extract_info(url, download=False)

                    # æ£€æŸ¥æ˜¯å¦æœ‰å¤šä¸ªæ¡ç›®
                    if info and '_type' in info and info['_type'] == 'playlist':
                        entries = info.get('entries', [])
                        if len(entries) > 1:
                            logger.info(f"âœ… æ£€æµ‹åˆ°Bç«™å¤šå†…å®¹è§†é¢‘: {bv_id}, å…±{len(entries)}ä¸ªæ¡ç›®")
                            return True, bv_id

                    # æ£€æŸ¥æ˜¯å¦æœ‰åˆ†Pä¿¡æ¯
                    if info and 'entries' in info and len(info['entries']) > 1:
                        logger.info(f"âœ… æ£€æµ‹åˆ°Bç«™å¤šå†…å®¹è§†é¢‘: {bv_id}, å…±{len(info['entries'])}ä¸ªæ¡ç›®")
                        return True, bv_id
            except Exception as e:
                logger.warning(f"å¿«é€Ÿæ£€æµ‹å¤±è´¥: {e}")

            # å¦‚æœå¿«é€Ÿæ£€æµ‹å¤±è´¥ï¼Œå°è¯•å®Œæ•´æ£€æµ‹ï¼ˆextract_flat=Falseï¼‰
            logger.info(f"ğŸ”„ å¿«é€Ÿæ£€æµ‹æœªå‘ç°å¤šå†…å®¹ï¼Œå°è¯•å®Œæ•´æ£€æµ‹: {bv_id}")

            # ä½¿ç”¨è¾“å‡ºæ•è·æ¥æ£€æµ‹anthology
            import io
            from contextlib import redirect_stdout, redirect_stderr

            stdout_capture = io.StringIO()
            stderr_capture = io.StringIO()

            ydl_opts_full = {
                'quiet': False,  # æ”¹ä¸ºFalseä»¥ä¾¿çœ‹åˆ°æ›´å¤šä¿¡æ¯
                'no_warnings': False,  # æ”¹ä¸ºFalseä»¥ä¾¿çœ‹åˆ°è­¦å‘Šä¿¡æ¯
                'extract_flat': False,
                'noplaylist': False,
                'simulate': True,  # æ·»åŠ æ¨¡æ‹Ÿæ¨¡å¼
            }

            try:
                with redirect_stdout(stdout_capture), redirect_stderr(stderr_capture):
                    with yt_dlp.YoutubeDL(ydl_opts_full) as ydl:
                        info = ydl.extract_info(url, download=False)

                # æ£€æŸ¥æ•è·çš„è¾“å‡ºä¸­æ˜¯å¦åŒ…å«anthology
                stdout_output = stdout_capture.getvalue()
                stderr_output = stderr_capture.getvalue()
                all_output = (stdout_output + stderr_output).lower()

                if 'anthology' in all_output or 'extracting videos in anthology' in all_output:
                    logger.info(f"âœ… ä»yt-dlpè¾“å‡ºä¸­æ£€æµ‹åˆ°anthology: {bv_id}")
                    return True, bv_id

                # æ£€æŸ¥æ˜¯å¦æœ‰å¤šä¸ªæ¡ç›®
                    if info and '_type' in info and info['_type'] == 'playlist':
                        entries = info.get('entries', [])
                        if len(entries) > 1:
                            logger.info(f"âœ… å®Œæ•´æ£€æµ‹å‘ç°Bç«™å¤šå†…å®¹è§†é¢‘: {bv_id}, å…±{len(entries)}ä¸ªæ¡ç›®")
                            return True, bv_id

                    # æ£€æŸ¥æ˜¯å¦æœ‰åˆ†Pä¿¡æ¯
                    if info and 'entries' in info and len(info['entries']) > 1:
                        logger.info(f"âœ… å®Œæ•´æ£€æµ‹å‘ç°Bç«™å¤šå†…å®¹è§†é¢‘: {bv_id}, å…±{len(info['entries'])}ä¸ªæ¡ç›®")
                        return True, bv_id

                    # æ£€æŸ¥æ˜¯å¦åŒ…å«anthologyä¿¡æ¯ï¼ˆBç«™åˆé›†çš„ç‰¹å¾ï¼‰
                    info_str = str(info).lower()
                    if info and any(key in info_str for key in ['anthology', 'collection', 'series']):
                        logger.info(f"âœ… æ£€æµ‹åˆ°Bç«™åˆé›†ç‰¹å¾: {bv_id}")
                        return True, bv_id

                    # é¢å¤–æ£€æŸ¥ï¼šä½¿ç”¨æ¨¡æ‹Ÿä¸‹è½½æ¥æ£€æµ‹anthology
                    try:
                        logger.info(f"ğŸ” ä½¿ç”¨æ¨¡æ‹Ÿä¸‹è½½æ£€æµ‹anthology: {bv_id}")

                        # ä½¿ç”¨æ›´è¯¦ç»†çš„æ—¥å¿—æ•è·anthologyä¿¡æ¯
                        import io
                        import sys
                        from contextlib import redirect_stdout, redirect_stderr

                        # æ•è·yt-dlpçš„è¾“å‡º
                        stdout_capture = io.StringIO()
                        stderr_capture = io.StringIO()

                        simulate_opts = {
                            'quiet': False,  # æ”¹ä¸ºFalseä»¥æ•è·anthologyä¿¡æ¯
                            'no_warnings': False,  # æ”¹ä¸ºFalseä»¥æ•è·æ›´å¤šä¿¡æ¯
                            'simulate': True,
                            'extract_flat': False,
                        }

                        with redirect_stdout(stdout_capture), redirect_stderr(stderr_capture):
                            with yt_dlp.YoutubeDL(simulate_opts) as sim_ydl:
                                sim_info = sim_ydl.extract_info(url, download=False)

                        # æ£€æŸ¥æ•è·çš„è¾“å‡ºä¸­æ˜¯å¦åŒ…å«anthology
                        stdout_output = stdout_capture.getvalue().lower()
                        stderr_output = stderr_capture.getvalue().lower()
                        all_output = stdout_output + stderr_output

                        if 'anthology' in all_output or 'extracting videos in anthology' in all_output:
                            logger.info(f"âœ… ä»è¾“å‡ºä¸­æ£€æµ‹åˆ°anthologyå…³é”®è¯: {bv_id}")
                            return True, bv_id

                        # æ£€æŸ¥æ¨¡æ‹Ÿä¸‹è½½çš„ä¿¡æ¯ä¸­æ˜¯å¦åŒ…å«anthology
                        sim_str = str(sim_info).lower()
                        if 'anthology' in sim_str:
                            logger.info(f"âœ… æ¨¡æ‹Ÿä¸‹è½½æ£€æµ‹åˆ°anthologyå…³é”®è¯: {bv_id}")
                            return True, bv_id

                        # æ£€æŸ¥æ˜¯å¦æœ‰å¤šä¸ªentries
                        if sim_info and 'entries' in sim_info and len(sim_info['entries']) > 1:
                            logger.info(f"âœ… æ¨¡æ‹Ÿä¸‹è½½æ£€æµ‹åˆ°å¤šä¸ªæ¡ç›®: {bv_id}, å…±{len(sim_info['entries'])}ä¸ª")
                            return True, bv_id

                    except Exception as sim_e:
                        logger.warning(f"æ¨¡æ‹Ÿä¸‹è½½æ£€æµ‹å¤±è´¥: {sim_e}")

                    # å°è¯•ä»é‡å®šå‘URLä¸­æå–ç”¨æˆ·IDï¼Œæ£€æŸ¥ç”¨æˆ·ç©ºé—´æ˜¯å¦æœ‰å¤šä¸ªè§†é¢‘
                    webpage_url = info.get('webpage_url', '')
                    if webpage_url and 'up_id=' in webpage_url:
                        import re
                        up_id_match = re.search(r'up_id=(\d+)', webpage_url)
                        if up_id_match:
                            up_id = up_id_match.group(1)
                            logger.info(f"ğŸ” å°è¯•æ£€æŸ¥ç”¨æˆ·ç©ºé—´: {up_id}")

                            # æ£€æŸ¥ç”¨æˆ·ç©ºé—´æ˜¯å¦æœ‰å¤šä¸ªè§†é¢‘
                            user_space_url = f"https://space.bilibili.com/{up_id}"
                            try:
                                user_opts = {
                                    'quiet': True,
                                    'no_warnings': True,
                                    'extract_flat': True,
                                    'flat_playlist': True,
                                }
                                with yt_dlp.YoutubeDL(user_opts) as user_ydl:
                                    user_info = user_ydl.extract_info(user_space_url, download=False)

                                if user_info and 'entries' in user_info:
                                    user_entries = user_info['entries']
                                    if len(user_entries) > 1:
                                        logger.info(f"âœ… ç”¨æˆ·ç©ºé—´æ£€æµ‹åˆ°å¤šä¸ªè§†é¢‘: {len(user_entries)}ä¸ªï¼Œå¯èƒ½æ˜¯åˆé›†åˆ†äº«")
                                        return True, bv_id
                            except Exception as user_e:
                                logger.warning(f"ç”¨æˆ·ç©ºé—´æ£€æµ‹å¤±è´¥: {user_e}")

            except Exception as e:
                logger.warning(f"å®Œæ•´æ£€æµ‹å¤±è´¥: {e}")

            return False, bv_id
        except Exception as e:
            logger.warning(f"æ£€æŸ¥Bç«™å¤šPè§†é¢‘æ—¶å‡ºé”™: {e}")
            return False, None

    def is_youtube_playlist_url(self, url: str) -> tuple:
        """æ£€æŸ¥æ˜¯å¦ä¸º YouTube æ’­æ”¾åˆ—è¡¨ URL"""
        import re

        logger.info(f"ğŸ” æ£€æŸ¥æ˜¯å¦ä¸ºYouTubeæ’­æ”¾åˆ—è¡¨URL: {url}")

        # åŒ¹é… YouTube æ’­æ”¾åˆ—è¡¨ URLï¼ˆæ”¯æŒç§»åŠ¨ç‰ˆå’Œæ¡Œé¢ç‰ˆï¼‰
        patterns = [
            r"(?:(?:m\.)?youtube\.com/playlist\?list=|(?:m\.)?youtube\.com/watch\?.*&list=)([a-zA-Z0-9_-]+)",
            r"(?:m\.)?youtube\.com/playlist\?list=([a-zA-Z0-9_-]+)",
        ]
        for i, pattern in enumerate(patterns, 1):
            match = re.search(pattern, url)
            if match:
                playlist_id = match.group(1)
                logger.info(f"ğŸ¯ æ¨¡å¼{i}åŒ¹é…æˆåŠŸï¼Œæ•è·æ’­æ”¾åˆ—è¡¨ID: {playlist_id}")
                logger.info(f"ğŸ“‹ æ£€æµ‹åˆ°æ’­æ”¾åˆ—è¡¨: {playlist_id}")
                return True, playlist_id

        logger.info("âŒ æœªæ£€æµ‹åˆ°æ’­æ”¾åˆ—è¡¨å‚æ•°")
        return False, None



    def is_youtube_channel_playlists_url(self, url: str) -> tuple:
        """æ£€æŸ¥æ˜¯å¦ä¸º YouTube é¢‘é“æ’­æ”¾åˆ—è¡¨é¡µé¢ URL æˆ–é¢‘é“ä¸»é¡µ URL"""
        import re

        # é¦–å…ˆåŒ¹é…å·²ç»åŒ…å« /playlists çš„URLï¼ˆæ”¯æŒç§»åŠ¨ç‰ˆå’Œæ¡Œé¢ç‰ˆï¼‰
        playlists_patterns = [
            r"(?:m\.)?youtube\.com/@([^/\?]+)/playlists",
            r"(?:m\.)?youtube\.com/c/([^/\?]+)/playlists",
            r"(?:m\.)?youtube\.com/channel/([^/\?]+)/playlists",
            r"(?:m\.)?youtube\.com/user/([^/\?]+)/playlists",
        ]
        for pattern in playlists_patterns:
            match = re.search(pattern, url)
            if match:
                channel_identifier = match.group(1)
                return True, url

        # ç„¶ååŒ¹é…é¢‘é“ä¸»é¡µURLï¼Œè‡ªåŠ¨è½¬æ¢ä¸ºæ’­æ”¾åˆ—è¡¨URLï¼ˆæ”¯æŒç§»åŠ¨ç‰ˆå’Œæ¡Œé¢ç‰ˆï¼‰
        channel_patterns = [
            r"(?:m\.)?youtube\.com/@([^/\?]+)(?:\?.*)?$",  # @username æ ¼å¼
            r"(?:m\.)?youtube\.com/c/([^/\?]+)(?:\?.*)?$",  # /c/channel æ ¼å¼
            r"(?:m\.)?youtube\.com/channel/([^/\?]+)(?:\?.*)?$",  # /channel/ID æ ¼å¼
            r"(?:m\.)?youtube\.com/user/([^/\?]+)(?:\?.*)?$",  # /user/username æ ¼å¼
        ]
        for pattern in channel_patterns:
            match = re.search(pattern, url)
            if match:
                channel_identifier = match.group(1)
                # æ„å»ºæ’­æ”¾åˆ—è¡¨URL
                if "@" in url:
                    playlists_url = f"https://www.youtube.com/@{channel_identifier}/playlists"
                elif "/c/" in url:
                    playlists_url = f"https://www.youtube.com/c/{channel_identifier}/playlists"
                elif "/channel/" in url:
                    playlists_url = f"https://www.youtube.com/channel/{channel_identifier}/playlists"
                elif "/user/" in url:
                    playlists_url = f"https://www.youtube.com/user/{channel_identifier}/playlists"
                else:
                    playlists_url = url

                logger.info(f"ğŸ” æ£€æµ‹åˆ°YouTubeé¢‘é“ä¸»é¡µï¼Œè½¬æ¢ä¸ºæ’­æ”¾åˆ—è¡¨URL: {playlists_url}")
                return True, playlists_url
        return False, None

    def get_download_path(self, url: str) -> Path:
        """æ ¹æ® URL ç¡®å®šä¸‹è½½è·¯å¾„"""
        if self.is_x_url(url):
            return self.x_download_path.resolve()
        elif self.is_youtube_url(url):
            return self.youtube_download_path.resolve()
        elif self.is_xvideos_url(url):
            return self.xvideos_download_path.resolve()
        elif self.is_pornhub_url(url):
            return self.pornhub_download_path.resolve()
        elif self.is_bilibili_url(url):
            return self.bilibili_download_path.resolve()
        elif self.is_telegraph_url(url):
            return self.telegraph_download_path.resolve()
        elif self.is_douyin_url(url):
            return self.douyin_download_path.resolve()
        elif self.is_kuaishou_url(url):
            return self.kuaishou_download_path.resolve()
        elif self.is_toutiao_url(url):
            return self.toutiao_download_path.resolve()
        elif self.is_facebook_url(url):
            return self.facebook_download_path.resolve()
        elif self.is_xiaohongshu_url(url):
            return self.xiaohongshu_download_path.resolve()  # å°çº¢ä¹¦ä½¿ç”¨è‡ªå·±çš„ç›®å½•
        elif self.is_weibo_url(url):
            return self.weibo_download_path.resolve()
        elif self.is_instagram_url(url):
            return self.instagram_download_path.resolve()
        elif self.is_tiktok_url(url):
            return self.tiktok_download_path.resolve()
        elif self.is_netease_url(url):
            return self.netease_download_path.resolve()
        elif self.is_qqmusic_url(url):
            return self.qqmusic_download_path.resolve()
        elif self.is_youtube_music_url(url):
            return self.youtubemusic_download_path.resolve()
        elif self.is_apple_music_url(url):
            return self.apple_music_download_path.resolve()
        else:
            return self.youtube_download_path.resolve()

    def get_platform_name(self, url: str) -> str:
        """è·å–å¹³å°åç§°"""
        if self.is_x_url(url):
            return "x"
        elif self.is_youtube_url(url):
            return "youtube"
        elif self.is_xvideos_url(url):
            return "xvideos"
        elif self.is_pornhub_url(url):
            return "pornhub"
        elif self.is_bilibili_url(url):
            return "bilibili"
        elif self.is_telegraph_url(url):
            return "telegraph"
        elif self.is_douyin_url(url):
            return "douyin"
        elif self.is_kuaishou_url(url):
            return "kuaishou"
        elif self.is_toutiao_url(url):
            return "toutiao"
        elif self.is_facebook_url(url):
            return "facebook"
        elif self.is_xiaohongshu_url(url):
            return "xiaohongshu"
        elif self.is_weibo_url(url):
            return "weibo"
        elif self.is_instagram_url(url):
            return "instagram"
        elif self.is_tiktok_url(url):
            return "tiktok"
        elif self.is_netease_url(url):
            return "netease"
        elif self.is_qqmusic_url(url):
            return "qqmusic"
        elif self.is_youtube_music_url(url):
            return "youtubemusic"
        elif self.is_apple_music_url(url):
            return "applemusic"
        else:
            return "other"

    def check_ytdlp_version(self) -> Dict[str, Any]:
        """æ£€æŸ¥yt-dlpç‰ˆæœ¬"""
        try:
            import yt_dlp

            version = yt_dlp.version.__version__
            return {
                "success": True,
                "version": version,
                "info": f"yt-dlp ç‰ˆæœ¬: {version}",
            }
        except Exception as e:
            return {"success": False, "error": str(e)}

    def check_video_formats(self, url: str) -> Dict[str, Any]:
        """æ£€æŸ¥è§†é¢‘çš„å¯ç”¨æ ¼å¼"""
        try:
            ydl_opts = {
                "quiet": True,
                "no_warnings": True,
                "listformats": True,
            }
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                info = ydl.extract_info(url, download=False)
                formats = info.get("formats", [])
                video_formats = []
                audio_formats = []
                for fmt in formats:
                    format_info = {
                        "id": fmt.get("format_id", "unknown"),
                        "ext": fmt.get("ext", "unknown"),
                        "quality": fmt.get("format_note", "unknown"),
                        "filesize": fmt.get("filesize", 0),
                        "height": fmt.get("height", 0),
                        "width": fmt.get("width", 0),
                        "fps": fmt.get("fps", 0),
                        "vcodec": fmt.get("vcodec", "none"),
                        "acodec": fmt.get("acodec", "none"),
                        "format_type": (
                            "video" if fmt.get("vcodec", "none") != "none" else "audio"
                        ),
                    }
                    if format_info["format_type"] == "video":
                        video_formats.append(format_info)
                    else:
                        audio_formats.append(format_info)
                # æŒ‰è´¨é‡æ’åº
                video_formats.sort(
                    key=lambda x: (x["height"], x["filesize"]), reverse=True
                )
                audio_formats.sort(key=lambda x: x["filesize"], reverse=True)
                # æ£€æŸ¥æ˜¯å¦æœ‰é«˜åˆ†è¾¨ç‡æ ¼å¼
                has_high_res = any(f.get("height", 0) >= 2160 for f in video_formats)
                has_4k = any(f.get("height", 0) >= 2160 for f in video_formats)
                has_1080p = any(f.get("height", 0) >= 1080 for f in video_formats)
                has_720p = any(f.get("height", 0) >= 720 for f in video_formats)
                return {
                    "success": True,
                    "title": info.get("title", "Unknown"),
                    "duration": info.get("duration", 0),
                    "video_formats": video_formats[:10],  # åªæ˜¾ç¤ºå‰10ä¸ªè§†é¢‘æ ¼å¼
                    "audio_formats": audio_formats[:5],  # åªæ˜¾ç¤ºå‰5ä¸ªéŸ³é¢‘æ ¼å¼
                    "quality_info": {
                        "has_4k": has_4k,
                        "has_1080p": has_1080p,
                        "has_720p": has_720p,
                        "total_video_formats": len(video_formats),
                        "total_audio_formats": len(audio_formats),
                    },
                }
        except Exception as e:
            logger.error(f"æ ¼å¼æ£€æŸ¥å¤±è´¥: {str(e)}")
            return {"success": False, "error": str(e)}

    def get_media_info(self, file_path: str) -> Dict[str, Any]:
        """ä½¿ç”¨ ffprobe è·å–åª’ä½“æ–‡ä»¶çš„è¯¦ç»†ä¿¡æ¯"""
        try:
            # é¦–å…ˆæ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
            if not os.path.exists(file_path):
                logger.warning(f"âš ï¸ æ–‡ä»¶ä¸å­˜åœ¨: {file_path}")
                return {}

            # æ£€æŸ¥æ–‡ä»¶å¤§å°
            file_size = os.path.getsize(file_path)
            if file_size == 0:
                logger.warning(f"âš ï¸ æ–‡ä»¶å¤§å°ä¸º0: {file_path}")
                return {}

            logger.info(f"ğŸ” å¼€å§‹è·å–åª’ä½“ä¿¡æ¯: {file_path}")
            logger.info(f"ğŸ“¦ æ–‡ä»¶å¤§å°: {file_size / (1024 * 1024):.2f} MB")

            cmd = [
                "ffprobe",
                "-loglevel",
                "quiet",
                "-print_format",
                "json",
                "-show_format",
                "-show_streams",
                str(file_path),
            ]

            logger.info(f"ğŸ”§ æ‰§è¡Œffprobeå‘½ä»¤: {' '.join(cmd)}")
            result = subprocess.run(cmd, capture_output=True, text=True, check=True)

            if result.returncode != 0:
                logger.warning(f"âš ï¸ ffprobeè¿”å›éé›¶çŠ¶æ€ç : {result.returncode}")
                logger.warning(f"âš ï¸ stderr: {result.stderr}")

            info = json.loads(result.stdout)
            logger.info(f"âœ… ffprobeè§£ææˆåŠŸï¼Œæµæ•°é‡: {len(info.get('streams', []))}")

            media_info = {}
            if "format" in info:
                duration = float(info["format"].get("duration", 0))
                if duration > 0:
                    media_info["duration"] = (
                        time.strftime("%H:%M:%S", time.gmtime(duration))
                        if duration >= 3600
                        else time.strftime("%M:%S", time.gmtime(duration))
                    )
                    logger.info(f"â±ï¸ è§†é¢‘æ—¶é•¿: {media_info['duration']}")
                size = int(info["format"].get("size", 0) or 0)
                if size > 0:
                    media_info["size"] = f"{size / (1024 * 1024):.2f} MB"

            # æŸ¥æ‰¾è§†é¢‘æµ
            video_streams = [s for s in info.get("streams", []) if s.get("codec_type") == "video"]
            logger.info(f"ğŸ¬ æ‰¾åˆ° {len(video_streams)} ä¸ªè§†é¢‘æµ")

            video_stream = next(
                (s for s in info.get("streams", []) if s.get("codec_type") == "video"),
                None,
            )
            if video_stream:
                width, height = video_stream.get("width"), video_stream.get("height")
                logger.info(f"ğŸ” è§†é¢‘æµä¿¡æ¯: width={width}, height={height}")
                logger.info(f"ğŸ” è§†é¢‘ç¼–ç : {video_stream.get('codec_name', 'æœªçŸ¥')}")

                if width and height:
                    resolution = f"{width}x{height}"
                    media_info["resolution"] = resolution
                    logger.info(f"âœ… è·å–åˆ°åˆ†è¾¨ç‡: {media_info['resolution']}")
                else:
                    logger.warning(f"âš ï¸ è§†é¢‘æµä¸­æ²¡æœ‰å®½é«˜ä¿¡æ¯: width={width}, height={height}")
                    # å°è¯•ä»æ–‡ä»¶åæ¨æ–­åˆ†è¾¨ç‡
                    filename = os.path.basename(file_path)
                    resolution_from_filename = self._extract_resolution_from_filename(filename)
                    if resolution_from_filename:
                        # æ£€æŸ¥æ˜¯å¦å·²ç»åŒ…å«è´¨é‡æ ‡è¯†ï¼Œé¿å…é‡å¤
                        if "(" in resolution_from_filename and ")" in resolution_from_filename:
                            media_info["resolution"] = resolution_from_filename
                            logger.info(f"ğŸ“ ä»æ–‡ä»¶åæ¨æ–­åˆ†è¾¨ç‡ï¼ˆå·²åŒ…å«è´¨é‡æ ‡è¯†ï¼‰: {resolution_from_filename}")
                        else:
                            # å¦‚æœæ²¡æœ‰è´¨é‡æ ‡è¯†ï¼Œæ·»åŠ ä¸€ä¸ª
                            if height >= 2160:
                                quality = "4K"
                            elif height >= 1440:
                                quality = "2K"
                            elif height >= 1080:
                                quality = "1080p"
                            elif height >= 720:
                                quality = "720p"
                            elif height >= 480:
                                quality = "480p"
                            else:
                                quality = f"{height}p"
                            # æ£€æŸ¥resolution_from_filenameæ˜¯å¦å·²ç»åŒ…å«è´¨é‡æ ‡è¯†
                            if "(" in resolution_from_filename and ")" in resolution_from_filename:
                                media_info["resolution"] = resolution_from_filename
                                logger.info(f"ğŸ“ ä»æ–‡ä»¶åæ¨æ–­åˆ†è¾¨ç‡ï¼ˆå·²åŒ…å«è´¨é‡æ ‡è¯†ï¼‰: {media_info['resolution']}")
                            else:
                                media_info["resolution"] = f"{resolution_from_filename} ({quality})"
                                logger.info(f"ğŸ“ ä»æ–‡ä»¶åæ¨æ–­åˆ†è¾¨ç‡ï¼ˆæ·»åŠ è´¨é‡æ ‡è¯†ï¼‰: {media_info['resolution']}")
                    else:
                        logger.warning("âš ï¸ æ²¡æœ‰æ‰¾åˆ°è§†é¢‘æµ")
                        # ä¸å°è¯•ä»æ–‡ä»¶åæ¨æ–­åˆ†è¾¨ç‡ï¼Œé¿å…ä¸å®é™…åˆ†è¾¨ç‡å†²çª
                        # å¦‚æœffprobeæ— æ³•è·å–åˆ†è¾¨ç‡ï¼Œå°±æ ‡è®°ä¸ºæœªçŸ¥
                        media_info["resolution"] = "æœªçŸ¥"
                        logger.info(f"ğŸ“ æ— æ³•è·å–è§†é¢‘åˆ†è¾¨ç‡ï¼Œæ ‡è®°ä¸ºæœªçŸ¥")

            audio_stream = next(
                (s for s in info.get("streams", []) if s.get("codec_type") == "audio"),
                None,
            )
            if audio_stream:
                bit_rate = int(audio_stream.get("bit_rate", 0))
                if bit_rate > 0:
                    media_info["bit_rate"] = f"{bit_rate // 1000} kbps"
                    logger.info(f"ğŸ”Š éŸ³é¢‘ç ç‡: {media_info['bit_rate']}")

            logger.info(f"ğŸ“Š æœ€ç»ˆåª’ä½“ä¿¡æ¯: {media_info}")
            return media_info
        except (
            subprocess.CalledProcessError,
            FileNotFoundError,
            json.JSONDecodeError,
        ) as e:
            logger.warning(f"âš ï¸ æ— æ³•ä½¿ç”¨ ffprobe è·å–åª’ä½“ä¿¡æ¯: {e}")
            logger.warning(f"âš ï¸ å¼‚å¸¸ç±»å‹: {type(e)}")

            # ä¸å°è¯•ä»æ–‡ä»¶åæ¨æ–­åˆ†è¾¨ç‡ï¼Œé¿å…ä¸å®é™…åˆ†è¾¨ç‡å†²çª
            logger.info(f"ğŸ“ è·³è¿‡ä»æ–‡ä»¶åæ¨æ–­åˆ†è¾¨ç‡ï¼Œé¿å…ä¸å®é™…åˆ†è¾¨ç‡å†²çª")

            # è¿”å›åŸºæœ¬çš„æ–‡ä»¶ä¿¡æ¯
            try:
                if os.path.exists(file_path):
                    file_size = os.path.getsize(file_path)
                    if file_size > 0:
                        return {"size": f"{file_size / (1024 * 1024):.2f} MB"}
            except Exception as e2:
                logger.warning(f"âš ï¸ è·å–æ–‡ä»¶å¤§å°å¤±è´¥: {e2}")
            return {}

    def _extract_resolution_from_filename(self, filename: str) -> str:
        """ä»æ–‡ä»¶åä¸­æå–åˆ†è¾¨ç‡ä¿¡æ¯"""
        try:
            import re

            # å¸¸è§çš„åˆ†è¾¨ç‡æ¨¡å¼
            patterns = [
                # æ ‡å‡†åˆ†è¾¨ç‡æ ¼å¼ï¼š1920x1080, 1280x720ç­‰
                r'(\d{3,4})x(\d{3,4})',
                # é«˜åº¦æ ¼å¼ï¼š1080p, 720p, 480pç­‰
                r'(\d{3,4})[pP]',
                # è´¨é‡æ ‡è¯†ï¼š4K, 2K, 1080Pç­‰
                r'(4K|2K|1080[Pp]|720[Pp]|480[Pp])',
                # Bç«™ç‰¹æœ‰æ ¼å¼
                r'(\d{3,4})[Pp](\d+)',
            ]

            for pattern in patterns:
                match = re.search(pattern, filename)
                if match:
                    if 'x' in pattern:
                        # å®½xé«˜æ ¼å¼
                        width, height = int(match.group(1)), int(match.group(2))
                        resolution = f"{width}x{height}"
                        return resolution

                    elif match.group(1).isdigit():
                        # çº¯æ•°å­—é«˜åº¦æ ¼å¼
                        height = int(match.group(1))

                        # æ¨æ–­å¸¸è§çš„å®½åº¦
                        if height >= 2160:
                            width = 3840
                        elif height >= 1440:
                            width = 2560
                        elif height >= 1080:
                            width = 1920
                        elif height >= 720:
                            width = 1280
                        elif height >= 480:
                            width = 854
                        else:
                            width = 640

                        return f"{width}x{height}"

                    else:
                        # è´¨é‡æ ‡è¯†æ ¼å¼
                        quality_str = match.group(1).upper()
                        if quality_str == "4K":
                            return "3840x2160"
                        elif quality_str == "2K":
                            return "2560x1440"
                        elif "1080" in quality_str:
                            return "1920x1080"
                        elif "720" in quality_str:
                            return "1280x720"
                        elif "480" in quality_str:
                            return "854x480"
                        else:
                            return f"æœªçŸ¥åˆ†è¾¨ç‡"

            logger.debug(f"ğŸ“ æ— æ³•ä»æ–‡ä»¶åæå–åˆ†è¾¨ç‡: {filename}")
            return ""

        except Exception as e:
            logger.warning(f"âš ï¸ ä»æ–‡ä»¶åæå–åˆ†è¾¨ç‡æ—¶å‡ºé”™: {e}")
            return ""

    def single_video_find_downloaded_file(
        self, download_path: Path, progress_data: dict = None, expected_title: str = None, url: str = None
    ) -> str:
        """
        å•è§†é¢‘ä¸‹è½½çš„æ–‡ä»¶æŸ¥æ‰¾æ–¹æ³•

        Args:
            download_path: ä¸‹è½½ç›®å½•
            progress_data: è¿›åº¦æ•°æ®ï¼ŒåŒ…å«final_filename
            expected_title: é¢„æœŸçš„æ–‡ä»¶åï¼ˆä¸åŒ…å«æ‰©å±•åï¼‰
            url: åŸå§‹URLï¼Œç”¨äºåˆ¤æ–­å¹³å°ç±»å‹

        Returns:
            str: æ‰¾åˆ°çš„æ–‡ä»¶è·¯å¾„ï¼Œå¦‚æœæ²¡æ‰¾åˆ°è¿”å›None
        """
        # 1. ä¼˜å…ˆä½¿ç”¨progress_hookè®°å½•çš„æ–‡ä»¶è·¯å¾„
        if progress_data and isinstance(progress_data, dict) and progress_data.get("final_filename"):
            final_file_path = progress_data["final_filename"]

            # æ£€æŸ¥æ˜¯å¦æ˜¯ä¸­é—´æ–‡ä»¶ï¼Œå¦‚æœæ˜¯åˆ™ç›´æ¥æŸ¥æ‰¾åˆå¹¶åçš„æ–‡ä»¶
            original_path = Path(final_file_path)
            base_name = original_path.stem

            # æ£€æŸ¥æ˜¯å¦æ˜¯ä¸­é—´æ–‡ä»¶ï¼ˆåŒ…å«.f140, .f401ç­‰æ ¼å¼æ ‡è¯†ç¬¦ï¼‰
            is_intermediate_file = False
            if "." in base_name:
                parts = base_name.split(".")
                # å¦‚æœæœ€åä¸€éƒ¨åˆ†æ˜¯æ•°å­—ï¼ˆå¦‚f140, f401ï¼‰ï¼Œåˆ™ç§»é™¤å®ƒ
                if (
                    len(parts) > 1
                    and parts[-1].startswith("f")
                    and parts[-1][1:].isdigit()
                ):
                    base_name = ".".join(parts[:-1])
                    is_intermediate_file = True

            # å¦‚æœæ˜¯ä¸­é—´æ–‡ä»¶ï¼Œç›´æ¥æŸ¥æ‰¾åˆå¹¶åçš„æ–‡ä»¶
            if is_intermediate_file:
                logger.info(f"ğŸ” æ£€æµ‹åˆ°ä¸­é—´æ–‡ä»¶ï¼Œç›´æ¥æŸ¥æ‰¾åˆå¹¶åçš„æ–‡ä»¶: {final_file_path}")
                # æ„é€ æœ€ç»ˆæ–‡ä»¶åï¼ˆä¼˜å…ˆæŸ¥æ‰¾.mp4ï¼Œç„¶åæ˜¯å…¶ä»–æ ¼å¼ï¼‰
                possible_extensions = [".mp4", ".mkv", ".webm", ".avi", ".mov"]
                for ext in possible_extensions:
                    final_merged_file = original_path.parent / f"{base_name}{ext}"
                    logger.info(f"ğŸ” å°è¯•æŸ¥æ‰¾åˆå¹¶åçš„æ–‡ä»¶: {final_merged_file}")

                    if os.path.exists(final_merged_file):
                        logger.info(f"âœ… æ‰¾åˆ°åˆå¹¶åçš„æ–‡ä»¶: {final_merged_file}")
                        return str(final_merged_file)

                logger.warning(f"âš ï¸ æœªæ‰¾åˆ°åˆå¹¶åçš„æ–‡ä»¶ï¼ŒåŸºç¡€åç§°: {base_name}")
            else:
                # ä¸æ˜¯ä¸­é—´æ–‡ä»¶ï¼Œç›´æ¥æ£€æŸ¥æ˜¯å¦å­˜åœ¨
                if os.path.exists(final_file_path):
                    logger.info(f"âœ… ä½¿ç”¨progress_hookè®°å½•çš„æ–‡ä»¶è·¯å¾„: {final_file_path}")
                    return final_file_path

                # æ£€æŸ¥æ˜¯å¦ä¸ºYouTubeéŸ³é¢‘æ¨¡å¼ï¼Œå¦‚æœæ˜¯åˆ™æŸ¥æ‰¾å¯¹åº”çš„MP3æ–‡ä»¶
                if (hasattr(self, 'bot') and hasattr(self.bot, 'youtube_audio_mode') and
                    self.bot.youtube_audio_mode and self.is_youtube_url(url)):
                    # å°†åŸå§‹æ–‡ä»¶æ‰©å±•åæ›¿æ¢ä¸º.mp3
                    original_path = Path(final_file_path)
                    mp3_path = original_path.with_suffix('.mp3')
                    if mp3_path.exists():
                        logger.info(f"âœ… éŸ³é¢‘æ¨¡å¼ï¼šæ‰¾åˆ°è½¬æ¢åçš„MP3æ–‡ä»¶: {mp3_path}")
                        return str(mp3_path)
                    else:
                        logger.warning(f"âš ï¸ éŸ³é¢‘æ¨¡å¼ï¼šæœªæ‰¾åˆ°è½¬æ¢åçš„MP3æ–‡ä»¶: {mp3_path}")
                else:
                    # æ£€æŸ¥æ˜¯å¦ä¸ºä¸­é—´æ–‡ä»¶ï¼ˆåŒ…å«æ ¼å¼ä»£ç çš„æ–‡ä»¶ï¼‰
                    original_path = Path(final_file_path)
                    filename = original_path.name

                    # æ£€æŸ¥æ˜¯å¦ä¸ºDASHä¸­é—´æ–‡ä»¶
                    is_dash_intermediate = (
                        '.fdash-' in filename or
                        '.f' in filename and filename.count('.') >= 2 or
                        'dash-' in filename
                    )

                    if is_dash_intermediate:
                        logger.info(f"ğŸ” æ£€æµ‹åˆ°DASHä¸­é—´æ–‡ä»¶ï¼Œå°è¯•æŸ¥æ‰¾åˆå¹¶åçš„æ–‡ä»¶: {filename}")
                        # å°è¯•æŸ¥æ‰¾åˆå¹¶åçš„æ–‡ä»¶
                        base_name = filename.split('.f')[0] if '.f' in filename else filename.split('.')[0]
                        ext = '.mp4'  # åˆå¹¶åé€šå¸¸æ˜¯mp4æ ¼å¼
                        final_merged_file = original_path.parent / f"{base_name}{ext}"

                        if os.path.exists(final_merged_file):
                            logger.info(f"âœ… æ‰¾åˆ°DASHåˆå¹¶åçš„æ–‡ä»¶: {final_merged_file}")
                            return str(final_merged_file)
                        else:
                            logger.info(f"ğŸ” DASHåˆå¹¶æ–‡ä»¶ä¸å­˜åœ¨ï¼Œå°†ä½¿ç”¨å…¶ä»–æ–¹æ³•æŸ¥æ‰¾: {final_merged_file}")
                    else:
                        logger.warning(f"âš ï¸ progress_hookè®°å½•çš„æ–‡ä»¶è·¯å¾„ä¸å­˜åœ¨: {final_file_path}")

        # 2. åŸºäºé¢„æœŸæ–‡ä»¶åæŸ¥æ‰¾
        if expected_title:
            logger.info(f"ğŸ” åŸºäºé¢„æœŸæ–‡ä»¶åæŸ¥æ‰¾: {expected_title}")
            # ä½¿ç”¨ç»Ÿä¸€çš„æ–‡ä»¶åæ¸…ç†æ–¹æ³•
            safe_title = self._sanitize_filename(expected_title)
            if safe_title:
                # å°è¯•ä¸åŒçš„æ‰©å±•å
                possible_extensions = [".mp4", ".mkv", ".webm", ".avi", ".mov"]
                for ext in possible_extensions:
                    expected_file = download_path / f"{safe_title}{ext}"
                    logger.info(f"ğŸ” å°è¯•æŸ¥æ‰¾æ–‡ä»¶: {expected_file}")
                    if os.path.exists(expected_file):
                        logger.info(f"âœ… æ‰¾åˆ°åŸºäºæ ‡é¢˜çš„æ–‡ä»¶: {expected_file}")
                        return str(expected_file)

                logger.warning(f"âš ï¸ æœªæ‰¾åˆ°åŸºäºæ ‡é¢˜çš„æ–‡ä»¶: {safe_title}")

        # 3. åŸºäºå¹³å°ç‰¹å®šé€»è¾‘æŸ¥æ‰¾
        if url:
            logger.info(f"ğŸ” åŸºäºå¹³å°ç‰¹å®šé€»è¾‘æŸ¥æ‰¾: {url}")
            try:
                if self.is_x_url(url):
                    # Xå¹³å°ï¼šåŸºäºè§†é¢‘æ ‡é¢˜æŸ¥æ‰¾
                    logger.info("ğŸ” Xå¹³å°ï¼šå°è¯•è·å–è§†é¢‘æ ‡é¢˜å¹¶æŸ¥æ‰¾")
                    info_opts = {
                        "quiet": True,
                        "no_warnings": True,
                        "socket_timeout": 15,
                        "retries": 2,
                    }
                    if self.x_cookies_path and os.path.exists(self.x_cookies_path):
                        info_opts["cookiefile"] = self.x_cookies_path

                    with yt_dlp.YoutubeDL(info_opts) as ydl:
                        info = ydl.extract_info(url, download=False)
                        if info and info.get('title'):
                            title = info.get('title')
                            safe_title = self._sanitize_filename(title)
                            if safe_title:
                                logger.info(f"ğŸ” Xå¹³å°æ ‡é¢˜: {safe_title}")
                                # å°è¯•ä¸åŒçš„æ‰©å±•å
                                possible_extensions = [".mp4", ".mkv", ".webm", ".avi", ".mov"]
                                for ext in possible_extensions:
                                    expected_file = download_path / f"{safe_title}{ext}"
                                    logger.info(f"ğŸ” å°è¯•æŸ¥æ‰¾Xå¹³å°æ–‡ä»¶: {expected_file}")
                                    if os.path.exists(expected_file):
                                        logger.info(f"âœ… æ‰¾åˆ°Xå¹³å°æ–‡ä»¶: {expected_file}")
                                        return str(expected_file)

                                logger.warning(f"âš ï¸ æœªæ‰¾åˆ°Xå¹³å°æ–‡ä»¶ï¼Œæ ‡é¢˜: {safe_title}")
                            else:
                                logger.warning("âš ï¸ Xå¹³å°æ ‡é¢˜ä¸ºç©ºæˆ–æ— æ•ˆ")
                        else:
                            logger.warning("âš ï¸ æ— æ³•è·å–Xå¹³å°è§†é¢‘æ ‡é¢˜")
                else:
                    # å…¶ä»–å¹³å°ï¼šåŸºäºæ ‡é¢˜æŸ¥æ‰¾ï¼ˆå¦‚æœè¿˜æ²¡æœ‰å°è¯•è¿‡ï¼‰
                    if not expected_title:
                        logger.info("ğŸ” å…¶ä»–å¹³å°ï¼šå°è¯•è·å–è§†é¢‘æ ‡é¢˜å¹¶æŸ¥æ‰¾")
                        info_opts = {
                            "quiet": True,
                            "no_warnings": True,
                            "socket_timeout": 15,
                            "retries": 2,
                        }
                        if self.youtube_cookies_path and os.path.exists(self.youtube_cookies_path):
                            info_opts["cookiefile"] = self.youtube_cookies_path
                        if self.douyin_cookies_path and os.path.exists(self.douyin_cookies_path):
                            info_opts["cookiefile"] = self.douyin_cookies_path

                        with yt_dlp.YoutubeDL(info_opts) as ydl:
                            info = ydl.extract_info(url, download=False)
                            if info and info.get('title'):
                                title = info.get('title')
                                safe_title = self._sanitize_filename(title)
                                if safe_title:
                                    logger.info(f"ğŸ” å…¶ä»–å¹³å°æ ‡é¢˜: {safe_title}")
                                    # å°è¯•ä¸åŒçš„æ‰©å±•å
                                    possible_extensions = [".mp4", ".mkv", ".webm", ".avi", ".mov"]
                                    for ext in possible_extensions:
                                        expected_file = download_path / f"{safe_title}{ext}"
                                        logger.info(f"ğŸ” å°è¯•æŸ¥æ‰¾å…¶ä»–å¹³å°æ–‡ä»¶: {expected_file}")
                                        if os.path.exists(expected_file):
                                            logger.info(f"âœ… æ‰¾åˆ°å…¶ä»–å¹³å°æ–‡ä»¶: {expected_file}")
                                            return str(expected_file)

                                    logger.warning(f"âš ï¸ æœªæ‰¾åˆ°å…¶ä»–å¹³å°æ–‡ä»¶ï¼Œæ ‡é¢˜: {safe_title}")
            except Exception as e:
                logger.warning(f"âš ï¸ å¹³å°ç‰¹å®šæŸ¥æ‰¾å¤±è´¥: {e}")

        # 4. æœ€åå°è¯•ï¼šæ‰«æä¸‹è½½ç›®å½•ä¸­çš„æ‰€æœ‰è§†é¢‘æ–‡ä»¶
        logger.info("ğŸ” æœ€åå°è¯•ï¼šæ‰«æä¸‹è½½ç›®å½•ä¸­çš„æ‰€æœ‰è§†é¢‘æ–‡ä»¶")
        try:
            video_extensions = ['.mp4', '.mkv', '.webm', '.avi', '.mov', '.m4a', '.mp3']
            all_files = []
            
            for file_path in download_path.rglob('*'):
                if file_path.is_file() and file_path.suffix.lower() in video_extensions:
                    # è·å–æ–‡ä»¶çš„ä¿®æ”¹æ—¶é—´
                    mtime = file_path.stat().st_mtime
                    all_files.append((file_path, mtime))
            
            if all_files:
                # æŒ‰ä¿®æ”¹æ—¶é—´æ’åºï¼Œæœ€æ–°çš„æ–‡ä»¶ä¼˜å…ˆ
                all_files.sort(key=lambda x: x[1], reverse=True)
                latest_file = all_files[0][0]
                logger.info(f"âœ… æ‰¾åˆ°æœ€æ–°çš„è§†é¢‘æ–‡ä»¶: {latest_file}")
                return str(latest_file)
            else:
                logger.warning("âš ï¸ ä¸‹è½½ç›®å½•ä¸­æœªæ‰¾åˆ°ä»»ä½•è§†é¢‘æ–‡ä»¶")
        except Exception as e:
            logger.warning(f"âš ï¸ æ‰«æä¸‹è½½ç›®å½•æ—¶å‡ºé”™: {e}")

        # 5. å¦‚æœéƒ½æ‰¾ä¸åˆ°ï¼Œè®°å½•é”™è¯¯å¹¶è¿”å›None
        logger.error("âŒ æ— æ³•æ‰¾åˆ°é¢„æœŸçš„ä¸‹è½½æ–‡ä»¶")
        return None

    async def _download_with_ytdlp_unified(
        self,
        url: str,
        download_path: Path,
        message_updater=None,
        platform_name: str = "Unknown",
        content_type: str = "video",
        format_spec: str = "bestvideo[ext=mp4]+bestaudio[ext=m4a]/bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best",
        cookies_path: str = None
    ) -> Dict[str, Any]:
        """
        ç»Ÿä¸€çš„ yt-dlp ä¸‹è½½å‡½æ•°

        Args:
            url: ä¸‹è½½URL
            download_path: ä¸‹è½½ç›®å½•
            message_updater: æ¶ˆæ¯æ›´æ–°å™¨
            platform_name: å¹³å°åç§°
            content_type: å†…å®¹ç±»å‹ (video/image)
            format_spec: æ ¼å¼è§„æ ¼
            cookies_path: cookiesæ–‡ä»¶è·¯å¾„

        Returns:
            Dict[str, Any]: ä¸‹è½½ç»“æœ
        """
        try:
            import yt_dlp

            # ç¡®ä¿ä¸‹è½½ç›®å½•å­˜åœ¨
            os.makedirs(download_path, exist_ok=True)

            # é…ç½® yt-dlp
            # æ ¹æ®è®¾ç½®å†³å®šæ–‡ä»¶åæ¨¡æ¿
            if hasattr(self, 'bot') and hasattr(self.bot, 'youtube_id_tags') and self.bot.youtube_id_tags and self.is_youtube_url(url):
                outtmpl = '%(title).50s[%(id)s].%(ext)s'
            else:
                outtmpl = '%(title).50s.%(ext)s'

            ydl_opts = {
                'format': format_spec,
                'outtmpl': os.path.join(str(download_path), outtmpl),
                'verbose': False,
                'no_warnings': True,
                'extract_flat': False,
                'ignoreerrors': False,
                'no_check_certificate': True,
                'http_headers': {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
                }
            }

            # æ·»åŠ  cookies æ”¯æŒ
            if cookies_path and os.path.exists(cookies_path):
                ydl_opts["cookiefile"] = cookies_path
                logger.info(f"ğŸª ä½¿ç”¨cookies: {cookies_path}")

            # è¿›åº¦æ•°æ®å­˜å‚¨
            progress_data = {"final_filename": None, "lock": threading.Lock()}

            # ä½¿ç”¨ç»Ÿä¸€çš„å•é›†ä¸‹è½½è¿›åº¦å›è°ƒ
            # æ£€æŸ¥ message_updater æ˜¯å¦æ˜¯å¢å¼ºç‰ˆè¿›åº¦å›è°ƒå‡½æ•°
            if callable(message_updater) and message_updater.__name__ == 'enhanced_progress_callback':
                # å¦‚æœæ˜¯å¢å¼ºç‰ˆè¿›åº¦å›è°ƒï¼Œç›´æ¥ä½¿ç”¨å®ƒè¿”å›çš„ progress_hook
                progress_hook = message_updater(progress_data)
            else:
                # å¦åˆ™ä½¿ç”¨æ ‡å‡†çš„ single_video_progress_hook
                progress_hook = single_video_progress_hook(message_updater, progress_data, status_message, context)

            ydl_opts["progress_hooks"] = [progress_hook]

            # å¼€å§‹ä¸‹è½½
            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                logger.info(f"ğŸ¬ yt-dlp å¼€å§‹ä¸‹è½½ {platform_name} {content_type}...")
                info = ydl.extract_info(url, download=True)

                if not info:
                    raise Exception(f"yt-dlp æœªè·å–åˆ°{content_type}ä¿¡æ¯")

                # æ£€æŸ¥infoçš„ç±»å‹ï¼Œç¡®ä¿å®ƒæ˜¯å­—å…¸
                if not isinstance(info, dict):
                    logger.error(f"âŒ yt-dlp è¿”å›äº†éå­—å…¸ç±»å‹çš„ç»“æœ: {type(info)}, å†…å®¹: {info}")
                    raise Exception(f"yt-dlp è¿”å›äº†æ„å¤–çš„æ•°æ®ç±»å‹: {type(info)}")

                # æŸ¥æ‰¾ä¸‹è½½çš„æ–‡ä»¶
                filename = ydl.prepare_filename(info)
                logger.info(f"ğŸ” yt-dlp å‡†å¤‡çš„æ–‡ä»¶å: {filename}")

                if not os.path.exists(filename):
                    logger.info(f"âš ï¸ å‡†å¤‡çš„æ–‡ä»¶åä¸å­˜åœ¨ï¼Œå°è¯•æŸ¥æ‰¾å®é™…ä¸‹è½½çš„æ–‡ä»¶...")
                    # å°è¯•æŸ¥æ‰¾å®é™…ä¸‹è½½çš„æ–‡ä»¶
                    download_path_found = self.single_video_find_downloaded_file(
                        download_path,
                        progress_data,
                        info.get('title', ''),
                        url
                    )
                    if download_path_found:
                        filename = download_path_found
                        logger.info(f"âœ… æ‰¾åˆ°å®é™…ä¸‹è½½çš„æ–‡ä»¶: {filename}")
                    else:
                        raise Exception(f"æœªæ‰¾åˆ°ä¸‹è½½çš„{content_type}æ–‡ä»¶")
                else:
                    logger.info(f"âœ… ä½¿ç”¨yt-dlpå‡†å¤‡çš„æ–‡ä»¶å: {filename}")

                # é‡å‘½åæ–‡ä»¶ä»¥ä½¿ç”¨æ¸…ç†è¿‡çš„æ–‡ä»¶å
                try:
                    original_filename = filename
                    file_dir = os.path.dirname(filename)
                    file_ext = os.path.splitext(filename)[1]

                    # è·å–åŸå§‹æ ‡é¢˜å¹¶æ¸…ç†
                    original_title = info.get('title', f'{platform_name}_{content_type}')
                    clean_title = self._sanitize_filename(original_title)

                    # æ„å»ºæ–°çš„æ–‡ä»¶å
                    new_filename = os.path.join(file_dir, f"{clean_title}{file_ext}")

                    # å¦‚æœæ–°æ–‡ä»¶åä¸æ—§æ–‡ä»¶åä¸åŒï¼Œåˆ™é‡å‘½å
                    if new_filename != original_filename:
                        # å¦‚æœæ–°æ–‡ä»¶åå·²å­˜åœ¨ï¼Œæ·»åŠ æ•°å­—åç¼€
                        counter = 1
                        final_filename = new_filename
                        while os.path.exists(final_filename):
                            name_without_ext = os.path.splitext(new_filename)[0]
                            final_filename = f"{name_without_ext}_{counter}{file_ext}"
                            counter += 1

                        # é‡å‘½åæ–‡ä»¶
                        os.rename(original_filename, final_filename)
                        filename = final_filename
                        logger.info(f"âœ… æ–‡ä»¶å·²é‡å‘½åä¸º: {os.path.basename(filename)}")
                    else:
                        logger.info(f"âœ… æ–‡ä»¶åæ— éœ€é‡å‘½å")

                except Exception as e:
                    logger.warning(f"âš ï¸ é‡å‘½åæ–‡ä»¶å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹æ–‡ä»¶å: {e}")
                    # ç»§ç»­ä½¿ç”¨åŸå§‹æ–‡ä»¶å

                # è·å–æ–‡ä»¶ä¿¡æ¯
                file_size = os.path.getsize(filename)
                size_mb = file_size / 1024 / 1024

                logger.info(f"âœ… {platform_name} {content_type}ä¸‹è½½æˆåŠŸ: {filename} ({size_mb:.1f} MB)")

                # æ„å»ºè¿”å›ç»“æœ
                result = {
                    "success": True,
                    "platform": platform_name,
                    "content_type": content_type,
                    "download_path": filename,
                    "full_path": filename,
                    "size_mb": size_mb,
                    "title": info.get('title', f'{platform_name}{content_type}'),
                    "uploader": info.get('uploader', f'{platform_name}ç”¨æˆ·'),
                    "filename": os.path.basename(filename),
                }

                # æ ¹æ®å†…å®¹ç±»å‹æ·»åŠ ç‰¹å®šä¿¡æ¯
                if content_type == "video":
                    # è§†é¢‘ç‰¹æœ‰ä¿¡æ¯
                    duration = info.get('duration', 0)
                    width = info.get('width', 0)
                    height = info.get('height', 0)
                    resolution = f"{width}x{height}" if width and height else "æœªçŸ¥"

                    # æ ¼å¼åŒ–æ—¶é•¿
                    if duration:
                        minutes, seconds = divmod(int(duration), 60)
                        hours, minutes = divmod(minutes, 60)
                        if hours > 0:
                            duration_str = f"{hours}:{minutes:02d}:{seconds:02d}"
                        else:
                            duration_str = f"{minutes}:{seconds:02d}"
                    else:
                        duration_str = "æœªçŸ¥"

                    result.update({
                        "duration": duration,
                        "duration_str": duration_str,
                        "resolution": resolution,
                        "width": width,
                        "height": height,
                    })
                else:
                    # å›¾ç‰‡ç‰¹æœ‰ä¿¡æ¯
                    width = info.get('width', 0)
                    height = info.get('height', 0)
                    resolution = f"{width}x{height}" if width and height else "æœªçŸ¥"

                    result.update({
                        "resolution": resolution,
                        "width": width,
                        "height": height,
                    })

                return result

        except Exception as e:
            logger.error(f"âŒ yt-dlp ä¸‹è½½ {platform_name} {content_type}å¤±è´¥: {e}")
            return {
                "success": False,
                "error": f"yt-dlp ä¸‹è½½å¤±è´¥: {str(e)}",
                "platform": platform_name,
                "content_type": content_type
            }

    def cleanup_duplicates(self):
        """æ¸…ç†é‡å¤æ–‡ä»¶"""
        try:
            cleaned_count = 0
            for directory in [self.x_download_path, self.youtube_download_path]:
                if directory.exists():
                    for file in directory.glob("*"):
                        if file.is_file() and " #" in file.name:
                            # æ£€æŸ¥æ˜¯å¦æ˜¯è§†é¢‘æ–‡ä»¶
                            if any(
                                file.name.endswith(ext)
                                for ext in [".mp4", ".mkv", ".webm", ".mov", ".avi"]
                            ):
                                try:
                                    file.unlink()
                                    logger.info(f"åˆ é™¤é‡å¤æ–‡ä»¶: {file.name}")
                                    cleaned_count += 1
                                except Exception as e:
                                    logger.error(f"åˆ é™¤æ–‡ä»¶å¤±è´¥: {e}")
            return cleaned_count
        except Exception as e:
            logger.error(f"æ¸…ç†é‡å¤æ–‡ä»¶å¤±è´¥: {e}")
            return 0

    def _generate_display_filename(self, original_filename, timestamp):
        """ç”Ÿæˆç”¨æˆ·å‹å¥½çš„æ˜¾ç¤ºæ–‡ä»¶å"""
        try:
            # ç§»é™¤æ—¶é—´æˆ³å‰ç¼€
            if original_filename.startswith(f"{timestamp}_"):
                display_name = original_filename[len(f"{timestamp}_") :]
            else:
                display_name = original_filename
            # å¦‚æœæ–‡ä»¶åå¤ªé•¿ï¼Œæˆªæ–­å®ƒ
            if len(display_name) > 35:
                name, ext = os.path.splitext(display_name)
                display_name = name[:30] + "..." + ext
            return display_name
        except BaseException:
            return original_filename

    def _detect_x_content_type(self, url: str) -> str:
        """æ£€æµ‹ X é“¾æ¥çš„å†…å®¹ç±»å‹ï¼ˆå›¾ç‰‡/è§†é¢‘ï¼‰"""
        logger.info(f"ğŸ” å¼€å§‹æ£€æµ‹ X å†…å®¹ç±»å‹: {url}")

        # æ–¹æ³•1: ä½¿ç”¨ yt-dlp æ£€æµ‹ï¼ˆæœ€å‡†ç¡®ï¼‰
        content_type = self._detect_with_ytdlp(url)
        if content_type:
            return content_type

        # æ–¹æ³•2: ä½¿ç”¨ curl æ£€æµ‹ï¼ˆå¤‡ç”¨ï¼‰
        content_type = self._detect_with_curl(url)
        if content_type:
            return content_type

        # æ–¹æ³•3: é»˜è®¤å¤„ç† - å½“æˆè§†é¢‘ç”¨ yt-dlp ä¸‹è½½
        logger.info("ğŸ¬ æ£€æµ‹å¤±è´¥ï¼Œé»˜è®¤ä¸ºè§†é¢‘ç±»å‹ï¼Œä½¿ç”¨ yt-dlp ä¸‹è½½")
        return "video"

    def _detect_with_ytdlp(self, url: str) -> str:
        """ä½¿ç”¨ yt-dlp æ£€æµ‹å†…å®¹ç±»å‹"""
        try:
            import yt_dlp

            # é…ç½® yt-dlp é€‰é¡¹
            ydl_opts = {
                "quiet": True,
                "no_warnings": True,
                "extract_flat": False,  # ä¸ä½¿ç”¨ flat æ¨¡å¼ï¼Œè·å–å®Œæ•´ä¿¡æ¯
                "skip_download": True,  # ä¸ä¸‹è½½ï¼Œåªè·å–ä¿¡æ¯
                "socket_timeout": 15,   # 15ç§’è¶…æ—¶
                "retries": 2,           # å‡å°‘é‡è¯•æ¬¡æ•°
            }

            # æ·»åŠ  cookies æ”¯æŒ
            if self.x_cookies_path and os.path.exists(self.x_cookies_path):
                ydl_opts["cookiefile"] = self.x_cookies_path
                logger.info(f"ğŸª yt-dlp ä½¿ç”¨X cookies: {self.x_cookies_path}")

            with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                logger.info("ğŸ” yt-dlp å¼€å§‹æå–ä¿¡æ¯...")
                info = ydl.extract_info(url, download=False)

                if not info:
                    logger.warning("âš ï¸ yt-dlp æœªè·å–åˆ°ä¿¡æ¯")
                    return None

                # ä¼˜å…ˆæ£€æŸ¥æ˜¯å¦æœ‰è§†é¢‘æ ¼å¼ï¼ˆæœ€é«˜ä¼˜å…ˆçº§ï¼‰
                formats = info.get('formats', [])
                if formats:
                    # æŸ¥æ‰¾æœ‰è§†é¢‘ç¼–ç çš„æ ¼å¼
                    video_formats = [f for f in formats if f.get('vcodec') and f.get('vcodec') != 'none']
                    if video_formats:
                        logger.info(f"ğŸ¬ yt-dlp æ£€æµ‹åˆ°è§†é¢‘å†…å®¹ï¼Œæ‰¾åˆ° {len(video_formats)} ä¸ªè§†é¢‘æ ¼å¼")
                        return "video"

                # æ£€æŸ¥å…¶ä»–è§†é¢‘æŒ‡æ ‡
                if info.get('duration') and info.get('duration') > 0:
                    logger.info(f"ğŸ¬ yt-dlp é€šè¿‡æ—¶é•¿æ£€æµ‹åˆ°è§†é¢‘å†…å®¹: {info.get('duration')}ç§’")
                    return "video"

                # æ£€æŸ¥æ–‡ä»¶æ‰©å±•åï¼ˆè§†é¢‘ä¼˜å…ˆï¼‰
                filename = info.get('filename', '')
                if any(ext in filename.lower() for ext in ['.mp4', '.webm', '.mov', '.avi']):
                    logger.info(f"ğŸ¬ yt-dlp é€šè¿‡æ–‡ä»¶åæ£€æµ‹åˆ°è§†é¢‘å†…å®¹: {filename}")
                    return "video"

                # æœ€åæ£€æŸ¥æ˜¯å¦æœ‰å›¾ç‰‡ä¿¡æ¯
                thumbnails = info.get('thumbnails', [])
                if thumbnails:
                    logger.info(f"ğŸ“¸ yt-dlp æ£€æµ‹åˆ°å›¾ç‰‡å†…å®¹ï¼Œæ‰¾åˆ° {len(thumbnails)} ä¸ªç¼©ç•¥å›¾")
                    return "image"

                # æ£€æŸ¥å›¾ç‰‡æ–‡ä»¶æ‰©å±•å
                if any(ext in filename.lower() for ext in ['.jpg', '.jpeg', '.png', '.gif', '.webp']):
                    logger.info(f"ğŸ“¸ yt-dlp é€šè¿‡æ–‡ä»¶åæ£€æµ‹åˆ°å›¾ç‰‡å†…å®¹: {filename}")
                    return "image"

                logger.info("ğŸ¬ yt-dlp æœªæ£€æµ‹åˆ°æ˜ç¡®å†…å®¹ç±»å‹ï¼Œé»˜è®¤ä¸ºè§†é¢‘ç±»å‹")
                return "video"

        except Exception as e:
            logger.warning(f"âš ï¸ yt-dlp æ£€æµ‹å¤±è´¥: {e}")
        return None

    def _detect_with_curl(self, url: str) -> str:
        """ä½¿ç”¨ curl æ£€æµ‹å†…å®¹ç±»å‹ï¼ˆå¤‡ç”¨æ–¹æ³•ï¼‰"""
        try:
            import subprocess
            import re
            import gzip

            # æ„å»º curl å‘½ä»¤
            curl_cmd = [
                "curl", "-s", "-L", "-k",  # é™é»˜æ¨¡å¼ï¼Œè·Ÿéšé‡å®šå‘ï¼Œç¦ç”¨SSLéªŒè¯
                "-H", "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                "-H", "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
                "-H", "Accept-Language: en-US,en;q=0.5",
                "-H", "Accept-Encoding: gzip, deflate, br",
                "-H", "DNT: 1",
                "-H", "Connection: keep-alive",
                "-H", "Upgrade-Insecure-Requests: 1",
                "--max-time", "10",  # 10ç§’è¶…æ—¶
            ]

            # å¦‚æœæœ‰ cookiesï¼Œæ·»åŠ  cookies æ–‡ä»¶
            if self.x_cookies_path and os.path.exists(self.x_cookies_path):
                curl_cmd.extend(["-b", self.x_cookies_path])
                logger.info(f"ğŸª curl ä½¿ç”¨X cookies: {self.x_cookies_path}")

            curl_cmd.append(url)

            # æ‰§è¡Œ curl å‘½ä»¤
            logger.info("ğŸ” curl å¼€å§‹æ£€æµ‹å†…å®¹ç±»å‹...")
            result = subprocess.run(curl_cmd, capture_output=True, timeout=15)

            if result.returncode != 0:
                logger.warning(f"âš ï¸ curl è¯·æ±‚å¤±è´¥: {result.stderr}")
                return None

            # å¤„ç†å“åº”å†…å®¹
            try:
                html_content = result.stdout.decode('utf-8')
            except UnicodeDecodeError:
                try:
                    html_content = gzip.decompress(result.stdout).decode('utf-8')
                except Exception:
                    html_content = result.stdout.decode('utf-8', errors='ignore')

            # æ£€æµ‹è§†é¢‘ç›¸å…³çš„ HTML å…ƒç´ 
            video_patterns = [
                r'<video[^>]*>',
                r'data-testid="videoPlayer"',
                r'data-testid="video"',
                r'aria-label="[^"]*video[^"]*"',
                r'class="[^"]*video[^"]*"',
            ]

            # æ£€æµ‹å›¾ç‰‡ç›¸å…³çš„ HTML å…ƒç´ 
            image_patterns = [
                r'<img[^>]*>',
                r'data-testid="tweetPhoto"',
                r'data-testid="image"',
                r'aria-label="[^"]*image[^"]*"',
                r'class="[^"]*image[^"]*"',
            ]

            # æ£€æŸ¥è§†é¢‘æ¨¡å¼
            for pattern in video_patterns:
                if re.search(pattern, html_content, re.IGNORECASE):
                    logger.info(f"ğŸ¬ curl æ£€æµ‹åˆ°è§†é¢‘å†…å®¹ (æ¨¡å¼: {pattern})")
                    return "video"

            # æ£€æŸ¥å›¾ç‰‡æ¨¡å¼
            for pattern in image_patterns:
                if re.search(pattern, html_content, re.IGNORECASE):
                    logger.info(f"ğŸ“¸ curl æ£€æµ‹åˆ°å›¾ç‰‡å†…å®¹ (æ¨¡å¼: {pattern})")
                    return "image"

            # æ–‡æœ¬æ£€æµ‹
            if re.search(r'video|mp4|webm|mov', html_content, re.IGNORECASE):
                logger.info("ğŸ¬ curl é€šè¿‡æ–‡æœ¬æ£€æµ‹åˆ°è§†é¢‘å†…å®¹")
                return "video"

            if re.search(r'image|photo|jpg|jpeg|png|gif|webp', html_content, re.IGNORECASE):
                logger.info("ğŸ“¸ curl é€šè¿‡æ–‡æœ¬æ£€æµ‹åˆ°å›¾ç‰‡å†…å®¹")
                return "image"

            logger.info("ğŸ“¸ curl æœªæ£€æµ‹åˆ°æ˜ç¡®å†…å®¹ç±»å‹")
            return None

        except subprocess.TimeoutExpired:
            logger.warning("âš ï¸ curl è¯·æ±‚è¶…æ—¶")
            return None
        except Exception as e:
            logger.warning(f"âš ï¸ curl æ£€æµ‹å¤±è´¥: {e}")
            return None

    async def download_video(
        self, url: str, message_updater=None, auto_playlist=False, status_message=None, loop=None, context=None
    ) -> Dict[str, Any]:
        logger.info(f"ğŸš€ [DOWNLOAD_VIDEO] å‡½æ•°è¢«è°ƒç”¨ï¼ŒURL: {url}")
        logger.info(f"ğŸš€ [DOWNLOAD_VIDEO] message_updaterç±»å‹: {type(message_updater)}")
        logger.info(f"ğŸš€ [DOWNLOAD_VIDEO] message_updateræ˜¯å¦ä¸ºNone: {message_updater is None}")
        # è‡ªåŠ¨ä¿®æ­£å°çº¢ä¹¦çŸ­é“¾åè®®
        if url.startswith("tp://"):
            logger.info("æ£€æµ‹åˆ° tp:// åè®®ï¼Œè‡ªåŠ¨ä¿®æ­£ä¸º http://")
            url = "http://" + url[5:]
        elif url.startswith("tps://"):
            logger.info("æ£€æµ‹åˆ° tps:// åè®®ï¼Œè‡ªåŠ¨ä¿®æ­£ä¸º https://")
            url = "https://" + url[6:]

        # è‡ªåŠ¨å±•å¼€å¾®åšçŸ­é“¾æ¥
        if self.is_weibo_url(url):
            logger.info(f"ğŸ” æ£€æµ‹åˆ°å¾®åšURLï¼Œå¼€å§‹å±•å¼€çŸ­é“¾æ¥: {url}")
            expanded_url = self._expand_weibo_short_url(url)
            if expanded_url != url:
                logger.info(f"ğŸ”„ çŸ­é“¾æ¥å±•å¼€æˆåŠŸ: {url} -> {expanded_url}")
                url = expanded_url
                logger.info(f"ğŸ”„ ä½¿ç”¨å±•å¼€åçš„å¾®åšé“¾æ¥: {url}")
            else:
                logger.info(f"â„¹ï¸ URLæ— éœ€å±•å¼€æˆ–å±•å¼€å¤±è´¥ï¼Œç»§ç»­ä½¿ç”¨åŸURL: {url}")
        
        # é¦–å…ˆè¿›è¡ŒURLæ¸…ç†ï¼Œæå–çº¯é“¾æ¥
        original_url = url
        
        # æ£€æŸ¥æ˜¯å¦éœ€è¦URLæ¸…ç†ï¼ˆåŒ…å«ä¸­æ–‡æè¿°æˆ–ç¼ºå°‘åè®®å‰ç¼€ï¼‰
        needs_cleanup = (' ' in url or 'ï¼ˆ' in url or 'ï¼‰' in url or 'ã€Š' in url or 'ã€‹' in url or '@' in url or 
                        not url.startswith(('http://', 'https://')))
        
        if needs_cleanup:
            logger.info(f"ğŸ”§ æ£€æµ‹åˆ°éœ€è¦æ¸…ç†çš„URLï¼Œå¼€å§‹æ¸…ç†: {url}")
            
            # ä¼˜å…ˆä½¿ç”¨ä¸“é—¨çš„ç½‘æ˜“äº‘éŸ³ä¹URLæ¸…ç†æ–¹æ³•
            clean_url = self._clean_netease_url_special(url)
            if clean_url and clean_url != url:
                logger.info(f"ğŸ”§ ç½‘æ˜“äº‘éŸ³ä¹URLæ¸…ç†æˆåŠŸ: {url} -> {clean_url}")
                url = clean_url
            else:
                # å¦‚æœç½‘æ˜“äº‘éŸ³ä¹æ¸…ç†å¤±è´¥ï¼Œä½¿ç”¨é€šç”¨æ¸…ç†æ–¹æ³•
                clean_url = self._extract_clean_url_from_text(url)
                if clean_url and clean_url != url:
                    logger.info(f"ğŸ”§ é€šç”¨URLæ¸…ç†æˆåŠŸ: {url} -> {clean_url}")
                    url = clean_url
                else:
                    # å¦‚æœæ¸…ç†å¤±è´¥ä½†URLç¼ºå°‘åè®®å‰ç¼€ï¼Œå°è¯•æ·»åŠ 
                    if not url.startswith(('http://', 'https://')):
                        logger.info(f"ğŸ”§ URLç¼ºå°‘åè®®å‰ç¼€ï¼Œå°è¯•æ·»åŠ : {url}")
                        url = 'https://' + url
                        logger.info(f"ğŸ”§ æ·»åŠ åè®®å‰ç¼€å: {url}")
                    else:
                        logger.warning(f"âš ï¸ URLæ¸…ç†å¤±è´¥ï¼Œä½¿ç”¨åŸå§‹URL: {url}")
        
        # é€šç”¨URLé‡å®šå‘æ£€æµ‹å’Œå¹³å°é‡æ–°è¯†åˆ«ï¼ˆå®Œå…¨è·³è¿‡ç½‘æ˜“äº‘éŸ³ä¹é“¾æ¥ï¼‰
        if not self.is_netease_url(url):
            logger.info(f"ğŸ”„ å¼€å§‹URLé‡å®šå‘æ£€æµ‹: {url}")
            try:
                # ä½¿ç”¨yt-dlpæ£€æµ‹URLé‡å®šå‘
                temp_opts = {
                    'quiet': True,
                    'no_warnings': True,
                    'extract_flat': True,
                }
                with yt_dlp.YoutubeDL(temp_opts) as ydl:
                    temp_info = ydl.extract_info(url, download=False)
                
                if temp_info and temp_info.get("webpage_url") and temp_info["webpage_url"] != url:
                    redirected_url = temp_info["webpage_url"]
                    logger.info(f"ğŸ”„ æ£€æµ‹åˆ°URLé‡å®šå‘: {url} -> {redirected_url}")
                    
                    # æ£€æŸ¥é‡å®šå‘åçš„URLæ˜¯å¦ä¸ºç½‘æ˜“äº‘éŸ³ä¹
                    if self.is_netease_url(redirected_url) and not self.is_netease_url(url):
                        logger.info(f"ğŸµ é‡å®šå‘åæ£€æµ‹åˆ°ç½‘æ˜“äº‘éŸ³ä¹é“¾æ¥ï¼Œæ›´æ–°URL: {redirected_url}")
                        url = redirected_url
                    elif self.is_apple_music_url(redirected_url) and not self.is_apple_music_url(url):
                        logger.info(f"ğŸ é‡å®šå‘åæ£€æµ‹åˆ°Apple Musicé“¾æ¥ï¼Œæ›´æ–°URL: {redirected_url}")
                        url = redirected_url
                    # å¯ä»¥æ·»åŠ å…¶ä»–å¹³å°çš„é‡å®šå‘æ£€æµ‹
            except Exception as e:
                logger.info(f"URLé‡å®šå‘æ£€æµ‹å¤±è´¥: {e}")
        else:
            logger.info(f"ğŸµ æ£€æµ‹åˆ°ç½‘æ˜“äº‘éŸ³ä¹é“¾æ¥ï¼Œå®Œå…¨è·³è¿‡URLé‡å®šå‘æ£€æµ‹: {url}")
            # ç¡®ä¿ç½‘æ˜“äº‘éŸ³ä¹é“¾æ¥ä¸ä¼šè¢«yt-dlpå¤„ç†
            logger.info(f"ğŸµ ç½‘æ˜“äº‘éŸ³ä¹é“¾æ¥å°†ç›´æ¥ä¼ é€’ç»™ç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½å™¨: {url}")
            # ç¡®ä¿URLæ ¼å¼æ­£ç¡®
            if not url.startswith(('http://', 'https://')):
                logger.warning(f"âš ï¸ ç½‘æ˜“äº‘éŸ³ä¹URLç¼ºå°‘åè®®å‰ç¼€ï¼Œè‡ªåŠ¨æ·»åŠ : {url}")
                url = 'https://' + url
                logger.info(f"ğŸ”§ ä¿®å¤åçš„URL: {url}")
        
        # æ·»åŠ è¯¦ç»†çš„è°ƒè¯•æ—¥å¿—
        logger.info(f"ğŸ” download_video å¼€å§‹å¤„ç†URL: {url}")
        logger.info(f"ğŸ” è‡ªåŠ¨ä¸‹è½½å…¨é›†æ¨¡å¼: {'å¼€å¯' if auto_playlist else 'å…³é—­'}")
        # æ£€æŸ¥URLç±»å‹
        is_bilibili = self.is_bilibili_url(url)
        is_list, uid, list_id = self.is_bilibili_list_url(url)
        is_user_lists, user_uid = self.is_bilibili_user_lists_url(url)
        is_ugc_season, ugc_bv_id, season_id = self.is_bilibili_ugc_season(url)
        is_multi_part, bv_id = self.is_bilibili_multi_part_video(url)
        logger.info(f"ğŸ” å³å°†è°ƒç”¨is_youtube_playlist_urlæ£€æŸ¥: {url}")
        is_youtube_playlist, playlist_id = self.is_youtube_playlist_url(url)
        logger.info(f"ğŸ¯ is_youtube_playlist_urlè¿”å›ç»“æœ: is_playlist={is_youtube_playlist}, playlist_id={playlist_id}")

        # æ£€æŸ¥æ˜¯å¦ä¸ºMixæ’­æ”¾åˆ—è¡¨ä½†åŠŸèƒ½å…³é—­çš„æƒ…å†µï¼Œéœ€è¦æ¸…ç†URL
        is_mix_playlist_disabled = False
        if not is_youtube_playlist and "list=RDMM" in url:
            logger.info("ğŸµ æ£€æµ‹åˆ°Mixæ’­æ”¾åˆ—è¡¨ä½†åŠŸèƒ½å…³é—­ï¼Œæ¸…ç†URLä¸­çš„æ’­æ”¾åˆ—è¡¨å‚æ•°")
            import re
            # ç§»é™¤æ’­æ”¾åˆ—è¡¨ç›¸å…³å‚æ•°
            original_url = url
            url = re.sub(r'[&?]list=[^&]*', '', url)
            url = re.sub(r'[&?]index=[^&]*', '', url)
            # æ¸…ç†å¯èƒ½çš„å¤šä½™&ç¬¦å·
            url = re.sub(r'[&]{2,}', '&', url)
            url = re.sub(r'[?&]$', '', url)
            logger.info(f"ğŸ”— åŸå§‹URL: {original_url}")
            logger.info(f"ğŸ”— æ¸…ç†åURL: {url}")
            is_mix_playlist_disabled = True
        is_youtube_channel, channel_url = self.is_youtube_channel_playlists_url(url)
        logger.info(f"ğŸ” YouTubeé¢‘é“è¯†åˆ«ç»“æœ: is_youtube_channel={is_youtube_channel}, channel_url={channel_url}")
        is_x = self.is_x_url(url)
        is_telegraph = self.is_telegraph_url(url)
        is_douyin = self.is_douyin_url(url)
        is_kuaishou = self.is_kuaishou_url(url)
        is_facebook = self.is_facebook_url(url)
        is_netease = self.is_netease_url(url)
        platform = self.get_platform_name(url)
        logger.info(f"ğŸ” URLè¯†åˆ«ç»“æœ:")
        logger.info(f"  - is_bilibili_url: {is_bilibili}")
        logger.info(
            f"  - is_bilibili_list_url: {is_list}, uid: {uid}, list_id: {list_id}"
        )
        logger.info(
            f"  - is_bilibili_user_lists_url: {is_user_lists}, uid: {user_uid}"
        )
        logger.info(
            f"  - is_bilibili_ugc_season: {is_ugc_season}, bv_id: {ugc_bv_id}, season_id: {season_id}"
        )
        logger.info(
            f"  - is_bilibili_multi_part: {is_multi_part}, bv_id: {bv_id}"
        )
        logger.info(
            f"  - is_youtube_playlist: {is_youtube_playlist}, playlist_id: {playlist_id}"
        )
        logger.info(f"  - is_youtube_channel: {is_youtube_channel}, channel_url: {channel_url if is_youtube_channel else 'None'}")
        logger.info(f"  - is_x_url: {is_x}")
        logger.info(f"  - is_telegraph_url: {is_telegraph}")
        logger.info(f"  - is_netease_url: {is_netease}")
        logger.info(f"  - platform: {platform}")
        download_path = self.get_download_path(url)
        logger.info(f"ğŸ“ è·å–åˆ°çš„ä¸‹è½½è·¯å¾„: {download_path}")

        # å¤„ç† X é“¾æ¥ - å¤šé›†æ£€æµ‹ä¼˜å…ˆ
        if is_x:
            is_x_playlist, playlist_info = self.is_x_playlist_url(url)
            if is_x_playlist:
                logger.info(f"ğŸ¬ æ£€æµ‹åˆ°Xå¤šé›†è§†é¢‘ï¼Œå…±{playlist_info['total_videos']}ä¸ªè§†é¢‘")
                return await self._download_x_playlist(url, download_path, message_updater, playlist_info)
            logger.info("ğŸ” æ£€æµ‹åˆ°Xé“¾æ¥ï¼Œå¼€å§‹æ£€æµ‹å†…å®¹ç±»å‹...")
            # æ£€æµ‹å†…å®¹ç±»å‹
            content_type = self._detect_x_content_type(url)
            logger.info(f"ğŸ“Š æ£€æµ‹åˆ°å†…å®¹ç±»å‹: {content_type}")
            if content_type == "video":
                # è§†é¢‘ä½¿ç”¨ç»Ÿä¸€çš„å•è§†é¢‘ä¸‹è½½å‡½æ•°
                logger.info("ğŸ¬ X è§†é¢‘ä½¿ç”¨ç»Ÿä¸€çš„å•è§†é¢‘ä¸‹è½½å‡½æ•°")
                return await self._download_single_video(url, download_path, message_updater, status_message=status_message, context=context)
            else:
                # å›¾ç‰‡ä½¿ç”¨ gallery-dl ä¸‹è½½
                logger.info("ğŸ“¸ X å›¾ç‰‡ä½¿ç”¨ gallery-dl ä¸‹è½½")
                return await self.download_with_gallery_dl(url, download_path, message_updater)
        # å¤„ç† Telegraph é“¾æ¥ï¼ˆä½¿ç”¨ gallery-dlï¼‰
        if is_telegraph:
            logger.info(f"ğŸ“¸ æ£€æµ‹åˆ°Telegraphé“¾æ¥ï¼Œä½¿ç”¨ gallery-dl ä¸‹è½½")
            return await self.download_with_gallery_dl(url, download_path, message_updater)

        # å¤„ç†æŠ–éŸ³é“¾æ¥ - ä½¿ç”¨Playwrightæ–¹æ³•
        if is_douyin:
            logger.info("ğŸ¬ æ£€æµ‹åˆ°æŠ–éŸ³é“¾æ¥ï¼Œä½¿ç”¨Playwrightæ–¹æ³•ä¸‹è½½")
            # åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿçš„messageå¯¹è±¡ç”¨äºPlaywrightæ–¹æ³•
            class MockMessage:
                def __init__(self, chat_id=0):
                    self.chat_id = chat_id
                    self.message_id = 0

            mock_message = MockMessage()
            return await self._download_douyin_with_playwright(url, mock_message, message_updater)

        # å¤„ç†å¿«æ‰‹é“¾æ¥ - ä½¿ç”¨Playwrightæ–¹æ³•
        if is_kuaishou:
            logger.info("âš¡ æ£€æµ‹åˆ°å¿«æ‰‹é“¾æ¥ï¼Œä½¿ç”¨Playwrightæ–¹æ³•ä¸‹è½½")
            # åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿçš„messageå¯¹è±¡ç”¨äºPlaywrightæ–¹æ³•
            class MockMessage:
                def __init__(self, chat_id=0):
                    self.chat_id = chat_id
                    self.message_id = 0

            mock_message = MockMessage()
            return await self._download_kuaishou_with_playwright(url, mock_message, message_updater)

        # å¤„ç†Facebooké“¾æ¥ - ä½¿ç”¨yt-dlpæ–¹æ³•ï¼ˆå‚è€ƒYouTubeå•é›†ä¸‹è½½ï¼‰
        if self.is_facebook_url(url):
            logger.info("ğŸ“˜ æ£€æµ‹åˆ°Facebooké“¾æ¥ï¼Œä½¿ç”¨yt-dlpæ–¹æ³•ä¸‹è½½")
            return await self._download_single_video(url, download_path, message_updater, status_message=status_message, context=context)

        # å¤„ç†å°çº¢ä¹¦é“¾æ¥ - æ£€æµ‹å†…å®¹ç±»å‹å¹¶é€‰æ‹©åˆé€‚çš„ä¸‹è½½æ–¹æ³•
        if self.is_xiaohongshu_url(url):
            logger.info("ğŸ“– æ£€æµ‹åˆ°å°çº¢ä¹¦é“¾æ¥")
            
            # æ£€æµ‹å†…å®¹ç±»å‹ï¼ˆå›¾ç‰‡æˆ–è§†é¢‘ï¼‰
            content_type = await self._detect_xiaohongshu_content_type(url)
            logger.info(f"ğŸ“Š å°çº¢ä¹¦å†…å®¹ç±»å‹: {content_type}")
            
            if content_type == "image":
                logger.info("ğŸ–¼ï¸ æ£€æµ‹åˆ°å°çº¢ä¹¦å›¾ç‰‡ï¼Œä½¿ç”¨xiaohongshu_downloaderæ–¹æ³•ä¸‹è½½")
                return await self._download_xiaohongshu_image_with_downloader(url, message_updater)
            else:
                logger.info("ğŸ¬ æ£€æµ‹åˆ°å°çº¢ä¹¦è§†é¢‘ï¼Œä½¿ç”¨Playwrightæ–¹æ³•ä¸‹è½½")
                # åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿçš„messageå¯¹è±¡ç”¨äºPlaywrightæ–¹æ³•
                class MockMessage:
                    def __init__(self, chat_id=0):
                        self.chat_id = chat_id
                        self.message_id = 0

                mock_message = MockMessage()
                return await self._download_xiaohongshu_with_playwright(url, mock_message, message_updater)

        # å¤„ç†ç½‘æ˜“äº‘éŸ³ä¹é“¾æ¥
        if is_netease:
            logger.info("ğŸµ æ£€æµ‹åˆ°ç½‘æ˜“äº‘éŸ³ä¹é“¾æ¥ï¼Œä½¿ç”¨ç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½å™¨")
            return await self._download_netease_music(url, download_path, message_updater, status_message, context)

        # å¤„ç†QQéŸ³ä¹é“¾æ¥
        if self.is_qqmusic_url(url):
            logger.info("ğŸµ æ£€æµ‹åˆ°QQéŸ³ä¹é“¾æ¥ï¼Œä½¿ç”¨QQéŸ³ä¹ä¸‹è½½å™¨")
            return await self._download_qqmusic_music(url, download_path, message_updater, status_message, context)

        # å¤„ç†YouTube Musicé“¾æ¥
        if self.is_youtube_music_url(url):
            logger.info("ğŸµ æ£€æµ‹åˆ°YouTube Musicé“¾æ¥ï¼Œä½¿ç”¨YouTube Musicä¸‹è½½å™¨")
            return await self._download_youtubemusic_music(url, download_path, message_updater, status_message, context)

        # å¤„ç† Apple Music é“¾æ¥
        if self.is_apple_music_url(url):
            # æ ¹æ®ç¯å¢ƒå˜é‡æ˜¾ç¤ºä¸åŒçš„æ—¥å¿—ä¿¡æ¯
            use_amd = os.environ.get("AMDP", "false").lower() == "true"
            if use_amd:
                logger.info("ğŸ æ£€æµ‹åˆ° Apple Music é“¾æ¥ï¼Œä½¿ç”¨ Apple Music Plus ä¸‹è½½å™¨ (AMD)")
            else:
                logger.info("ğŸ æ£€æµ‹åˆ° Apple Music é“¾æ¥ï¼Œä½¿ç”¨ Apple Music ä¸‹è½½å™¨ (GAMDL)")
            return await self._download_apple_music(url, download_path, message_updater, status_message, context)

        # å¤„ç† YouTube é¢‘é“æ’­æ”¾åˆ—è¡¨
        if is_youtube_channel:
            logger.info("âœ… æ£€æµ‹åˆ°YouTubeé¢‘é“æ’­æ”¾åˆ—è¡¨ï¼Œå¼€å§‹ä¸‹è½½æ‰€æœ‰æ’­æ”¾åˆ—è¡¨")
            # message_updaterå‚æ•°å·²æ­£ç¡®ä¼ é€’
            return await self._download_youtube_channel_playlists(
                channel_url, download_path, message_updater, status_message, loop
            )
        # å¤„ç† YouTube æ’­æ”¾åˆ—è¡¨
        logger.info(f"ğŸ” æ£€æŸ¥YouTubeæ’­æ”¾åˆ—è¡¨åˆ†æ”¯: is_youtube_playlist={is_youtube_playlist}")
        if is_youtube_playlist:
            logger.info(f"âœ… æ£€æµ‹åˆ°YouTubeæ’­æ”¾åˆ—è¡¨ï¼Œæ’­æ”¾åˆ—è¡¨ID: {playlist_id}")

            # ä¸ºå•ä¸ªæ’­æ”¾åˆ—è¡¨ä¸‹è½½åˆ›å»ºè¿›åº¦å›è°ƒ
            if message_updater:
                # åˆ›å»ºæ’­æ”¾åˆ—è¡¨ä¸“ç”¨çš„è¿›åº¦å›è°ƒ
                playlist_progress_data = {
                    "playlist_index": 1,
                    "total_playlists": 1,
                    "playlist_title": "æ’­æ”¾åˆ—è¡¨",  # ä¸´æ—¶æ ‡é¢˜ï¼Œä¼šåœ¨ä¸‹è½½æ—¶æ›´æ–°
                    "current_video": 0,
                    "total_videos": 0,
                    "downloaded_videos": 0,
                }

                # ä½¿ç”¨ä¸é¢‘é“ä¸‹è½½ç›¸åŒçš„è¿›åº¦å›è°ƒåˆ›å»ºå‡½æ•°
                def create_single_playlist_progress_callback(progress_data):
                    last_update = {"percent": -1, "time": 0, "text": ""}
                    import time as _time

                    # æ•è·å¤–å±‚ä½œç”¨åŸŸçš„å˜é‡
                    captured_message_updater = message_updater
                    captured_status_message = status_message if 'status_message' in locals() else None
                    captured_loop = loop if 'loop' in locals() else None

                    def escape_num(text):
                        # è½¬ä¹‰MarkdownV2ç‰¹æ®Šå­—ç¬¦ï¼ŒåŒ…æ‹¬å°æ•°ç‚¹
                        if not isinstance(text, str):
                            text = str(text)
                        escape_chars = [
                            "_", "*", "[", "]", "(", ")", "~", "`", ">", "#", "+", "-", "=", "|", "{", "}", ".", "!"
                        ]
                        for char in escape_chars:
                            text = text.replace(char, "\\" + char)
                        return text

                    def progress_callback(d):
                        # å¼ºåˆ¶æ—¥å¿—ï¼Œç¡®ä¿èƒ½çœ‹åˆ°è¿›åº¦å›è°ƒè¢«è°ƒç”¨
                        logger.info(f"ğŸ” [SINGLE_PLAYLIST_PROGRESS_CALLBACK] è¢«è°ƒç”¨: status={d.get('status')}, filename={d.get('filename', 'N/A')}")

                        if d.get("status") == "downloading":
                            logger.info(f"ğŸ” å•ä¸ªYouTubeæ’­æ”¾åˆ—è¡¨è¿›åº¦å›è°ƒ: status={d.get('status')}, filename={d.get('filename', 'N/A')}")
                            # ä¿®æ­£å½“å‰è§†é¢‘åºå·ä¸ºæœ¬æ’­æ”¾åˆ—è¡¨çš„å½“å‰ä¸‹è½½è§†é¢‘åºå·/æ€»æ•°
                            cur_idx = (
                                d.get("playlist_index")
                                or d.get("info_dict", {}).get("playlist_index")
                                or 1
                            )
                            total_idx = (
                                d.get("playlist_count")
                                or d.get("info_dict", {}).get("n_entries")
                                or (progress_data.get("total_videos") if progress_data and isinstance(progress_data, dict) else 0)
                                or 1
                            )
                            if progress_data and isinstance(progress_data, dict):
                                progress_text = (
                                    f"ğŸ“¥ æ­£åœ¨ä¸‹è½½ç¬¬{escape_num(progress_data['playlist_index'])}/{escape_num(progress_data['total_playlists'])}ä¸ªæ’­æ”¾åˆ—è¡¨ï¼š{escape_num(progress_data['playlist_title'])}\n\n"
                                    f"ğŸ“º å½“å‰è§†é¢‘: {escape_num(cur_idx)}/{escape_num(total_idx)}\n"
                                )
                            else:
                                progress_text = f"ğŸ“º å½“å‰è§†é¢‘: {escape_num(cur_idx)}/{escape_num(total_idx)}\n"
                            percent = 0
                            if d.get("filename"):
                                filename = os.path.basename(d.get("filename", ""))
                                total_bytes = d.get("total_bytes") or d.get(
                                    "total_bytes_estimate", 0
                                )
                                downloaded_bytes = d.get("downloaded_bytes", 0)
                                speed_bytes_s = d.get("speed", 0)
                                eta_seconds = d.get("eta", 0)
                                if total_bytes and total_bytes > 0:
                                    downloaded_mb = downloaded_bytes / (1024 * 1024)
                                    total_mb = total_bytes / (1024 * 1024)
                                    speed_mb_s = (
                                        speed_bytes_s / (1024 * 1024)
                                        if speed_bytes_s
                                        else 0
                                    )
                                    percent = int(downloaded_bytes * 100 / total_bytes)
                                    bar = self._make_progress_bar(percent)
                                    try:
                                        minutes, seconds = divmod(int(eta_seconds), 60)
                                        eta_str = f"{minutes:02d}:{seconds:02d}"
                                    except (ValueError, TypeError):
                                        eta_str = "æœªçŸ¥"
                                    downloaded_mb_str = f"{downloaded_mb:.2f}"
                                    total_mb_str = f"{total_mb:.2f}"
                                    speed_mb_s_str = f"{speed_mb_s:.2f}"
                                    percent_str = f"{percent:.1f}"
                                    progress_text += (
                                        f"ğŸ“ æ–‡ä»¶: {escape_num(filename)}\n"
                                        f"ğŸ’¾ å¤§å°: {escape_num(downloaded_mb_str)}MB / {escape_num(total_mb_str)}MB\n"
                                        f"âš¡ é€Ÿåº¦: {escape_num(speed_mb_s_str)}MB/s\n"
                                        f"â³ é¢„è®¡å‰©ä½™: {escape_num(eta_str)}\n"
                                        f"ğŸ“Š è¿›åº¦: {bar} {escape_num(percent_str)}%"
                                    )
                                else:
                                    downloaded_mb = (
                                        downloaded_bytes / (1024 * 1024)
                                        if downloaded_bytes > 0
                                        else 0
                                    )
                                    speed_mb_s = (
                                        speed_bytes_s / (1024 * 1024)
                                        if speed_bytes_s
                                        else 0
                                    )
                                    downloaded_mb_str = f"{downloaded_mb:.2f}"
                                    speed_mb_s_str = f"{speed_mb_s:.2f}"
                                    progress_text += (
                                        f"ğŸ“ æ–‡ä»¶: {escape_num(filename)}\n"
                                        f"ğŸ’¾ å¤§å°: {escape_num(downloaded_mb_str)}MB\n"
                                        f"âš¡ é€Ÿåº¦: {escape_num(speed_mb_s_str)}MB/s\n"
                                        f"ğŸ“Š è¿›åº¦: ä¸‹è½½ä¸­..."
                                    )
                            now = _time.time()
                            # å‚è€ƒrenlixing.pyï¼šæ¯5%è¿›åº¦å˜åŒ–æˆ–æ¯1ç§’æ›´æ–°ä¸€æ¬¡
                            if (abs(percent - last_update["percent"]) >= 5) or (now - last_update["time"] > 1):
                                if progress_text != last_update["text"]:
                                    # æ›´æ–°è¿›åº¦æ¶ˆæ¯
                                    logger.info(f"ğŸ”„ å•ä¸ªæ’­æ”¾åˆ—è¡¨æ›´æ–°è¿›åº¦æ¶ˆæ¯: percent={percent}%")
                                last_update["percent"] = percent
                                last_update["time"] = now
                                last_update["text"] = progress_text
                                import asyncio

                                # å‚è€ƒrenlixing.pyï¼šç®€åŒ–çš„æ¶ˆæ¯æ›´æ–°é€»è¾‘
                                if captured_message_updater:
                                    try:
                                        # ç›´æ¥è°ƒç”¨ message_updater
                                        if asyncio.iscoroutinefunction(captured_message_updater):
                                            # å¼‚æ­¥å‡½æ•°ï¼Œéœ€è¦åœ¨äº‹ä»¶å¾ªç¯ä¸­è¿è¡Œ
                                            if captured_loop:
                                                future = asyncio.run_coroutine_threadsafe(
                                                    captured_message_updater(progress_text), captured_loop
                                                )
                                                future.result(timeout=3.0)
                                            else:
                                                logger.warning(f"âš ï¸ æ²¡æœ‰äº‹ä»¶å¾ªç¯ï¼Œæ— æ³•è°ƒç”¨å¼‚æ­¥å‡½æ•°")
                                        else:
                                            # åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                                            captured_message_updater(progress_text)
                                    except Exception as e:
                                        # ç®€åŒ–é”™è¯¯å¤„ç†
                                        if "Message is not modified" not in str(e):
                                            logger.warning(f"âŒ è¿›åº¦æ›´æ–°å¤±è´¥: {e}")
                                        # è®°å½•è¿›åº¦åˆ°æ—¥å¿—ï¼ˆé™çº§å¤„ç†ï¼‰
                                        logger.debug(f"ğŸ“Š è¿›åº¦æ›´æ–°: {progress_text}")

                    return progress_callback

                progress_callback = create_single_playlist_progress_callback(playlist_progress_data)
                logger.info(f"ğŸ”§ ä¸ºå•ä¸ªæ’­æ”¾åˆ—è¡¨åˆ›å»ºè¿›åº¦å›è°ƒå‡½æ•°: {type(progress_callback)}")
            else:
                progress_callback = None
                logger.info(f"âš ï¸ æ²¡æœ‰message_updaterï¼Œè·³è¿‡è¿›åº¦å›è°ƒåˆ›å»º")

            return await self._download_youtube_playlist_with_progress(
                playlist_id, download_path, progress_callback, original_url=url
            )
        else:
            logger.info(f"âŒ ä¸æ˜¯YouTubeæ’­æ”¾åˆ—è¡¨ï¼Œç»§ç»­å…¶ä»–å¤„ç†é€»è¾‘")
        # å¦‚æœæ˜¯Bç«™é“¾æ¥ï¼Œæ ¹æ®è®¾ç½®é€‰æ‹©ä¸‹è½½å™¨
        if self.is_bilibili_url(url):
            logger.info(f"ğŸ” Bç«™é“¾æ¥æ£€æµ‹ç»“æœ: is_user_lists={is_user_lists}, user_uid={user_uid}")
            logger.info(f"ğŸ” Bç«™é“¾æ¥æ£€æµ‹ç»“æœ: is_ugc_season={is_ugc_season}, ugc_bv_id={ugc_bv_id}, season_id={season_id}")
            logger.info(f"ğŸ” Bç«™é“¾æ¥æ£€æµ‹ç»“æœ: is_multi_part={is_multi_part}, bv_id={bv_id if 'bv_id' in locals() else 'N/A'}")

            # ä¼˜å…ˆå¤„ç†UPä¸»åˆé›†åˆ—è¡¨é¡µé¢
            if is_user_lists:
                logger.info("âœ… æ£€æµ‹åˆ°Bç«™UPä¸»åˆé›†åˆ—è¡¨é¡µé¢ï¼Œå¼€å§‹ä¸‹è½½æ‰€æœ‰è§†é¢‘")
                logger.info(f"ğŸ¯ è°ƒç”¨ _download_bilibili_user_all_videos(uid={user_uid})")
                result = await self._download_bilibili_user_all_videos(user_uid, download_path, message_updater)
                logger.info(f"ğŸ¯ UPä¸»ä¸‹è½½ç»“æœ: {result.get('success', False)}")
                return result

            # ä¼˜å…ˆå¤„ç†UGCåˆé›†
            if is_ugc_season:
                # æ£€æŸ¥UGCæ’­æ”¾åˆ—è¡¨é…ç½®
                ugc_playlist_enabled = getattr(self.bot, 'bilibili_ugc_playlist', True) if hasattr(self, 'bot') else True
                if ugc_playlist_enabled:
                    logger.info("âœ… æ£€æµ‹åˆ°Bç«™UGCåˆé›†ï¼Œä¸”UGCæ’­æ”¾åˆ—è¡¨å¼€å¯ï¼Œä¸‹è½½æ•´ä¸ªåˆé›†")
                    return await self._download_bilibili_ugc_season(ugc_bv_id, season_id, download_path, message_updater)
                else:
                    logger.info("âœ… æ£€æµ‹åˆ°Bç«™UGCåˆé›†ï¼Œä½†UGCæ’­æ”¾åˆ—è¡¨å…³é—­ï¼Œåªä¸‹è½½å½“å‰å•é›†")
                    return await self._download_single_video(url, download_path, message_updater, status_message=status_message, context=context)

            # ä¼˜å…ˆæ£€æŸ¥ï¼šå¦‚æœæ˜ç¡®æ£€æµ‹åˆ°æ˜¯å•é›†è§†é¢‘ï¼Œç›´æ¥ä½¿ç”¨é€šç”¨ä¸‹è½½å™¨
            elif not is_multi_part and not is_list:
                logger.info("âœ… æ£€æµ‹åˆ°Bç«™å•é›†è§†é¢‘ï¼Œç›´æ¥ä½¿ç”¨é€šç”¨ä¸‹è½½å™¨")
                return await self._download_single_video(url, download_path, message_updater, status_message=status_message, context=context)

            # å¦‚æœæ£€æµ‹åˆ°å¤šPæˆ–åˆé›†ï¼Œä¸”å¼€å¯äº†è‡ªåŠ¨ä¸‹è½½å…¨é›†ï¼Œä½¿ç”¨ä¸“é—¨çš„Bç«™ä¸‹è½½å™¨
            elif auto_playlist and (is_multi_part or is_list):
                logger.info("âœ… æ£€æµ‹åˆ°Bç«™å¤šPè§†é¢‘æˆ–åˆé›†ï¼Œä¸”å¼€å¯å¤šPè‡ªåŠ¨ä¸‹è½½å…¨é›†ï¼Œä½¿ç”¨ä¸“é—¨çš„Bç«™ä¸‹è½½å™¨")
                return await self._download_bilibili_video(
                    url, download_path, message_updater, auto_playlist, status_message, context
                )

            # å…¶ä»–æƒ…å†µï¼ˆæ£€æµ‹åˆ°å¤šPä½†æœªå¼€å¯å¤šPè‡ªåŠ¨ä¸‹è½½å…¨é›†ï¼‰ä½¿ç”¨é€šç”¨ä¸‹è½½å™¨
            else:
                logger.info("âœ… æ£€æµ‹åˆ°Bç«™å¤šPè§†é¢‘æˆ–åˆé›†ï¼Œä½†æœªå¼€å¯å¤šPè‡ªåŠ¨ä¸‹è½½å…¨é›†ï¼Œä½¿ç”¨é€šç”¨ä¸‹è½½å™¨ä¸‹è½½å½“å‰é›†")
                return await self._download_single_video(url, download_path, message_updater, status_message=status_message, context=context)
        # å¤„ç†æ–°å¢çš„å¹³å°ï¼ˆå¾®åšã€Instagramã€TikTokï¼‰
        if self.is_weibo_url(url) or self.is_instagram_url(url) or self.is_tiktok_url(url):
            logger.info(f"âœ… æ£€æµ‹åˆ°{platform}è§†é¢‘ï¼Œä½¿ç”¨é€šç”¨ä¸‹è½½å™¨")
            return await self._download_single_video(url, download_path, message_updater, status_message=status_message, context=context)

        # æ£€æŸ¥æ˜¯å¦ä¸ºBç«™UPä¸»ç©ºé—´URLï¼Œå¦‚æœæ˜¯åˆ™ä¸åº”è¯¥fallbackåˆ°å•ä¸ªè§†é¢‘ä¸‹è½½
        if self.is_bilibili_url(url) and "space.bilibili.com" in url:
            logger.error(f"âŒ Bç«™UPä¸»ç©ºé—´URLä¸åº”è¯¥fallbackåˆ°å•ä¸ªè§†é¢‘ä¸‹è½½: {url}")
            return {'success': False, 'error': 'Bç«™UPä¸»ç©ºé—´URLå¤„ç†å¤±è´¥ï¼Œè¯·æ£€æŸ¥URLæ ¼å¼æˆ–é‡è¯•'}

        # æ£€æŸ¥æ˜¯å¦ä¸ºç½‘æ˜“äº‘éŸ³ä¹é“¾æ¥ï¼Œå¦‚æœæ˜¯åˆ™ä¸åº”è¯¥fallbackåˆ°å•ä¸ªè§†é¢‘ä¸‹è½½
        if self.is_netease_url(url):
            logger.error(f"âŒ ç½‘æ˜“äº‘éŸ³ä¹é“¾æ¥ä¸åº”è¯¥fallbackåˆ°å•ä¸ªè§†é¢‘ä¸‹è½½: {url}")
            return {'success': False, 'error': 'ç½‘æ˜“äº‘éŸ³ä¹é“¾æ¥å¤„ç†å¤±è´¥ï¼Œè¯·æ£€æŸ¥URLæ ¼å¼æˆ–é‡è¯•'}

        # æ£€æŸ¥æ˜¯å¦ä¸ºQQéŸ³ä¹é“¾æ¥ï¼Œå¦‚æœæ˜¯åˆ™ä¸åº”è¯¥fallbackåˆ°å•ä¸ªè§†é¢‘ä¸‹è½½
        if self.is_qqmusic_url(url):
            logger.error(f"âŒ QQéŸ³ä¹é“¾æ¥ä¸åº”è¯¥fallbackåˆ°å•ä¸ªè§†é¢‘ä¸‹è½½: {url}")
            return {'success': False, 'error': 'QQéŸ³ä¹é“¾æ¥å¤„ç†å¤±è´¥ï¼Œè¯·æ£€æŸ¥URLæ ¼å¼æˆ–é‡è¯•'}

        # å¤„ç†å•ä¸ªè§†é¢‘ï¼ˆåŒ…æ‹¬YouTubeå•ä¸ªè§†é¢‘ï¼‰
        logger.info(f"âœ… ä½¿ç”¨é€šç”¨ä¸‹è½½å™¨å¤„ç†å•ä¸ªè§†é¢‘ï¼Œå¹³å°: {platform}")
        logger.info(f"ğŸ” æœ€ç»ˆfallback: URL={url}")
        return await self._download_single_video(url, download_path, message_updater, no_playlist=is_mix_playlist_disabled, status_message=status_message, context=context)

    async def _download_bilibili_video(
        self, url: str, download_path: str, message_updater=None, auto_playlist=False, status_message=None, context=None
    ) -> Dict[str, Any]:
        """ä¸‹è½½Bç«™å¤šPè§†é¢‘æˆ–åˆé›†"""
        import os
        from pathlib import Path
        import time
        import re
        logger.info(f"ğŸ¬ å¼€å§‹ä¸‹è½½Bç«™å¤šPè§†é¢‘æˆ–åˆé›†: {url}")

        # æ£€æŸ¥æ˜¯å¦ä¸ºBç«™ç”¨æˆ·è‡ªå®šä¹‰åˆ—è¡¨URL
        is_list, uid, list_id = self.is_bilibili_list_url(url)
        is_multi_part, bv_id = self.is_bilibili_multi_part_video(url)

        # è®°å½•ä¸‹è½½å¼€å§‹æ—¶é—´
        download_start_time = time.time()
        logger.info(f"â° ä¸‹è½½å¼€å§‹æ—¶é—´: {download_start_time}")

        logger.info(f"ğŸ” æ£€æµ‹ç»“æœ: åˆ—è¡¨={is_list}, å¤šP={is_multi_part}, BVå·={bv_id}")

        # ç®€åŒ–ï¼šä¸éœ€è¦è·Ÿè¸ªä¸‹è½½æ–‡ä»¶ï¼Œä½¿ç”¨ç›®å½•éå†

        # ç®€åŒ–æ–¹æ¡ˆï¼šç›´æ¥åˆ é™¤ç›®å½•éå†ï¼Œä½¿ç”¨ç°æœ‰çš„è¿›åº¦å›è°ƒæœºåˆ¶

        # é¢„å…ˆè·å–æ’­æ”¾åˆ—è¡¨ä¿¡æ¯ï¼Œä»¥ä¾¿çŸ¥é“åº”è¯¥æœ‰å“ªäº›æ–‡ä»¶
        # ç®€åŒ–ï¼šä¸éœ€è¦é¢„å…ˆè·å–æ’­æ”¾åˆ—è¡¨ä¿¡æ¯ï¼Œç›´æ¥ä¸‹è½½åç”¨ç›®å½•éå†

        # ä½¿ç”¨single_video_progress_hookæ¥è·å¾—å®Œæ•´çš„è¿›åº¦æ˜¾ç¤ºåŠŸèƒ½
        import threading
        progress_data = {"final_filename": None, "lock": threading.Lock()}
        progress_callback = single_video_progress_hook(
            message_updater=message_updater,
            progress_data=progress_data,
            status_message=status_message,
            context=context
        )

        try:
            loop = asyncio.get_running_loop()
            result = await loop.run_in_executor(
                None,
                self.smart_download_bilibili,
                url,
                str(download_path),
                progress_callback,
                auto_playlist,
            )

            # æ£€æŸ¥æ˜¯å¦ä¸ºå•è§†é¢‘ï¼Œå¦‚æœæ˜¯åˆ™å›é€€åˆ°é€šç”¨ä¸‹è½½å™¨
            if isinstance(result, dict) and result.get("status") == "single_video":
                logger.info("ğŸ”„ smart_download_bilibili æ£€æµ‹åˆ°å•è§†é¢‘ï¼Œå›é€€åˆ°é€šç”¨ä¸‹è½½å™¨")
                return await self._download_single_video(url, download_path, message_updater, status_message=status_message, context=context)

            if not result:
                return {'success': False, 'error': 'Bç«™ä¸‹è½½å¤±è´¥'}

            # æ£€æŸ¥æ˜¯å¦ä¸ºåŒ…å«å®Œæ•´æ–‡ä»¶ä¿¡æ¯çš„ç»“æœï¼ˆBVå·å¾ªç¯æ³•ï¼‰
            if isinstance(result, dict) and result.get("status") == "success" and "files" in result:
                logger.info("âœ… smart_download_bilibili è¿”å›äº†å®Œæ•´çš„æ–‡ä»¶ä¿¡æ¯ï¼Œç›´æ¥ä½¿ç”¨")
                return {
                    'success': True,
                    'is_playlist': result.get('is_playlist', True),
                    'file_count': result.get('file_count', 0),
                    'total_size_mb': result.get('total_size_mb', 0),
                    'files': result.get('files', []),
                    'platform': result.get('platform', 'bilibili'),
                    'download_path': result.get('download_path', str(download_path)),
                    'filename': result.get('filename', ''),
                    'size_mb': result.get('size_mb', 0),
                    'resolution': result.get('resolution', 'æœªçŸ¥'),
                    'episode_count': result.get('episode_count', 0),
                    'video_type': result.get('video_type', 'playlist')
                }

            await asyncio.sleep(1)

            # ç®€åŒ–ï¼šç›´æ¥ä½¿ç”¨ç›®å½•éå†æŸ¥æ‰¾æ–‡ä»¶
            video_files = []

            # ç®€åŒ–ï¼šç›´æ¥è·³åˆ°ç›®å½•éå†ï¼Œåˆ é™¤æ‰€æœ‰å¤æ‚çš„æ–‡ä»¶è®°å½•é€»è¾‘
            if False:  # ç¦ç”¨å¤æ‚é€»è¾‘
                downloaded_files = []  # å®šä¹‰å˜é‡ä»¥é¿å…æœªå®šä¹‰é”™è¯¯
                logger.info(f"ğŸ“‹ æ‰¾åˆ° {len(downloaded_files)} ä¸ªå®é™…ä¸‹è½½æ–‡ä»¶è®°å½•")
                for filename in downloaded_files:
                    file_path = Path(filename)
                    if file_path.exists():
                        try:
                            mtime = os.path.getmtime(file_path)
                            video_files.append((file_path, mtime))
                            logger.info(f"âœ… æ‰¾åˆ°æœ¬æ¬¡ä¸‹è½½æ–‡ä»¶: {file_path.name}")
                        except OSError:
                            continue
                    else:
                        logger.warning(f"âš ï¸ è®°å½•çš„æ–‡ä»¶ä¸å­˜åœ¨: {filename}")
            elif False:  # ç¦ç”¨å¤æ‚é€»è¾‘
                # æ£€æŸ¥æ˜¯å¦ä¸ºBç«™åˆé›†ä¸‹è½½ï¼ˆæœ‰fileså­—æ®µï¼‰
                if progress_data and isinstance(progress_data, dict) and progress_data.get("files"):
                    # Bç«™åˆé›†ä¸‹è½½ï¼šç›´æ¥ä½¿ç”¨é¢„æœŸæ–‡ä»¶åæŸ¥æ‰¾
                    logger.info("ğŸ” Bç«™åˆé›†ä¸‹è½½ï¼šä½¿ç”¨é¢„æœŸæ–‡ä»¶åç›´æ¥æŸ¥æ‰¾")
                    logger.info(f"ğŸ“‹ é¢„æœŸæ–‡ä»¶æ•°é‡: {len(progress_data['files'])}")
                    logger.info(f"ğŸ“ æœç´¢ç›®å½•: {download_path}")

                    for file_info in progress_data["files"]:
                        expected_filename = file_info['filename']
                        expected_path = download_path / expected_filename

                        if expected_path.exists():
                            try:
                                mtime = os.path.getmtime(expected_path)
                                video_files.append((expected_path, mtime))
                                logger.info(f"âœ… æ‰¾åˆ°é¢„æœŸæ–‡ä»¶: {expected_filename}")
                            except OSError:
                                logger.warning(f"âš ï¸ æ— æ³•è·å–æ–‡ä»¶æ—¶é—´: {expected_filename}")
                        else:
                            logger.warning(f"âš ï¸ é¢„æœŸæ–‡ä»¶ä¸å­˜åœ¨: {expected_filename}")
                else:
                    # å…¶ä»–ç±»å‹ä¸‹è½½ï¼šç›´æ¥ä½¿ç”¨progress_dataä¸­çš„é¢„æœŸæ–‡ä»¶åˆ—è¡¨
                    expected_files_list = progress_data.get('expected_files', []) if progress_data and isinstance(progress_data, dict) else []
                    logger.info("ğŸ” ä½¿ç”¨progress_dataä¸­çš„é¢„æœŸæ–‡ä»¶åˆ—è¡¨")

                    logger.info(f"ğŸ“‹ é¢„æœŸæ–‡ä»¶æ•°é‡: {len(expected_files_list)}")
                    logger.info(f"ğŸ“ æœç´¢ç›®å½•: {download_path}")

                    def clean_filename_for_matching(filename):
                        """æ¸…ç†æ–‡ä»¶åç”¨äºåŒ¹é…ï¼Œåˆ é™¤yt-dlpæ ¼å¼ä»£ç å’ŒIDæ ‡è¯†ï¼Œä¿ç•™ç‰ˆæœ¬å·ç­‰é‡è¦ä¿¡æ¯"""
                        import re
                        if not filename:
                            return ""

                        # åˆ é™¤yt-dlpçš„å„ç§æ ¼å¼ä»£ç 
                        # 1. åˆ é™¤ .f137+140 æ ¼å¼ï¼ˆåœ¨æ‰©å±•åå‰ï¼‰
                        cleaned = re.sub(r'\.[fm]\d+(\+\d+)*', '', filename)

                        # 2. åˆ é™¤ .f100026 æ ¼å¼ï¼ˆåµŒå…¥åœ¨æ–‡ä»¶åä¸­é—´ï¼‰
                        cleaned = re.sub(r'\.f\d+', '', cleaned)

                        # 3. åˆ é™¤YouTubeè§†é¢‘IDæ ‡è¯† [video_id]ï¼ˆä»…åœ¨å¯ç”¨IDæ ‡ç­¾æ—¶ï¼‰
                        # åªæœ‰å¯ç”¨äº†IDæ ‡ç­¾åŠŸèƒ½æ—¶æ‰æ¸…ç†ID
                        if hasattr(self, 'bot') and hasattr(self.bot, 'youtube_id_tags') and self.bot.youtube_id_tags:
                            cleaned = re.sub(r'\[[a-zA-Z0-9_-]{10,12}\]', '', cleaned)

                        # 4. åˆ é™¤ .m4a, .webm ç­‰ä¸´æ—¶æ ¼å¼ï¼Œæ›¿æ¢ä¸º .mp4
                        cleaned = re.sub(r'\.(webm|m4a|mp3)$', '.mp4', cleaned)

                        # ä¿®å¤å¯èƒ½çš„åŒæ‰©å±•åé—®é¢˜ï¼ˆå¦‚ .m4a.mp4 -> .mp4ï¼‰
                        cleaned = re.sub(r'\.(webm|m4a|mp3)\.mp4$', '.mp4', cleaned)

                        # 5. åˆ é™¤åºå·å‰ç¼€ï¼ˆå¦‚ "23. "ï¼‰ï¼Œå› ä¸ºé¢„æœŸæ–‡ä»¶åæ²¡æœ‰åºå·
                        cleaned = re.sub(r'^\d+\.\s*', '', cleaned)

                        # 6. å¯¹Bç«™å¤šPæ ‡é¢˜è¿›è¡Œæ™ºèƒ½å¤„ç†ï¼ˆå’Œé¢„æœŸæ–‡ä»¶åä¿æŒä¸€è‡´ï¼‰
                        # æŸ¥æ‰¾ pxx æ¨¡å¼ï¼Œå¦‚æœæ‰¾åˆ°å°±ä» pxx å¼€å§‹æˆªå–
                        pattern = r'\s+[pP](\d{1,3})\s+'
                        match = re.search(pattern, cleaned)
                        if match:
                            start_pos = match.start() + 1  # +1 æ˜¯ä¸ºäº†è·³è¿‡å‰é¢çš„ç©ºæ ¼
                            cleaned = cleaned[start_pos:]

                        # 7. ç»Ÿä¸€ç‰¹æ®Šå­—ç¬¦ï¼ˆè§£å†³å…¨è§’/åŠè§’å·®å¼‚ï¼‰
                        # å°†åŠè§’ç«–çº¿è½¬æ¢ä¸ºå…¨è§’ç«–çº¿ï¼Œä¸_basic_sanitize_filenameä¿æŒä¸€è‡´
                        cleaned = cleaned.replace('|', 'ï½œ')
                        # å°†æ™®é€šæ–œæ è½¬æ¢ä¸ºå¤§æ–œæ ç¬¦å·ï¼Œä¸_basic_sanitize_filenameä¿æŒä¸€è‡´
                        cleaned = cleaned.replace('/', 'â§¸')
                        # ä¿ç•™å…¨è§’å­—ç¬¦ï¼Œä¸è¿›è¡Œé¢å¤–è½¬æ¢
                        # cleaned = re.sub(r'[ã€ã€‘]', '_', cleaned)  # æ³¨é‡Šæ‰ï¼Œä¿ç•™åŸå§‹å­—ç¬¦

                        # ç¡®ä¿ä»¥ .mp4 ç»“å°¾
                        if not cleaned.endswith('.mp4'):
                            cleaned = cleaned.rstrip('.') + '.mp4'

                        return cleaned

                    for expected_file in expected_files_list:
                        # å°è¯•å¤šç§å¯èƒ½çš„æ–‡ä»¶åæ ¼å¼
                        base_title = expected_file.get('title', '')
                        base_filename = expected_file.get('filename', '')

                        possible_names = [
                            base_filename,  # åŸå§‹æ–‡ä»¶å
                            base_title,     # åŸå§‹æ ‡é¢˜
                            f"{base_title}.mp4",  # æ ‡é¢˜+.mp4
                            clean_filename_for_matching(base_filename),  # æ¸…ç†åçš„æ–‡ä»¶å
                            clean_filename_for_matching(base_title),     # æ¸…ç†åçš„æ ‡é¢˜
                        ]

                        # å»é‡å¹¶è¿‡æ»¤ç©ºå€¼
                        possible_names = list(dict.fromkeys([name for name in possible_names if name]))

                        found = False
                        for possible_name in possible_names:
                            # 1. å…ˆåœ¨ä¸‹è½½ç›®å½•ç›´æ¥æŸ¥æ‰¾
                            expected_path = download_path / possible_name
                            if expected_path.exists():
                                try:
                                    mtime = os.path.getmtime(expected_path)
                                    video_files.append((expected_path, mtime))
                                    logger.info(f"âœ… æ‰¾åˆ°é¢„æœŸæ–‡ä»¶: {possible_name}")
                                    found = True
                                    break
                                except OSError:
                                    continue

                            # 2. åœ¨å­ç›®å½•ä¸­æŸ¥æ‰¾ï¼ˆé€’å½’æœç´¢ï¼‰
                            for video_ext in ["*.mp4", "*.mkv", "*.webm", "*.avi", "*.mov", "*.flv"]:
                                matching_files = list(Path(download_path).rglob(video_ext))
                                for file_path in matching_files:
                                    # æ£€æŸ¥æ–‡ä»¶åæ˜¯å¦åŒ¹é…ï¼ˆè€ƒè™‘åºå·å‰ç¼€ï¼‰
                                    actual_filename = file_path.name
                                    cleaned_actual = clean_filename_for_matching(actual_filename)
                                    cleaned_expected = clean_filename_for_matching(possible_name)

                                    if cleaned_actual == cleaned_expected:
                                        try:
                                            mtime = os.path.getmtime(file_path)
                                            video_files.append((file_path, mtime))
                                            logger.info(f"âœ… åœ¨å­ç›®å½•æ‰¾åˆ°æ–‡ä»¶: {file_path.relative_to(download_path)}")
                                            found = True
                                            break
                                        except OSError:
                                            continue
                                if found:
                                    break
                            if found:
                                break

                        if not found:
                            logger.warning(f"âš ï¸ æœªæ‰¾åˆ°é¢„æœŸæ–‡ä»¶: {expected_file.get('title', 'unknown')}")
                            logger.info(f"   å°è¯•çš„æ–‡ä»¶å: {possible_names}")
            else:
                # Bç«™å¤šPä¸‹è½½ï¼šæ™ºèƒ½æŸ¥æ‰¾å­ç›®å½•ä¸­çš„æ–‡ä»¶
                logger.info("ğŸ¯ Bç«™å¤šPä¸‹è½½ï¼šæ²¡æœ‰é¢„æœŸæ–‡ä»¶åˆ—è¡¨ï¼Œæ™ºèƒ½æŸ¥æ‰¾å­ç›®å½•ä¸­çš„æ–‡ä»¶")
                logger.info(f"ğŸ” æœç´¢è·¯å¾„: {download_path}")

                # æ£€æŸ¥ä¸‹è½½è·¯å¾„æ˜¯å¦å­˜åœ¨
                if not Path(download_path).exists():
                    logger.error(f"âŒ ä¸‹è½½è·¯å¾„ä¸å­˜åœ¨: {download_path}")
                    return {"success": False, "error": "ä¸‹è½½è·¯å¾„ä¸å­˜åœ¨"}

                # æ™ºèƒ½æŸ¥æ‰¾ï¼šä¼˜å…ˆæŸ¥æ‰¾æœ€æ–°åˆ›å»ºçš„å­ç›®å½•
                try:
                    all_items = list(Path(download_path).iterdir())
                    subdirs = [item for item in all_items if item.is_dir()]

                    if subdirs:
                        # æŒ‰ä¿®æ”¹æ—¶é—´æ’åºï¼Œæ‰¾åˆ°æœ€æ–°çš„å­ç›®å½•
                        latest_subdir = max(subdirs, key=lambda x: x.stat().st_mtime)
                        logger.info(f"ğŸ“ æ‰¾åˆ°æœ€æ–°å­ç›®å½•: {latest_subdir.name}")

                        # åœ¨å­ç›®å½•ä¸­æŸ¥æ‰¾è§†é¢‘æ–‡ä»¶
                        video_extensions = ["*.mp4", "*.mkv", "*.webm", "*.avi", "*.mov", "*.flv"]
                        for ext in video_extensions:
                            matching_files = list(latest_subdir.glob(ext))
                            if matching_files:
                                logger.info(f"âœ… åœ¨å­ç›®å½•ä¸­æ‰¾åˆ° {len(matching_files)} ä¸ª {ext} æ–‡ä»¶")
                                for file_path in matching_files:
                                    try:
                                        mtime = os.path.getmtime(file_path)
                                        video_files.append((file_path, mtime))
                                        logger.info(f"âœ… æ‰¾åˆ°æ–‡ä»¶: {file_path.name}")
                                    except OSError:
                                        continue
                    else:
                        logger.warning("âš ï¸ æœªæ‰¾åˆ°å­ç›®å½•ï¼Œåœ¨æ ¹ç›®å½•æŸ¥æ‰¾")
                        # å¦‚æœæ²¡æœ‰å­ç›®å½•ï¼Œåœ¨æ ¹ç›®å½•æŸ¥æ‰¾
                        video_extensions = ["*.mp4", "*.mkv", "*.webm", "*.avi", "*.mov", "*.flv"]
                        for ext in video_extensions:
                            matching_files = list(Path(download_path).glob(ext))
                            for file_path in matching_files:
                                try:
                                    mtime = os.path.getmtime(file_path)
                                    video_files.append((file_path, mtime))
                                    logger.info(f"âœ… æ‰¾åˆ°æ–‡ä»¶: {file_path.name}")
                                except OSError:
                                    continue

                except Exception as e:
                    logger.error(f"âŒ æ™ºèƒ½æŸ¥æ‰¾å¤±è´¥: {e}")
                    return {"success": False, "error": f"æ–‡ä»¶æŸ¥æ‰¾å¤±è´¥: {e}"}

            # å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ–‡ä»¶ï¼Œè®°å½•è¯¦ç»†ä¿¡æ¯ç”¨äºè°ƒè¯•
            if not video_files:
                logger.warning("âš ï¸ æœªæ‰¾åˆ°ä»»ä½•åŒ¹é…æ–‡ä»¶")
                logger.info(f"ğŸ” æœç´¢è·¯å¾„: {download_path}")
                return {"success": False, "error": "ç›®å½•éå†æœªæ‰¾åˆ°è§†é¢‘æ–‡ä»¶"}

            video_files.sort(key=lambda x: x[0].name)

            # æ£€æµ‹PARTæ–‡ä»¶
            part_files = self._detect_part_files(download_path)
            success_count = len(video_files)
            part_count = len(part_files)

            # åœ¨æ—¥å¿—ä¸­æ˜¾ç¤ºè¯¦ç»†ç»Ÿè®¡
            logger.info(f"ğŸ“Š ä¸‹è½½å®Œæˆç»Ÿè®¡ï¼š")
            logger.info(f"âœ… æˆåŠŸæ–‡ä»¶ï¼š{success_count} ä¸ª")
            if part_count > 0:
                logger.warning(f"âš ï¸ æœªå®Œæˆæ–‡ä»¶ï¼š{part_count} ä¸ª")
                self._log_part_files_details(part_files)
            else:
                logger.info("âœ… æœªå‘ç°PARTæ–‡ä»¶ï¼Œæ‰€æœ‰ä¸‹è½½éƒ½å·²å®Œæˆ")

            if is_list:
                logger.info(f"ğŸ‰ Bç«™åˆé›†ä¸‹è½½å®Œæˆï¼Œç»Ÿè®¡æœ¬æ¬¡ä¸‹è½½æ–‡ä»¶")
                if video_files:
                    total_size_mb = 0
                    file_info_list = []
                    all_resolutions = set()
                    for file_path, mtime in video_files:
                        size_mb = os.path.getsize(file_path) / (1024 * 1024)
                        total_size_mb += size_mb
                        media_info = self.get_media_info(str(file_path))
                        resolution = media_info.get('resolution', 'æœªçŸ¥')
                        if resolution != 'æœªçŸ¥':
                            all_resolutions.add(resolution)
                        file_info_list.append({
                            'filename': os.path.basename(file_path),
                            'size_mb': size_mb,
                            'resolution': resolution,
                            'abr': media_info.get('bit_rate')
                        })
                    filename_list = [info['filename'] for info in file_info_list]
                    filename_display = '\n'.join([f"  {i+1:02d}. {name}" for i, name in enumerate(filename_list)])
                    resolution_display = ', '.join(sorted(all_resolutions)) if all_resolutions else 'æœªçŸ¥'
                    return {
                        'success': True,
                        'is_playlist': True,
                        'file_count': len(video_files),
                        'total_size_mb': total_size_mb,
                        'files': file_info_list,
                        'platform': 'bilibili',
                        'download_path': str(download_path),
                        'filename': filename_display,
                        'size_mb': total_size_mb,
                        'resolution': resolution_display,
                        'episode_count': len(video_files),
                        # æ·»åŠ PARTæ–‡ä»¶ç»Ÿè®¡ä¿¡æ¯
                        'success_count': success_count,
                        'part_count': part_count,
                        'part_files': [str(pf) for pf in part_files] if part_files else []
                    }
                else:
                    return {'success': False, 'error': 'Bç«™åˆé›†ä¸‹è½½å®Œæˆä½†æœªæ‰¾åˆ°æœ¬æ¬¡ä¸‹è½½çš„æ–‡ä»¶'}
            else:
                # å¤šPè§†é¢‘ä¸‹è½½ï¼Œç»Ÿè®¡æœ¬æ¬¡ä¸‹è½½æ–‡ä»¶
                if video_files:
                    # å¦‚æœæœ‰å¤šä¸ªæ–‡ä»¶ï¼Œåº”è¯¥ä½¿ç”¨æ’­æ”¾åˆ—è¡¨æ ¼å¼æ˜¾ç¤º
                    if len(video_files) > 1:
                        total_size_mb = 0
                        file_info_list = []
                        all_resolutions = set()
                        for file_path, mtime in video_files:
                            size_mb = os.path.getsize(file_path) / (1024 * 1024)
                            total_size_mb += size_mb
                            media_info = self.get_media_info(str(file_path))
                            resolution = media_info.get('resolution', 'æœªçŸ¥')
                            if resolution != 'æœªçŸ¥':
                                all_resolutions.add(resolution)
                            file_info_list.append({
                                'filename': os.path.basename(file_path),
                                'size_mb': size_mb,
                                'resolution': resolution,
                                'abr': media_info.get('bit_rate')
                            })
                        filename_list = [info['filename'] for info in file_info_list]
                        filename_display = '\n'.join([f"  {i+1:02d}. {name}" for i, name in enumerate(filename_list)])
                        resolution_display = ', '.join(sorted(all_resolutions)) if all_resolutions else 'æœªçŸ¥'
                        return {
                            'success': True,
                            'is_playlist': True,
                            'video_type': 'playlist',
                            'file_count': len(video_files),
                            'total_size_mb': total_size_mb,
                            'files': file_info_list,
                            'platform': 'bilibili',
                            'download_path': str(download_path),
                            'filename': filename_display,
                            'size_mb': total_size_mb,
                            'resolution': resolution_display,
                            'episode_count': len(video_files)
                        }
                    else:
                        # åªæœ‰ä¸€ä¸ªæ–‡ä»¶ï¼Œä½¿ç”¨å•ä¸ªè§†é¢‘æ ¼å¼
                        video_files.sort(key=lambda x: x[1], reverse=True)
                        final_file_path = str(video_files[0][0])
                        media_info = self.get_media_info(final_file_path)
                        size_mb = os.path.getsize(final_file_path) / (1024 * 1024)
                        return {
                            'success': True,
                            'filename': os.path.basename(final_file_path),
                            'full_path': final_file_path,
                            'size_mb': size_mb,
                            'platform': 'bilibili',
                            'download_path': str(download_path),
                            'resolution': media_info.get('resolution', 'æœªçŸ¥'),
                            'abr': media_info.get('bit_rate')
                        }
                else:
                    return {'success': False, 'error': 'Bç«™å¤šPä¸‹è½½å®Œæˆä½†æœªæ‰¾åˆ°æœ¬æ¬¡ä¸‹è½½çš„æ–‡ä»¶'}

        except Exception as e:
            logger.error(f"Bç«™ä¸‹è½½å¤±è´¥: {e}")
            return {"success": False, "error": str(e)}

    async def _download_single_video(
        self, url: str, download_path: Path, message_updater=None, no_playlist: bool = False, status_message=None, context=None
    ) -> Dict[str, Any]:
        """ä¸‹è½½å•ä¸ªè§†é¢‘ï¼ˆåŒ…æ‹¬YouTubeå•ä¸ªè§†é¢‘ï¼‰"""
        import os
        logger.info(f"ğŸ¬ å¼€å§‹ä¸‹è½½å•ä¸ªè§†é¢‘: {url}")
        
        # æ£€æŸ¥æ˜¯å¦ä¸ºç½‘æ˜“äº‘éŸ³ä¹é“¾æ¥ï¼Œå¦‚æœæ˜¯åˆ™ä¸åº”è¯¥è°ƒç”¨æ­¤å‡½æ•°
        if self.is_netease_url(url):
            logger.error(f"âŒ ç½‘æ˜“äº‘éŸ³ä¹é“¾æ¥ä¸åº”è¯¥è°ƒç”¨_download_single_videoå‡½æ•°: {url}")
            return {
                "success": False,
                "error": "ç½‘æ˜“äº‘éŸ³ä¹é“¾æ¥ä¸åº”è¯¥è°ƒç”¨å•è§†é¢‘ä¸‹è½½å‡½æ•°",
                "platform": "Netease",
                "content_type": "music"
            }

        # æ£€æŸ¥æ˜¯å¦ä¸ºQQéŸ³ä¹é“¾æ¥ï¼Œå¦‚æœæ˜¯åˆ™ä¸åº”è¯¥è°ƒç”¨æ­¤å‡½æ•°
        if self.is_qqmusic_url(url):
            logger.error(f"âŒ QQéŸ³ä¹é“¾æ¥ä¸åº”è¯¥è°ƒç”¨_download_single_videoå‡½æ•°: {url}")
            return {
                "success": False,
                "error": "QQéŸ³ä¹é“¾æ¥ä¸åº”è¯¥è°ƒç”¨å•è§†é¢‘ä¸‹è½½å‡½æ•°",
                "platform": "QQMusic",
                "content_type": "music"
            }
        
        # æ£€æŸ¥æ˜¯å¦ä¸ºYouTube Musicé“¾æ¥ï¼Œå¦‚æœæ˜¯åˆ™ä¸åº”è¯¥è°ƒç”¨æ­¤å‡½æ•°
        if self.is_youtube_music_url(url):
            logger.error(f"âŒ YouTube Musicé“¾æ¥ä¸åº”è¯¥è°ƒç”¨_download_single_videoå‡½æ•°: {url}")
            return {
                "success": False,
                "error": "YouTube Musicé“¾æ¥ä¸åº”è¯¥è°ƒç”¨å•è§†é¢‘ä¸‹è½½å‡½æ•°",
                "platform": "YouTubeMusic",
                "content_type": "music"
            }
        # 1. é¢„å…ˆè·å–ä¿¡æ¯ä»¥ç¡®å®šæ–‡ä»¶å
        try:
            logger.info("ğŸ” æ­¥éª¤1: é¢„å…ˆè·å–è§†é¢‘ä¿¡æ¯...")
            info_opts = {
                "quiet": True,
                "no_warnings": True,
                "socket_timeout": 60,  # å¢åŠ åˆ°60ç§’è¶…æ—¶
                "retries": 5,  # å¢åŠ é‡è¯•æ¬¡æ•°
                "noplaylist": True,  # æ·»åŠ  noplaylist å‚æ•°ï¼Œç¡®ä¿åªè·å–å•ä¸ªè§†é¢‘ä¿¡æ¯
                "http_headers": {
                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
                }
            }
            if self.proxy_host:
                info_opts["proxy"] = self.proxy_host
                logger.info(f"ğŸŒ ä½¿ç”¨ä»£ç†: {self.proxy_host}")
            if (
                self.is_x_url(url)
                and self.x_cookies_path
                and os.path.exists(self.x_cookies_path)
            ):
                info_opts["cookiefile"] = self.x_cookies_path
                logger.info(f"ğŸª ä½¿ç”¨X cookies: {self.x_cookies_path}")
            if (
                self.is_youtube_url(url)
                and self.youtube_cookies_path
                and os.path.exists(self.youtube_cookies_path)
            ):
                info_opts["cookiefile"] = self.youtube_cookies_path
                logger.info(f"ğŸª ä½¿ç”¨YouTube cookies: {self.youtube_cookies_path}")
            if (
                self.is_douyin_url(url)
                and self.douyin_cookies_path
                and os.path.exists(self.douyin_cookies_path)
            ):
                info_opts["cookiefile"] = self.douyin_cookies_path
                logger.info(f"ğŸª ä½¿ç”¨æŠ–éŸ³ cookies: {self.douyin_cookies_path}")
            # Instagram cookiesæ”¯æŒï¼ˆç”¨äºé¢„å…ˆè·å–ä¿¡æ¯ï¼‰
            if "instagram.com" in url.lower():
                if (
                    hasattr(self, 'instagram_cookies_path') and
                    self.instagram_cookies_path and 
                    os.path.exists(self.instagram_cookies_path)
                ):
                    info_opts["cookiefile"] = self.instagram_cookies_path
                    logger.info(f"ğŸª é¢„å…ˆè·å–ä¿¡æ¯é˜¶æ®µä½¿ç”¨Instagram cookies: {self.instagram_cookies_path}")
                else:
                    logger.warning("âš ï¸ Instagramé¢„å…ˆè·å–ä¿¡æ¯ï¼šcookiesæœªé…ç½®ï¼Œå¯èƒ½å¯¼è‡´è·å–å¤±è´¥")
            logger.info("ğŸ” æ­¥éª¤2: å¼€å§‹æå–è§†é¢‘ä¿¡æ¯...")
            # ä½¿ç”¨å¼‚æ­¥æ‰§è¡Œå™¨æ¥æ·»åŠ è¶…æ—¶æ§åˆ¶
            loop = asyncio.get_running_loop()

            def extract_video_info():
                with yt_dlp.YoutubeDL(info_opts) as ydl:
                    logger.info("ğŸ“¡ æ­£åœ¨ä»å¹³å°è·å–è§†é¢‘æ•°æ®...")
                    return ydl.extract_info(url, download=False)

            # è®¾ç½®30ç§’è¶…æ—¶
            try:
                info = await asyncio.wait_for(
                    loop.run_in_executor(None, extract_video_info), timeout=60.0
                )
                logger.info(f"âœ… è§†é¢‘ä¿¡æ¯è·å–å®Œæˆï¼Œæ•°æ®ç±»å‹: {type(info)}")

                video_id = info.get("id")
                title = info.get("title")
                # æ¸…ç†æ ‡é¢˜ä¸­çš„éæ³•å­—ç¬¦
                if title:
                    title = self._sanitize_filename(title)
                else:
                    title = self._sanitize_filename(video_id)
                logger.info(f"ğŸ“ è§†é¢‘æ ‡é¢˜: {title}")
                logger.info(f"ğŸ†” è§†é¢‘ID: {video_id}")
            except asyncio.TimeoutError:
                logger.error("âŒ è·å–è§†é¢‘ä¿¡æ¯è¶…æ—¶ï¼ˆ60ç§’ï¼‰")
                return {
                    "success": False,
                    "error": "è·å–è§†é¢‘ä¿¡æ¯è¶…æ—¶ï¼ˆ60ç§’ï¼‰ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•ã€‚",
                }
        except Exception as e:
            logger.error(f"âŒ æ— æ³•é¢„å…ˆè·å–è§†é¢‘ä¿¡æ¯: {e}")
            # å¦‚æœé¢„å…ˆè·å–ä¿¡æ¯å¤±è´¥ï¼Œæä¾›ä¸€ä¸ªå›é€€æ–¹æ¡ˆ
            title = self._sanitize_filename(str(int(time.time())))
            logger.info(f"ğŸ“ ä½¿ç”¨æ—¶é—´æˆ³ä½œä¸ºæ ‡é¢˜: {title}")
        # 2. æ ¹æ®å¹³å°å’Œè·å–åˆ°çš„ä¿¡æ¯æ„é€ ç²¾ç¡®çš„è¾“å‡ºæ¨¡æ¿
        if self.is_youtube_url(url):
            # æ£€æŸ¥æ˜¯å¦ä¸ºéŸ³é¢‘æ¨¡å¼ï¼Œå¦‚æœæ˜¯åˆ™ä½¿ç”¨musicå­ç›®å½•
            if hasattr(self, 'bot') and hasattr(self.bot, 'youtube_audio_mode') and self.bot.youtube_audio_mode:
                # éŸ³é¢‘æ¨¡å¼ï¼šä½¿ç”¨YouTube/musicç›®å½•
                music_path = download_path / "music"
                music_path.mkdir(exist_ok=True)  # ç¡®ä¿musicç›®å½•å­˜åœ¨
                if hasattr(self, 'bot') and hasattr(self.bot, 'youtube_id_tags') and self.bot.youtube_id_tags:
                    outtmpl = str(music_path.absolute() / f"{title}[%(id)s].%(ext)s")
                else:
                    outtmpl = str(music_path.absolute() / f"{title}.%(ext)s")
                logger.info("ğŸµ éŸ³é¢‘æ¨¡å¼ï¼šæ–‡ä»¶å°†ä¿å­˜åˆ°YouTube/musicç›®å½•")
            else:
                # é»˜è®¤è§†é¢‘æ¨¡å¼ï¼šä½¿ç”¨YouTubeæ ¹ç›®å½•
                if hasattr(self, 'bot') and hasattr(self.bot, 'youtube_id_tags') and self.bot.youtube_id_tags:
                    outtmpl = str(download_path.absolute() / f"{title}[%(id)s].%(ext)s")
                else:
                    outtmpl = str(download_path.absolute() / f"{title}.%(ext)s")
        elif self.is_x_url(url):
            outtmpl = str(download_path.absolute() / f"{title}.%(ext)s")
        else:  # å…¶ä»–å¹³å°
            # Instagramä¸“ç”¨æ–‡ä»¶å‘½åä¼˜åŒ–
            if "instagram.com" in url.lower():
                optimized_title = self._optimize_instagram_filename(title)
                outtmpl = str(download_path.absolute() / f"{optimized_title}.%(ext)s")
                logger.info(f"ğŸ¨ Instagramä¼˜åŒ–æ–‡ä»¶å: {optimized_title}")
            else:
                outtmpl = str(download_path.absolute() / f"{title}.%(ext)s")
        # æ·»åŠ æ˜æ˜¾çš„outtmplæ—¥å¿—
        logger.info(f"ğŸ”§ [SINGLE_VIDEO] outtmpl ç»å¯¹è·¯å¾„: {outtmpl}")
        logger.info(f"ğŸ“ ä¸‹è½½è·¯å¾„: {download_path}")
        logger.info(f"ğŸ“ è¾“å‡ºæ¨¡æ¿: {outtmpl}")
        logger.info("ğŸ” æ­¥éª¤3: é…ç½®ä¸‹è½½é€‰é¡¹...")

        # ğŸ¯ Instagramä¸“ç”¨æ£€æµ‹å’Œé…ç½®ï¼ˆå¿…é¡»åœ¨æ ¼å¼è®¾ç½®ä¹‹å‰ï¼‰
        if "instagram.com" in url.lower():
            logger.info("ğŸ¯ Instagramæ£€æµ‹ï¼šè®¾ç½®æœ€é«˜è´¨é‡æ ¼å¼é€‰æ‹©")
            
            # æ£€æŸ¥æ˜¯å¦æœ‰ Instagram ä¸‹è½½å™¨å¯ç”¨
            if hasattr(self, 'instagram_downloader') and self.instagram_downloader:
                logger.info("ğŸ“± ä½¿ç”¨ä¸“é—¨çš„ Instagram ä¸‹è½½å™¨")
                # ä½¿ç”¨æœ€é«˜è´¨é‡æ ¼å¼é€‰æ‹©
                format_spec = "bestvideo+bestaudio/bestvideo[ext=mp4]+bestaudio[ext=m4a]/bestvideo+bestaudio[ext=m4a]/best[height>=1080]/best"
                merge_format = "mp4"
            else:
                logger.info("ğŸ“± ä½¿ç”¨ yt-dlp å¤„ç† Instagram")
                # ä½¿ç”¨æœ€é«˜è´¨é‡æ ¼å¼é€‰æ‹©
                format_spec = "bestvideo+bestaudio/bestvideo[ext=mp4]+bestaudio[ext=m4a]/bestvideo+bestaudio[ext=m4a]/best[height>=1080]/best"
                merge_format = "mp4"
            
            # æ£€æŸ¥å¹¶åº”ç”¨Instagram cookies
            if (
                hasattr(self, 'instagram_cookies_path') and 
                self.instagram_cookies_path and 
                os.path.exists(self.instagram_cookies_path)
            ):
                logger.info(f"ğŸª Instagramå°†ä½¿ç”¨cookies: {self.instagram_cookies_path}")
            else:
                logger.warning("âš ï¸ æ£€æµ‹åˆ°Instagramé“¾æ¥ä½†æœªè®¾ç½®cookiesæ–‡ä»¶")
                logger.warning("ğŸ’¡ Instagramå¤§éƒ¨åˆ†å†…å®¹éœ€è¦ç™»å½•æ‰èƒ½è®¿é—®")
                if hasattr(self, 'instagram_cookies_path') and self.instagram_cookies_path:
                    logger.warning(f"âš ï¸ Instagram cookiesæ–‡ä»¶ä¸å­˜åœ¨: {self.instagram_cookies_path}")
                else:
                    logger.warning("âš ï¸ æœªè®¾ç½®INSTAGRAM_COOKIESç¯å¢ƒå˜é‡")
                logger.warning("ğŸ“ è¯·è®¾ç½®INSTAGRAM_COOKIESç¯å¢ƒå˜é‡æŒ‡å‘cookiesæ–‡ä»¶")
        # æ ¹æ®YouTubeéŸ³é¢‘æ¨¡å¼è®¾ç½®format
        elif self.is_youtube_url(url) and hasattr(self, 'bot') and hasattr(self.bot, 'youtube_audio_mode') and self.bot.youtube_audio_mode:
            # YouTubeéŸ³é¢‘æ¨¡å¼ï¼šä¼˜å…ˆä¸‹è½½æœ€é«˜ç ç‡çš„MP3æ ¼å¼
            format_spec = "bestaudio[ext=mp3]/bestaudio[acodec=mp3]/bestaudio"
            merge_format = "mp3"
            logger.info("ğŸµ å¯ç”¨YouTubeéŸ³é¢‘æ¨¡å¼ï¼Œä¼˜å…ˆä¸‹è½½æœ€é«˜ç ç‡MP3")
        else:
            # é»˜è®¤è§†é¢‘æ¨¡å¼ - ä¸ºä¸åŒå¹³å°è®¾ç½®ä¸åŒçš„æ ¼å¼é€‰æ‹©ç­–ç•¥
            if self.is_bilibili_url(url):
                # Bç«™ä¸“ç”¨æ ¼å¼é€‰æ‹©ç­–ç•¥
                format_spec = self._get_bilibili_best_format()
                logger.info("ğŸ¯ æ£€æµ‹åˆ°Bç«™URLï¼Œä½¿ç”¨4Kä¼˜å…ˆæ ¼å¼ç­–ç•¥")
                logger.info(f"ğŸ”§ è®¾ç½®çš„æ ¼å¼å­—ç¬¦ä¸²: {format_spec}")
                
                # æ£€æŸ¥Bç«™ä¼šå‘˜çŠ¶æ€
                member_status = self.check_bilibili_member_status()
                logger.info(f"ğŸ” Bç«™ä¼šå‘˜çŠ¶æ€: {member_status['message']}")
                
                # è°ƒè¯•Bç«™æ ¼å¼
                try:
                    debug_result = self.debug_bilibili_formats(url)
                    if debug_result["success"]:
                        max_height = debug_result["max_height"]
                        logger.info(f"ğŸ” Bç«™è§†é¢‘æœ€é«˜åˆ†è¾¨ç‡: {max_height}p")
                        if max_height >= 2160:
                            logger.info("ğŸ‰ è¯¥è§†é¢‘æ”¯æŒ4Kä¸‹è½½ï¼ˆéœ€è¦Bç«™å¤§ä¼šå‘˜ï¼‰")
                            logger.info("ğŸ’¡ æç¤ºï¼šè¦ä¸‹è½½4Kï¼Œéœ€è¦Bç«™å¤§ä¼šå‘˜å¹¶æ­£ç¡®è®¾ç½®cookies")
                        elif max_height >= 1440:
                            logger.info("âœ… è¯¥è§†é¢‘æ”¯æŒ2Kä¸‹è½½ï¼ˆéœ€è¦Bç«™å¤§ä¼šå‘˜ï¼‰")
                            logger.info("ğŸ’¡ æç¤ºï¼šè¦ä¸‹è½½2Kï¼Œéœ€è¦Bç«™å¤§ä¼šå‘˜å¹¶æ­£ç¡®è®¾ç½®cookies")
                        elif max_height >= 1080:
                            logger.info("âœ… è¯¥è§†é¢‘æ”¯æŒ1080pä¸‹è½½ï¼ˆéœ€è¦Bç«™ä¼šå‘˜ï¼‰")
                            logger.info("ğŸ’¡ æç¤ºï¼šè¦ä¸‹è½½1080pï¼Œéœ€è¦Bç«™å¤§ä¼šå‘˜å¹¶æ­£ç¡®è®¾ç½®cookies")
                        elif max_height >= 720:
                            logger.info(f"âœ… è¯¥è§†é¢‘æ”¯æŒ {max_height}p ä¸‹è½½ï¼ˆéä¼šå‘˜æœ€é«˜è´¨é‡ï¼‰")
                        else:
                            logger.warning(f"âš ï¸ è¯¥è§†é¢‘æœ€é«˜åˆ†è¾¨ç‡ä»… {max_height}p")
                except Exception as e:
                    logger.warning(f"è°ƒè¯•Bç«™æ ¼å¼å¤±è´¥: {e}")
            elif self.is_youtube_url(url):
                # YouTubeä¸“ç”¨æ ¼å¼é€‰æ‹©ç­–ç•¥ - æ˜ç¡®ä¼˜å…ˆ4K
                format_spec = "bestvideo[height>=2160]+bestaudio/bestvideo[height>=1440]+bestaudio/bestvideo[height>=1080]+bestaudio/bestvideo+bestaudio/best"
                logger.info("ğŸ¬ æ£€æµ‹åˆ°YouTube URLï¼Œä½¿ç”¨4Kä¼˜å…ˆæ ¼å¼ç­–ç•¥ (2160p->1440p->1080p)")
            elif self.is_toutiao_url(url):
                # å¤´æ¡è§†é¢‘ä¸“ç”¨æ ¼å¼é€‰æ‹©ç­–ç•¥
                format_spec = "bestvideo+bestaudio/bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[height>=1080]/best"
                logger.info("ğŸ“° æ£€æµ‹åˆ°å¤´æ¡è§†é¢‘ URLï¼Œä½¿ç”¨é«˜è´¨é‡æ ¼å¼ç­–ç•¥")
            else:
                # å…¶ä»–å¹³å°ä½¿ç”¨é€šç”¨æ ¼å¼é€‰æ‹©
                format_spec = "bestvideo+bestaudio/bestvideo[ext=mp4]+bestaudio[ext=m4a]/bestvideo+bestaudio[ext=m4a]/best[height>=1080]/best"
                logger.info("ğŸŒ å…¶ä»–å¹³å°ï¼Œä½¿ç”¨é€šç”¨1080pä¼˜å…ˆæ ¼å¼ç­–ç•¥")
            merge_format = "mp4"

        # æ ¹æ®å‚æ•°å’ŒYouTube Mixæ’­æ”¾åˆ—è¡¨é…ç½®å†³å®šæ˜¯å¦ä½¿ç”¨noplaylist
        if no_playlist:
            # å¼ºåˆ¶ä½¿ç”¨noplaylistï¼ˆç”¨äºMixæ’­æ”¾åˆ—è¡¨åŠŸèƒ½å…³é—­æ—¶ï¼ŒURLå·²æ¸…ç†ï¼‰
            noplaylist_setting = True
            logger.info("ğŸµ Mixæ’­æ”¾åˆ—è¡¨åŠŸèƒ½å…³é—­ï¼ŒURLå·²æ¸…ç†ï¼Œä½¿ç”¨å•ä¸ªè§†é¢‘æ¨¡å¼")
        elif (self.is_youtube_url(url) and hasattr(self, 'bot') and
              hasattr(self.bot, 'youtube_mix_playlist') and self.bot.youtube_mix_playlist):
            # å¦‚æœå¼€å¯äº†Mixæ’­æ”¾åˆ—è¡¨ä¸‹è½½ï¼Œä¸ä½¿ç”¨noplaylistï¼Œå…è®¸ä¸‹è½½æ’­æ”¾åˆ—è¡¨
            noplaylist_setting = False
            logger.info("ğŸµ YouTube Mixæ’­æ”¾åˆ—è¡¨ä¸‹è½½å·²å¼€å¯ï¼Œå…è®¸ä¸‹è½½æ’­æ”¾åˆ—è¡¨å†…å®¹")
        else:
            # é»˜è®¤ä½¿ç”¨noplaylistï¼Œåªä¸‹è½½å•ä¸ªè§†é¢‘
            noplaylist_setting = True
            logger.info("ğŸ¬ ä½¿ç”¨å•ä¸ªè§†é¢‘æ¨¡å¼ï¼Œä¸ä¸‹è½½æ’­æ”¾åˆ—è¡¨å†…å®¹")

        ydl_opts = {
            "outtmpl": outtmpl,
            "format": format_spec,
            "merge_output_format": merge_format,
            "noplaylist": noplaylist_setting,
            "nocheckcertificate": True,
            "ignoreerrors": True,
            "logtostderr": True,  # æ”¹ä¸ºTrueï¼Œç¡®ä¿è¿›åº¦å›è°ƒæ­£å¸¸å·¥ä½œ
            "quiet": False,  # æ”¹ä¸ºFalseï¼Œç¡®ä¿è¿›åº¦å›è°ƒæ­£å¸¸å·¥ä½œ
            "no_warnings": False,  # æ”¹ä¸ºFalseï¼Œç¡®ä¿èƒ½çœ‹åˆ°è­¦å‘Šä¿¡æ¯
            "default_search": "auto",
            "source_address": "0.0.0.0",
            "http_headers": {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
            },
            "retries": 5,  # å‡å°‘é‡è¯•æ¬¡æ•°
            "fragment_retries": 5,
            "skip_unavailable_fragments": True,
            "keepvideo": False,
            "prefer_ffmpeg": True,
            "no_download_archive": True,  # å¼ºåˆ¶é‡æ–°ä¸‹è½½å·²å­˜åœ¨çš„æ–‡ä»¶ï¼Œç¡®ä¿è¿›åº¦å›è°ƒæ­£å¸¸å·¥ä½œ
            "force_download": True,  # å¼ºåˆ¶ä¸‹è½½ï¼Œå³ä½¿æ–‡ä»¶å·²å­˜åœ¨
            "socket_timeout": 30,  # 30ç§’è¶…æ—¶
            "progress": True,  # æ·»åŠ è¿™ä¸ªå‚æ•°ï¼Œç¡®ä¿è¿›åº¦å›è°ƒè¢«å¯ç”¨
            # ğŸ¯ å…³é”®ä¿®å¤ï¼šç¡®ä¿è¿›åº¦å›è°ƒè¢«æ­£ç¡®è°ƒç”¨
            "progress_hooks": [],  # å…ˆè®¾ç½®ä¸ºç©ºï¼Œåé¢ä¼šæ·»åŠ 
            # HLSä¸‹è½½ç‰¹æ®Šé…ç½®
            "hls_use_mpegts": False,  # ä½¿ç”¨mp4å®¹å™¨è€Œä¸æ˜¯ts
            "hls_prefer_native": True,  # ä¼˜å…ˆä½¿ç”¨åŸç”ŸHLSä¸‹è½½å™¨
            "concurrent_fragment_downloads": 3,  # å¹¶å‘ä¸‹è½½åˆ†ç‰‡æ•°é‡
            "buffersize": 1024,  # ç¼“å†²åŒºå¤§å°
            "http_chunk_size": 10485760,  # 10MBåˆ†å—å¤§å°

            # ğŸ¯ ä¿®å¤ï¼šç§»é™¤extractor_argsï¼Œè®©yt-dlpä½¿ç”¨é»˜è®¤é…ç½®è·å–æœ€é«˜è´¨é‡
            # æ³¨é‡Šæ‰extractor_argsï¼Œé¿å…iOSå®¢æˆ·ç«¯é™åˆ¶æ ¼å¼é€‰æ‹©
            # "extractor_args": {
            #     "youtube": {
            #         "player_client": ["ios", "android", "web"],  # iOSä¼˜å…ˆï¼Œè·å–æœ€é«˜è´¨é‡
            #         "player_skip": ["configs"],  # è·³è¿‡é…ç½®æ£€æŸ¥
            #         "include_dash_manifest": True,  # åŒ…å«DASHæ¸…å•
            #     }
            # },
        }

        # å¦‚æœæ˜¯éŸ³é¢‘æ¨¡å¼ï¼Œæ·»åŠ éŸ³é¢‘è½¬æ¢åå¤„ç†å™¨
        if self.is_youtube_url(url) and hasattr(self, 'bot') and hasattr(self.bot, 'youtube_audio_mode') and self.bot.youtube_audio_mode:
            ydl_opts["postprocessors"] = [
                {
                    'key': 'FFmpegExtractAudio',
                    'preferredcodec': 'mp3',
                    'preferredquality': '320',  # æœ€é«˜è´¨é‡320kbps
                }
            ]
            logger.info("ğŸµ æ·»åŠ éŸ³é¢‘è½¬æ¢åå¤„ç†å™¨ï¼šè½¬æ¢ä¸º320kbps MP3")

        # å¦‚æœæ˜¯YouTubeé“¾æ¥ä¸”å¼€å¯äº†å°é¢ä¸‹è½½ï¼Œæ·»åŠ ç¼©ç•¥å›¾ä¸‹è½½é€‰é¡¹
        if self.is_youtube_url(url) and hasattr(self, 'bot') and hasattr(self.bot, 'youtube_thumbnail_download') and self.bot.youtube_thumbnail_download:
            ydl_opts["writethumbnail"] = True
            # æ·»åŠ ç¼©ç•¥å›¾æ ¼å¼è½¬æ¢åå¤„ç†å™¨ï¼šWebP -> JPG
            if "postprocessors" not in ydl_opts:
                ydl_opts["postprocessors"] = []
            ydl_opts["postprocessors"].append({
                'key': 'FFmpegThumbnailsConvertor',
                'format': 'jpg',
                'when': 'before_dl'
            })
            logger.info("ğŸ–¼ï¸ å¼€å¯YouTubeå°é¢ä¸‹è½½ï¼ˆè½¬æ¢ä¸ºJPGæ ¼å¼ï¼‰")

        # å¦‚æœæ˜¯YouTubeé“¾æ¥ä¸”å¼€å¯äº†å­—å¹•ä¸‹è½½ï¼Œæ·»åŠ å­—å¹•ä¸‹è½½é€‰é¡¹
        if self.is_youtube_url(url) and hasattr(self, 'bot') and hasattr(self.bot, 'youtube_subtitle_download') and self.bot.youtube_subtitle_download:
            ydl_opts["writeautomaticsub"] = True  # ä¸‹è½½è‡ªåŠ¨ç”Ÿæˆçš„å­—å¹•
            ydl_opts["writesubtitles"] = True     # ä¸‹è½½æ‰‹åŠ¨å­—å¹•
            ydl_opts["subtitleslangs"] = ["zh", "en"]  # å­—å¹•è¯­è¨€ï¼šä¸­æ–‡å’Œè‹±æ–‡
            ydl_opts["convertsubtitles"] = "srt"  # è½¬æ¢ä¸ºSRTæ ¼å¼
            ydl_opts["subtitlesformat"] = "best[ext=srt]/srt/best"  # ä¼˜å…ˆé€‰æ‹©SRTæ ¼å¼
            logger.info("ğŸ“ å¼€å¯YouTubeå­—å¹•ä¸‹è½½ï¼ˆä¸­æ–‡ã€è‹±æ–‡ï¼ŒSRTæ ¼å¼ï¼‰")

        # å¦‚æœæ˜¯Bç«™é“¾æ¥ä¸”å¼€å¯äº†å°é¢ä¸‹è½½ï¼Œæ·»åŠ ç¼©ç•¥å›¾ä¸‹è½½é€‰é¡¹
        if self.is_bilibili_url(url) and hasattr(self, 'bot') and hasattr(self.bot, 'bilibili_thumbnail_download') and self.bot.bilibili_thumbnail_download:
            ydl_opts["writethumbnail"] = True
            # æ·»åŠ ç¼©ç•¥å›¾æ ¼å¼è½¬æ¢åå¤„ç†å™¨ï¼šWebP -> JPG
            if "postprocessors" not in ydl_opts:
                ydl_opts["postprocessors"] = []
            ydl_opts["postprocessors"].append({
                'key': 'FFmpegThumbnailsConvertor',
                'format': 'jpg',
                'when': 'before_dl'
            })
            logger.info("ğŸ–¼ï¸ é€šç”¨ä¸‹è½½å™¨å¼€å¯Bç«™å°é¢ä¸‹è½½ï¼ˆè½¬æ¢ä¸ºJPGæ ¼å¼ï¼‰")

        # é’ˆå¯¹æ€§åœ°æ·»åŠ  Cookies
        if (
            self.is_x_url(url)
            and self.x_cookies_path
            and os.path.exists(self.x_cookies_path)
        ):
            ydl_opts["cookiefile"] = self.x_cookies_path
            logger.info(f"ğŸª ä¸ºXé“¾æ¥æ·»åŠ cookies: {self.x_cookies_path}")
        elif self.is_x_url(url):
            logger.warning("âš ï¸ æ£€æµ‹åˆ°Xé“¾æ¥ä½†æœªè®¾ç½®cookiesæ–‡ä»¶")
            logger.warning("âš ï¸ NSFWå†…å®¹éœ€è¦ç™»å½•æ‰èƒ½ä¸‹è½½")
            if self.x_cookies_path:
                logger.warning(f"âš ï¸ X cookiesæ–‡ä»¶ä¸å­˜åœ¨: {self.x_cookies_path}")
            else:
                logger.warning("âš ï¸ æœªè®¾ç½®X_COOKIESç¯å¢ƒå˜é‡")
            logger.warning("ğŸ’¡ è¯·è®¾ç½®X_COOKIESç¯å¢ƒå˜é‡æŒ‡å‘cookiesæ–‡ä»¶è·¯å¾„")
        if (
            self.is_youtube_url(url)
            and self.youtube_cookies_path
            and os.path.exists(self.youtube_cookies_path)
        ):
            ydl_opts["cookiefile"] = self.youtube_cookies_path
            logger.info(f"ğŸª ä¸ºYouTubeé“¾æ¥æ·»åŠ cookies: {self.youtube_cookies_path}")
        if (
            self.is_bilibili_url(url)
            and self.b_cookies_path
            and os.path.exists(self.b_cookies_path)
        ):
            ydl_opts["cookiefile"] = self.b_cookies_path
            logger.info(f"ğŸª ä¸ºBç«™é“¾æ¥æ·»åŠ cookies: {self.b_cookies_path}")
        if (
            self.is_douyin_url(url)
            and self.douyin_cookies_path
            and os.path.exists(self.douyin_cookies_path)
        ):
            ydl_opts["cookiefile"] = self.douyin_cookies_path
            logger.info(f"ğŸª ä¸ºæŠ–éŸ³é“¾æ¥æ·»åŠ cookies: {self.douyin_cookies_path}")
        elif self.is_douyin_url(url):
            logger.warning("âš ï¸ æ£€æµ‹åˆ°æŠ–éŸ³é“¾æ¥ä½†æœªè®¾ç½®cookiesæ–‡ä»¶")
            if self.douyin_cookies_path:
                logger.warning(f"âš ï¸ æŠ–éŸ³cookiesæ–‡ä»¶ä¸å­˜åœ¨: {self.douyin_cookies_path}")
            else:
                logger.warning("âš ï¸ æœªè®¾ç½®DOUYIN_COOKIESç¯å¢ƒå˜é‡")
        
        # Instagram cookiesåœ¨å‰é¢å·²ç»æ£€æµ‹è¿‡äº†ï¼Œè¿™é‡Œåªéœ€è¦åº”ç”¨
        if "instagram.com" in url.lower():
            if (
                hasattr(self, 'instagram_cookies_path') and
                self.instagram_cookies_path and 
                os.path.exists(self.instagram_cookies_path)
            ):
                ydl_opts["cookiefile"] = self.instagram_cookies_path
                logger.info(f"ğŸª ä¸ºInstagramé“¾æ¥åº”ç”¨cookies: {self.instagram_cookies_path}")
            else:
                logger.warning("âš ï¸ Instagramé“¾æ¥ï¼šcookiesæœªé…ç½®æˆ–æ–‡ä»¶ä¸å­˜åœ¨")
            
            # å¦‚æœæœ‰ä¸“é—¨çš„ Instagram ä¸‹è½½å™¨ï¼Œä½¿ç”¨å®ƒæ¥å¤„ç†
            if hasattr(self, 'instagram_downloader') and self.instagram_downloader:
                logger.info("ğŸ“± ä½¿ç”¨ä¸“é—¨çš„ Instagram ä¸‹è½½å™¨å¤„ç†")
                try:
                    # åˆ›å»ºè¿›åº¦å›è°ƒå‡½æ•°
                    async def instagram_progress_callback(text):
                        if message_updater:
                            try:
                                if asyncio.iscoroutinefunction(message_updater):
                                    await message_updater(text)
                                else:
                                    message_updater(text)
                            except Exception as e:
                                logger.warning(f"Instagram è¿›åº¦å›è°ƒå¤±è´¥: {e}")
                    
                    # è°ƒç”¨ Instagram ä¸‹è½½å™¨
                    result = await self.instagram_downloader.download_post(
                        url, 
                        str(download_path), 
                        instagram_progress_callback
                    )
                    
                    if result.get("success"):
                        logger.info(f"âœ… Instagram ä¸‹è½½æˆåŠŸ: {result}")
                        # æŸ¥æ‰¾ä¸‹è½½çš„æ–‡ä»¶
                        files = result.get("files", [])
                        if files:
                            # è¿”å›ç¬¬ä¸€ä¸ªæ–‡ä»¶ä½œä¸ºä¸»è¦ç»“æœ
                            main_file = files[0]
                            file_path = Path(main_file.get("path", ""))
                            if file_path.exists():
                                return {
                                    "success": True,
                                    "file_path": str(file_path),
                                    "title": title,
                                    "platform": "instagram",
                                    "files": files,
                                    "total_size": result.get("total_size", 0),
                                    "files_count": result.get("files_count", 0)
                                }
                        
                        return {
                            "success": True,
                            "platform": "instagram",
                            "message": "Instagram å†…å®¹ä¸‹è½½å®Œæˆ",
                            "result": result
                        }
                    else:
                        logger.warning(f"âš ï¸ Instagram ä¸‹è½½å™¨å¤±è´¥ï¼Œå›é€€åˆ° yt-dlp: {result.get('error')}")
                        # ç»§ç»­ä½¿ç”¨ yt-dlp å¤„ç†
                except Exception as e:
                    logger.error(f"âŒ Instagram ä¸‹è½½å™¨å¼‚å¸¸ï¼Œå›é€€åˆ° yt-dlp: {e}")
                    # ç»§ç»­ä½¿ç”¨ yt-dlp å¤„ç†
            
        # æ·»åŠ ä»£ç†
        if self.proxy_host:
            ydl_opts["proxy"] = self.proxy_host

        # æ·»åŠ å¼¹å¹•ä¸‹è½½é€‰é¡¹
        ydl_opts = self._add_danmaku_options(ydl_opts, url)

        # 3. è®¾ç½®è¿›åº¦å›è°ƒ
        logger.info("ğŸ” æ­¥éª¤3: è®¾ç½®è¿›åº¦å›è°ƒ...")
        progress_data = {"final_filename": None, "lock": threading.Lock()}

        # ä½¿ç”¨å¢å¼ºç‰ˆçš„ single_video_progress_hookï¼ŒåŒ…å«å®Œæ•´çš„è¿›åº¦æ˜¾ç¤ºé€»è¾‘
        # ğŸ”§ ä¿®å¤ï¼šå®‰å…¨æ£€æŸ¥ message_updater æ˜¯å¦æ˜¯å¢å¼ºç‰ˆè¿›åº¦å›è°ƒå‡½æ•°
        logger.info(f"ğŸ” [PROGRESS_SETUP] message_updaterç±»å‹: {type(message_updater)}")
        logger.info(f"ğŸ” [PROGRESS_SETUP] status_message: {status_message}")
        logger.info(f"ğŸ” [PROGRESS_SETUP] context: {context}")
        
        if callable(message_updater) and hasattr(message_updater, '__name__') and message_updater.__name__ == 'enhanced_progress_callback':
            # å¦‚æœæ˜¯å¢å¼ºç‰ˆè¿›åº¦å›è°ƒï¼Œç›´æ¥ä½¿ç”¨å®ƒè¿”å›çš„ progress_hook
            logger.info("ğŸ” [PROGRESS_SETUP] ä½¿ç”¨å¢å¼ºç‰ˆè¿›åº¦å›è°ƒ")
            try:
                progress_hook = message_updater(progress_data)
            except Exception as e:
                logger.error(f"è°ƒç”¨å¢å¼ºç‰ˆè¿›åº¦å›è°ƒå¤±è´¥: {e}")
                # å›é€€åˆ°æ ‡å‡†çš„ single_video_progress_hookï¼Œä¼ é€’ status_message å’Œ context
                progress_hook = single_video_progress_hook(message_updater, progress_data, status_message, context)
        else:
            # å¦åˆ™ä½¿ç”¨æ ‡å‡†çš„ single_video_progress_hookï¼Œä¼ é€’ status_message å’Œ context
            logger.info("ğŸ” [PROGRESS_SETUP] ä½¿ç”¨æ ‡å‡†è¿›åº¦å›è°ƒ")
            progress_hook = single_video_progress_hook(message_updater, progress_data, status_message, context)

        ydl_opts['progress_hooks'] = [progress_hook]
        logger.info("âœ… è¿›åº¦å›è°ƒå·²è®¾ç½®")
        # 4. è¿è¡Œä¸‹è½½
        logger.info("ğŸ” æ­¥éª¤4: å¼€å§‹ä¸‹è½½è§†é¢‘ï¼ˆè®¾ç½®60ç§’è¶…æ—¶ï¼‰...")

        def run_download():
            try:
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    logger.info("ğŸš€ å¼€å§‹ä¸‹è½½è§†é¢‘...")
                    
                    # è·å–è§†é¢‘ä¿¡æ¯
                    try:
                        info = ydl.extract_info(url, download=False)
                        title = info.get('title', 'æœªçŸ¥æ ‡é¢˜')
                        logger.info(f"ğŸ“º è§†é¢‘æ ‡é¢˜: {title}")
                    except Exception as e:
                        logger.warning(f"âš ï¸ è·å–è§†é¢‘ä¿¡æ¯å¤±è´¥: {e}")
                    
                    # å¼€å§‹ä¸‹è½½
                    ydl.download([url])
                return True
            except KeyboardInterrupt:
                # ğŸ¯ å…³é”®ä¿®å¤ï¼šå¤„ç†ç”¨æˆ·å–æ¶ˆ
                logger.info("ğŸš« ä¸‹è½½è¢«ç”¨æˆ·å–æ¶ˆ")
                if progress_data and isinstance(progress_data, dict):
                    progress_data["error"] = "ä¸‹è½½å·²è¢«ç”¨æˆ·å–æ¶ˆ"
                return False
            except Exception as e:
                error_message = str(e)
                logger.error(f"âŒ ä¸‹è½½å¤±è´¥: {error_message}")
                if progress_data and isinstance(progress_data, dict):
                    progress_data["error"] = error_message
                return False

        # è®¾ç½®60ç§’è¶…æ—¶ç”¨äºä¸‹è½½
        try:
            success = await asyncio.wait_for(
                loop.run_in_executor(None, run_download), timeout=600.0  # å¢åŠ åˆ°10åˆ†é’Ÿ
            )
        except asyncio.TimeoutError:
            logger.error("âŒ è§†é¢‘ä¸‹è½½è¶…æ—¶ï¼ˆ10åˆ†é’Ÿï¼‰")
            return {
                "success": False,
                "error": "è§†é¢‘ä¸‹è½½è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•ã€‚",
            }
        if not success:
            error = progress_data.get("error", "ä¸‹è½½å™¨åœ¨æ‰§è¡Œæ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯") if progress_data and isinstance(progress_data, dict) else "ä¸‹è½½å™¨åœ¨æ‰§è¡Œæ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯"
            return {"success": False, "error": error}
        # 5. æŸ¥æ‰¾æ–‡ä»¶å¹¶è¿”å›ç»“æœ
        logger.info("ğŸ” æ­¥éª¤5: æŸ¥æ‰¾ä¸‹è½½çš„æ–‡ä»¶...")
        time.sleep(1)  # ç­‰å¾…æ–‡ä»¶ç³»ç»ŸåŒæ­¥

        # ä½¿ç”¨å•è§†é¢‘æ–‡ä»¶æŸ¥æ‰¾æ–¹æ³•
        final_file_path = self.single_video_find_downloaded_file(download_path, progress_data, title, url)



        # å¤„ç†æœ€ç»ˆæ–‡ä»¶
        if final_file_path and os.path.exists(final_file_path):
            logger.info("ğŸ” æ­¥éª¤6: è·å–åª’ä½“ä¿¡æ¯...")
            media_info = self.get_media_info(final_file_path)

            # å®‰å…¨åœ°è·å–æ–‡ä»¶å¤§å°
            try:
                file_size_bytes = os.path.getsize(final_file_path)
                size_mb = file_size_bytes / (1024 * 1024)
            except (OSError, TypeError):
                size_mb = 0.0

            logger.info("ğŸ‰ è§†é¢‘ä¸‹è½½ä»»åŠ¡å®Œæˆ!")
            return {
                "success": True,
                "filename": os.path.basename(final_file_path),
                "full_path": final_file_path,
                "size_mb": size_mb,
                "platform": self.get_platform_name(url),
                "download_path": str(download_path),
                "resolution": media_info.get("resolution", "æœªçŸ¥"),
                "abr": media_info.get("bit_rate"),
                "title": title,
            }
        else:
            return {
                "success": False,
                "error": "ä¸‹è½½å®Œæˆä½†æ— æ³•åœ¨æ–‡ä»¶ç³»ç»Ÿä¸­æ‰¾åˆ°æœ€ç»ˆæ–‡ä»¶ã€‚",
            }



    async def _download_youtube_channel_playlists(
        self, channel_url: str, download_path: Path, message_updater=None, status_message=None, loop=None
    ) -> Dict[str, Any]:
        """ä¸‹è½½YouTubeé¢‘é“çš„æ‰€æœ‰æ’­æ”¾åˆ—è¡¨"""
        logger.info(f"ğŸ¬ å¼€å§‹ä¸‹è½½YouTubeé¢‘é“æ’­æ”¾åˆ—è¡¨: {channel_url}")
        logger.info(f"ğŸ“ ä¸‹è½½è·¯å¾„: {download_path}")
        # ç§»é™¤è°ƒè¯•æ—¥å¿—

        # ç¡®ä¿äº‹ä»¶å¾ªç¯æ­£ç¡®è®¾ç½®
        try:
            import asyncio
            self._main_loop = asyncio.get_running_loop()
            logger.info(f"âœ… æˆåŠŸè®¾ç½®äº‹ä»¶å¾ªç¯: {self._main_loop}")
        except Exception as e:
            logger.warning(f"âš ï¸ æ— æ³•è·å–äº‹ä»¶å¾ªç¯: {e}")
            self._main_loop = None



        # YouTubeé¢‘é“æ’­æ”¾åˆ—è¿›åº¦ç®¡ç†å™¨ - ä¸“é—¨ç”¨äºè·Ÿè¸ªYouTubeé¢‘é“æ’­æ”¾åˆ—è¡¨ä¸‹è½½çš„æ€»ä½“è¿›åº¦
        global_progress = {
            "total_playlists": 0,
            "completed_playlists": 0,
            "total_videos": 0,
            "completed_videos": 0,
            "total_size_mb": 0,
            "downloaded_size_mb": 0,
            "channel_name": "",
            "start_time": time.time()
        }

        try:
            # æ›´æ–°çŠ¶æ€æ¶ˆæ¯
            if message_updater:
                try:
                    if asyncio.iscoroutinefunction(message_updater):
                        await message_updater("ğŸ” æ­£åœ¨è·å–é¢‘é“ä¿¡æ¯...")
                    else:
                        message_updater("ğŸ” æ­£åœ¨è·å–é¢‘é“ä¿¡æ¯...")
                except Exception as e:
                    logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")
            logger.info("ğŸ” æ­¥éª¤1: å‡†å¤‡è·å–é¢‘é“ä¿¡æ¯...")
            # è·å–é¢‘é“ä¿¡æ¯ - æ·»åŠ è¶…æ—¶æ§åˆ¶
            info_opts = {
                "quiet": True,
                "extract_flat": True,
                "ignoreerrors": True,
                "socket_timeout": 30,  # 30ç§’è¶…æ—¶
                "retries": 8,  # å¢åŠ é‡è¯•æ¬¡æ•°ä»¥æé«˜æ–­ç‚¹ç»­ä¼ æˆåŠŸç‡
                "fragment_retries": 8,
                # ç¡®ä¿åªæå–æ’­æ”¾åˆ—è¡¨ï¼Œä¸æå–å•ä¸ªè§†é¢‘
                "playlistend": None,  # ä¸é™åˆ¶æ’­æ”¾åˆ—è¡¨é•¿åº¦
                "playliststart": 1,   # ä»ç¬¬ä¸€ä¸ªå¼€å§‹
            }
            if self.proxy_host:
                info_opts["proxy"] = self.proxy_host
                logger.info(f"ğŸŒ ä½¿ç”¨ä»£ç†: {self.proxy_host}")
            if self.youtube_cookies_path and os.path.exists(self.youtube_cookies_path):
                info_opts["cookiefile"] = self.youtube_cookies_path
                logger.info(f"ğŸª ä½¿ç”¨YouTube cookies: {self.youtube_cookies_path}")
            logger.info("ğŸ” æ­¥éª¤2: å¼€å§‹æå–é¢‘é“ä¿¡æ¯ï¼ˆè®¾ç½®30ç§’è¶…æ—¶ï¼‰...")
            # ä½¿ç”¨å¼‚æ­¥æ‰§è¡Œå™¨æ¥æ·»åŠ è¶…æ—¶æ§åˆ¶
            loop = asyncio.get_running_loop()

            def extract_channel_info():
                logger.info("ğŸ“¡ æ­£åœ¨ä»YouTubeè·å–é¢‘é“æ•°æ®...")
                with yt_dlp.YoutubeDL(info_opts) as ydl:
                    logger.info("ğŸ”— å¼€å§‹ç½‘ç»œè¯·æ±‚...")
                    result = ydl.extract_info(channel_url, download=False)
                    logger.info(f"ğŸ“Š ç½‘ç»œè¯·æ±‚å®Œæˆï¼Œç»“æœç±»å‹: {type(result)}")
                    return result

            # è®¾ç½®30ç§’è¶…æ—¶
            try:
                if message_updater:
                    try:
                        if asyncio.iscoroutinefunction(message_updater):
                            await message_updater("â³ æ­£åœ¨è¿æ¥YouTubeæœåŠ¡å™¨...")
                        else:
                            message_updater("â³ æ­£åœ¨è¿æ¥YouTubeæœåŠ¡å™¨...")
                    except Exception as e:
                        logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")
                info = await asyncio.wait_for(
                    loop.run_in_executor(None, extract_channel_info), timeout=60.0
                )
                logger.info(f"âœ… é¢‘é“ä¿¡æ¯è·å–å®Œæˆï¼Œæ•°æ®ç±»å‹: {type(info)}")
                if message_updater:
                    try:
                        if asyncio.iscoroutinefunction(message_updater):
                            await message_updater("âœ… é¢‘é“ä¿¡æ¯è·å–æˆåŠŸï¼Œæ­£åœ¨åˆ†æ...")
                        else:
                            message_updater("âœ… é¢‘é“ä¿¡æ¯è·å–æˆåŠŸï¼Œæ­£åœ¨åˆ†æ...")
                    except Exception as e:
                        logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")
            except asyncio.TimeoutError:
                logger.error("âŒ è·å–é¢‘é“ä¿¡æ¯è¶…æ—¶ï¼ˆ30ç§’ï¼‰")
                if message_updater:
                    try:
                        if asyncio.iscoroutinefunction(message_updater):
                            await message_updater(
                                "âŒ è·å–é¢‘é“ä¿¡æ¯è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•ã€‚"
                            )
                        else:
                            message_updater(
                                "âŒ è·å–é¢‘é“ä¿¡æ¯è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•ã€‚"
                            )
                    except Exception as e:
                        logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")
                return {
                    "success": False,
                    "error": "è·å–é¢‘é“ä¿¡æ¯è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•ã€‚",
                }
            logger.info("ğŸ” æ­¥éª¤3: æ£€æŸ¥é¢‘é“ä¿¡æ¯ç»“æ„...")
            if not info:
                logger.error("âŒ é¢‘é“ä¿¡æ¯ä¸ºç©º")
                if message_updater:
                    try:
                        if asyncio.iscoroutinefunction(message_updater):
                            await message_updater("âŒ æ— æ³•è·å–é¢‘é“ä¿¡æ¯ã€‚")
                        else:
                            message_updater("âŒ æ— æ³•è·å–é¢‘é“ä¿¡æ¯ã€‚")
                    except Exception as e:
                        logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")
                return {"success": False, "error": "æ— æ³•è·å–é¢‘é“ä¿¡æ¯ã€‚"}
            if "entries" not in info:
                logger.warning("âŒ é¢‘é“ä¿¡æ¯ä¸­æ²¡æœ‰æ‰¾åˆ° 'entries' å­—æ®µ")
                logger.info(
                    f"ğŸ“Š é¢‘é“ä¿¡æ¯åŒ…å«çš„å­—æ®µ: {list(info.keys()) if isinstance(info, dict) else 'éå­—å…¸ç±»å‹'}"
                )
                if message_updater:
                    try:
                        if asyncio.iscoroutinefunction(message_updater):
                            await message_updater("âŒ æ­¤é¢‘é“ä¸»é¡µæœªæ‰¾åˆ°ä»»ä½•æ’­æ”¾åˆ—è¡¨ã€‚")
                        else:
                            message_updater("âŒ æ­¤é¢‘é“ä¸»é¡µæœªæ‰¾åˆ°ä»»ä½•æ’­æ”¾åˆ—è¡¨ã€‚")
                    except Exception as e:
                        logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")
                return {"success": False, "error": "æ­¤é¢‘é“ä¸»é¡µæœªæ‰¾åˆ°ä»»ä½•æ’­æ”¾åˆ—è¡¨ã€‚"}
            entries = info.get("entries", [])
            logger.info(f"ğŸ“Š æ‰¾åˆ° {len(entries)} ä¸ªæ¡ç›®")
            if not entries:
                logger.warning("âŒ é¢‘é“æ¡ç›®åˆ—è¡¨ä¸ºç©º")
                if message_updater:
                    try:
                        if asyncio.iscoroutinefunction(message_updater):
                            await message_updater("âŒ æ­¤é¢‘é“ä¸»é¡µæœªæ‰¾åˆ°ä»»ä½•æ’­æ”¾åˆ—è¡¨ã€‚")
                        else:
                            message_updater("âŒ æ­¤é¢‘é“ä¸»é¡µæœªæ‰¾åˆ°ä»»ä½•æ’­æ”¾åˆ—è¡¨ã€‚")
                    except Exception as e:
                        logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")
                return {"success": False, "error": "æ­¤é¢‘é“ä¸»é¡µæœªæ‰¾åˆ°ä»»ä½•æ’­æ”¾åˆ—è¡¨ã€‚"}
            logger.info("ğŸ” æ­¥éª¤4: åˆ†æé¢‘é“æ¡ç›®...")
            if message_updater:
                try:
                    if asyncio.iscoroutinefunction(message_updater):
                        await message_updater(f"ğŸ” æ­£åœ¨åˆ†æ {len(entries)} ä¸ªé¢‘é“æ¡ç›®...")
                    else:
                        message_updater(f"ğŸ” æ­£åœ¨åˆ†æ {len(entries)} ä¸ªé¢‘é“æ¡ç›®...")
                except Exception as e:
                    logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")

            # ç»Ÿè®¡ä¸åŒç±»å‹çš„æ¡ç›®
            type_counts = {}
            playlist_entries = []

            for i, entry in enumerate(entries):
                if entry:
                    entry_type = entry.get("_type", "unknown")
                    entry_id = entry.get("id", "no_id")
                    entry_title = entry.get("title", "no_title")
                    entry_url = entry.get("url", "")

                    # ç»Ÿè®¡ç±»å‹
                    type_counts[entry_type] = type_counts.get(entry_type, 0) + 1

                    logger.info(
                        f"  ğŸ“‹ æ¡ç›® {i + 1}: ç±»å‹={entry_type}, ID={entry_id}, æ ‡é¢˜={entry_title[:50]}..."
                    )

                    # ä¸¥æ ¼è¿‡æ»¤ï¼šåªå¤„ç†çœŸæ­£çš„æ’­æ”¾åˆ—è¡¨ï¼Œå¿½ç•¥å•ä¸ªè§†é¢‘
                    if entry_type == "playlist":
                        playlist_entries.append(entry)
                        logger.info(f"    âœ… è¯†åˆ«ä¸ºæ’­æ”¾åˆ—è¡¨")
                    elif entry_type == "url" and "playlist?list=" in entry_url:
                        playlist_entries.append(entry)
                        logger.info(f"    âœ… è¯†åˆ«ä¸ºæ’­æ”¾åˆ—è¡¨URL")
                    elif entry_type == "video":
                        # æ˜ç¡®å¿½ç•¥å•ä¸ªè§†é¢‘ï¼Œé¿å…ä¸‹è½½é¢‘é“ä¸»é¡µä¸Šçš„è§†é¢‘
                        logger.info(f"    â­ï¸ è·³è¿‡å•ä¸ªè§†é¢‘ï¼ˆåªä¸‹è½½æ’­æ”¾åˆ—è¡¨ï¼‰")
                    else:
                        logger.info(f"    â­ï¸ è·³è¿‡éæ’­æ”¾åˆ—è¡¨æ¡ç›®ï¼ˆç±»å‹: {entry_type}ï¼‰")
                else:
                    logger.warning(f"  âš ï¸ æ¡ç›® {i + 1} ä¸ºç©º")

            # è¾“å‡ºç»Ÿè®¡ä¿¡æ¯
            logger.info(f"ğŸ“Š æ¡ç›®ç±»å‹ç»Ÿè®¡: {type_counts}")
            logger.info(f"ğŸ“Š è¿‡æ»¤ç»“æœ: æ€»æ¡ç›® {len(entries)} ä¸ªï¼Œæ’­æ”¾åˆ—è¡¨ {len(playlist_entries)} ä¸ª")
            logger.info(f"ğŸ“Š æ€»å…±æ‰¾åˆ° {len(playlist_entries)} ä¸ªæ’­æ”¾åˆ—è¡¨")

            if not playlist_entries:
                logger.warning("âŒ æ²¡æœ‰æ‰¾åˆ°ä»»ä½•æ’­æ”¾åˆ—è¡¨")
                if message_updater:
                    try:
                        if asyncio.iscoroutinefunction(message_updater):
                            await message_updater("âŒ é¢‘é“ä¸­æ²¡æœ‰æ‰¾åˆ°ä»»ä½•æ’­æ”¾åˆ—è¡¨ã€‚")
                        else:
                            message_updater("âŒ é¢‘é“ä¸­æ²¡æœ‰æ‰¾åˆ°ä»»ä½•æ’­æ”¾åˆ—è¡¨ã€‚")
                    except Exception as e:
                        logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")
                return {"success": False, "error": "é¢‘é“ä¸­æ²¡æœ‰æ‰¾åˆ°ä»»ä½•æ’­æ”¾åˆ—è¡¨ã€‚"}

            logger.info("ğŸ” æ­¥éª¤5: åˆ›å»ºé¢‘é“ç›®å½•...")
            channel_name = re.sub(
                r'[\\/:*?"<>|]', "_", info.get("uploader", "Unknown Channel")
            ).strip()
            # YouTubeé¢‘é“ç›®å½•ä¸åŒ…å«IDï¼Œåªä½¿ç”¨é¢‘é“åç§°
            channel_path = download_path / channel_name
            channel_path.mkdir(parents=True, exist_ok=True)
            logger.info(f"ğŸ“ é¢‘é“ç›®å½•: {channel_path}")

            logger.info("ğŸ” æ­¥éª¤6: å¼€å§‹ä¸‹è½½æ’­æ”¾åˆ—è¡¨...")
            if message_updater:
                try:
                    if asyncio.iscoroutinefunction(message_updater):
                        await message_updater(
                            f"ğŸ¬ å¼€å§‹ä¸‹è½½ {len(playlist_entries)} ä¸ªæ’­æ”¾åˆ—è¡¨..."
                        )
                    else:
                        message_updater(
                            f"ğŸ¬ å¼€å§‹ä¸‹è½½ {len(playlist_entries)} ä¸ªæ’­æ”¾åˆ—è¡¨..."
                        )
                except Exception as e:
                    logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")

            # åˆå§‹åŒ–å…¨å±€è¿›åº¦æ•°æ®
            global_progress["total_playlists"] = len(playlist_entries)
            global_progress["channel_name"] = channel_name

            # è®¡ç®—æ€»è§†é¢‘æ•°ï¼ˆå¦‚æœå¯èƒ½çš„è¯ï¼‰
            total_video_count = 0
            for entry in playlist_entries:
                if entry and "video_count" in entry:
                    total_video_count += entry.get("video_count", 0)

            # å¦‚æœæ— æ³•ä»APIè·å–è§†é¢‘æ•°é‡ï¼Œè®¾ç½®ä¸º-1è¡¨ç¤ºéœ€è¦åŠ¨æ€è®¡ç®—
            if total_video_count == 0:
                logger.info("ğŸ“Š æ— æ³•ä»APIè·å–è§†é¢‘æ•°é‡ï¼Œå°†åœ¨ä¸‹è½½è¿‡ç¨‹ä¸­åŠ¨æ€è®¡ç®—")
                global_progress["total_videos"] = -1  # ä½¿ç”¨-1è¡¨ç¤ºéœ€è¦åŠ¨æ€è®¡ç®—
            else:
                global_progress["total_videos"] = total_video_count

            logger.info(f"ğŸ“Š å…¨å±€è¿›åº¦åˆå§‹åŒ–: {global_progress['total_playlists']} ä¸ªæ’­æ”¾åˆ—è¡¨, {global_progress['total_videos']} ä¸ªè§†é¢‘")

            downloaded_playlists = []
            playlist_stats = []  # å­˜å‚¨æ¯ä¸ªæ’­æ”¾åˆ—è¡¨çš„ç»Ÿè®¡ä¿¡æ¯

            for i, entry in enumerate(playlist_entries, 1):
                playlist_id = entry.get("id")
                playlist_title = entry.get("title", f"Playlist_{playlist_id}")
                logger.info(
                    f"ğŸ¬ å¼€å§‹ä¸‹è½½ç¬¬ {i}/{len(playlist_entries)} ä¸ªæ’­æ”¾åˆ—è¡¨: {playlist_title}"
                )
                logger.info(f"    ğŸ“‹ æ’­æ”¾åˆ—è¡¨ID: {playlist_id}")

                # å…ˆæ£€æŸ¥æ’­æ”¾åˆ—è¡¨æ˜¯å¦å·²å®Œæ•´ä¸‹è½½
                check_result = self._check_playlist_already_downloaded(playlist_id, channel_path)

                if message_updater:
                    try:
                        if asyncio.iscoroutinefunction(message_updater):
                            if check_result.get("already_downloaded", False):
                                await message_updater(
                                    f"âœ… æ£€æŸ¥ç¬¬ {i}/{len(playlist_entries)} ä¸ªæ’­æ”¾åˆ—è¡¨ï¼š{playlist_title} (å·²å®Œæ•´ä¸‹è½½)"
                                )
                            else:
                                await message_updater(
                                    f"ğŸ“¥ æ­£åœ¨ä¸‹è½½ç¬¬ {i}/{len(playlist_entries)} ä¸ªæ’­æ”¾åˆ—è¡¨ï¼š{playlist_title}"
                                )
                        else:
                            if check_result.get("already_downloaded", False):
                                message_updater(
                                    f"âœ… æ£€æŸ¥ç¬¬ {i}/{len(playlist_entries)} ä¸ªæ’­æ”¾åˆ—è¡¨ï¼š{playlist_title} (å·²å®Œæ•´ä¸‹è½½)"
                                )
                            else:
                                message_updater(
                                    f"ğŸ“¥ æ­£åœ¨ä¸‹è½½ç¬¬ {i}/{len(playlist_entries)} ä¸ªæ’­æ”¾åˆ—è¡¨ï¼š{playlist_title}"
                                )
                    except Exception as e:
                        logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")

                # åˆ›å»ºæ’­æ”¾åˆ—è¡¨ä¸“ç”¨çš„è¿›åº¦å›è°ƒ
                playlist_progress_data = {
                    "playlist_index": i,
                    "total_playlists": len(playlist_entries),
                    "playlist_title": playlist_title,
                    "current_video": 0,
                    "total_videos": 0,
                    "downloaded_videos": 0,
                }

                def create_playlist_progress_callback(progress_data):
                    last_update = {"percent": -1, "time": 0, "text": ""}
                    import time as _time



                    def escape_num(text):
                        # è½¬ä¹‰MarkdownV2ç‰¹æ®Šå­—ç¬¦ï¼ŒåŒ…æ‹¬å°æ•°ç‚¹
                        if not isinstance(text, str):
                            text = str(text)
                        escape_chars = [
                            "_",
                            "*",
                            "[",
                            "]",
                            "(",
                            ")",
                            "~",
                            "`",
                            ">",
                            "#",
                            "+",
                            "-",
                            "=",
                            "|",
                            "{",
                            "}",
                            ".",
                            "!",
                        ]
                        for char in escape_chars:
                            text = text.replace(char, "\\" + char)
                        return text

                    def progress_callback(d):
                        # å¼ºåˆ¶æ—¥å¿—ï¼Œç¡®ä¿èƒ½çœ‹åˆ°è¿›åº¦å›è°ƒè¢«è°ƒç”¨
                        logger.info(f"ğŸ” [PROGRESS_CALLBACK] è¢«è°ƒç”¨: status={d.get('status')}, filename={d.get('filename', 'N/A')}")

                        if d.get("status") == "downloading":
                            logger.info(f"ğŸ” YouTubeæ’­æ”¾åˆ—è¡¨è¿›åº¦å›è°ƒ: status={d.get('status')}, filename={d.get('filename', 'N/A')}")
                            # ä¿®æ­£å½“å‰è§†é¢‘åºå·ä¸ºæœ¬æ’­æ”¾åˆ—è¡¨çš„å½“å‰ä¸‹è½½è§†é¢‘åºå·/æ€»æ•°
                            cur_idx = (
                                d.get("playlist_index")
                                or d.get("info_dict", {}).get("playlist_index")
                                or 1
                            )
                            total_idx = (
                                d.get("playlist_count")
                                or d.get("info_dict", {}).get("n_entries")
                                or (progress_data.get("total_videos") if progress_data and isinstance(progress_data, dict) else 0)
                                or 1
                            )
                            if progress_data and isinstance(progress_data, dict):
                                progress_text = (
                                    f"ğŸ“¥ æ­£åœ¨ä¸‹è½½ç¬¬{escape_num(progress_data['playlist_index'])}/{escape_num(progress_data['total_playlists'])}ä¸ªæ’­æ”¾åˆ—è¡¨ï¼š{escape_num(progress_data['playlist_title'])}\n\n"
                                    f"ğŸ“º å½“å‰è§†é¢‘: {escape_num(cur_idx)}/{escape_num(total_idx)}\n"
                                )
                            else:
                                progress_text = f"ğŸ“º å½“å‰è§†é¢‘: {escape_num(cur_idx)}/{escape_num(total_idx)}\n"
                            percent = 0
                            if d.get("filename"):
                                filename = os.path.basename(d.get("filename", ""))
                                total_bytes = d.get("total_bytes") or d.get(
                                    "total_bytes_estimate", 0
                                )
                                downloaded_bytes = d.get("downloaded_bytes", 0)
                                speed_bytes_s = d.get("speed", 0)
                                eta_seconds = d.get("eta", 0)
                                if total_bytes and total_bytes > 0:
                                    downloaded_mb = downloaded_bytes / (1024 * 1024)
                                    total_mb = total_bytes / (1024 * 1024)
                                    speed_mb_s = (
                                        speed_bytes_s / (1024 * 1024)
                                        if speed_bytes_s
                                        else 0
                                    )
                                    percent = int(downloaded_bytes * 100 / total_bytes)
                                    bar = self._make_progress_bar(percent)
                                    try:
                                        minutes, seconds = divmod(int(eta_seconds), 60)
                                        eta_str = f"{minutes:02d}:{seconds:02d}"
                                    except (ValueError, TypeError):
                                        eta_str = "æœªçŸ¥"
                                    downloaded_mb_str = f"{downloaded_mb:.2f}"
                                    total_mb_str = f"{total_mb:.2f}"
                                    speed_mb_s_str = f"{speed_mb_s:.2f}"
                                    percent_str = f"{percent:.1f}"
                                    progress_text += (
                                        f"ğŸ“ æ–‡ä»¶: {escape_num(filename)}\n"
                                        f"ğŸ’¾ å¤§å°: {escape_num(downloaded_mb_str)}MB / {escape_num(total_mb_str)}MB\n"
                                        f"âš¡ é€Ÿåº¦: {escape_num(speed_mb_s_str)}MB/s\n"
                                        f"â³ é¢„è®¡å‰©ä½™: {escape_num(eta_str)}\n"
                                        f"ğŸ“Š è¿›åº¦: {bar} {escape_num(percent_str)}%"
                                    )
                                else:
                                    downloaded_mb = (
                                        downloaded_bytes / (1024 * 1024)
                                        if downloaded_bytes > 0
                                        else 0
                                    )
                                    speed_mb_s = (
                                        speed_bytes_s / (1024 * 1024)
                                        if speed_bytes_s
                                        else 0
                                    )
                                    downloaded_mb_str = f"{downloaded_mb:.2f}"
                                    speed_mb_s_str = f"{speed_mb_s:.2f}"
                                    progress_text += (
                                        f"ğŸ“ æ–‡ä»¶: {escape_num(filename)}\n"
                                        f"ğŸ’¾ å¤§å°: {escape_num(downloaded_mb_str)}MB\n"
                                        f"âš¡ é€Ÿåº¦: {escape_num(speed_mb_s_str)}MB/s\n"
                                        f"ğŸ“Š è¿›åº¦: ä¸‹è½½ä¸­..."
                                    )
                            now = _time.time()
                            # å‚è€ƒrenlixing.pyï¼šæ¯5%è¿›åº¦å˜åŒ–æˆ–æ¯1ç§’æ›´æ–°ä¸€æ¬¡
                            if (abs(percent - last_update["percent"]) >= 5) or (now - last_update["time"] > 1):
                                if progress_text != last_update["text"]:
                                    # æ›´æ–°è¿›åº¦æ¶ˆæ¯
                                    logger.info(f"ğŸ”„ æ›´æ–°è¿›åº¦æ¶ˆæ¯: percent={percent}%")
                                last_update["percent"] = percent
                                last_update["time"] = now
                                last_update["text"] = progress_text
                                import asyncio

                                # ç§»é™¤è°ƒè¯•æ—¥å¿—ï¼Œç›´æ¥å¤„ç†è¿›åº¦æ›´æ–°

                                # ğŸ¯ æ™ºèƒ½ TG æ¶ˆæ¯æ›´æ–°ï¼šä» message_updater ä¸­æå– TG å¯¹è±¡
                                tg_updated = False

                                # æ–¹æ³•1ï¼šå¦‚æœç›´æ¥ä¼ é€’äº† TG å¯¹è±¡ï¼Œä¼˜å…ˆä½¿ç”¨
                                if status_message and loop:
                                    try:
                                        def fix_markdown_v2(text):
                                            # ç®€åŒ–ç‰ˆæœ¬ï¼šç§»é™¤äº†ç²—ä½“æ ‡è®°ï¼Œç›´æ¥è½¬ä¹‰æ‰€æœ‰ç‰¹æ®Šå­—ç¬¦
                                            text = text.replace('\\', '')
                                            special_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
                                            for char in special_chars:
                                                text = text.replace(char, f'\\{char}')
                                            return text

                                        fixed_text = fix_markdown_v2(progress_text)
                                        future = asyncio.run_coroutine_threadsafe(
                                            status_message.edit_text(fixed_text, parse_mode=None),
                                            loop
                                        )
                                        future.result(timeout=3.0)
                                        tg_updated = True
                                    except:
                                        try:
                                            clean_text = progress_text.replace('\\', '')
                                            future = asyncio.run_coroutine_threadsafe(
                                                status_message.edit_text(clean_text),
                                                loop
                                            )
                                            future.result(timeout=3.0)
                                            tg_updated = True
                                        except:
                                            tg_updated = False
                                else:
                                    tg_updated = False

                                # æ–¹æ³•3ï¼šä¿®å¤ message_updater è°ƒç”¨
                                if not tg_updated and message_updater:
                                    try:
                                        # ğŸ”§ ä¿®å¤ï¼šåˆ›å»ºä¸€ä¸ªåŒ…è£…å‡½æ•°ï¼Œè®© message_updater èƒ½å¤„ç†å­—ç¬¦ä¸²
                                        def fixed_message_updater(text):
                                            """ä¿®å¤çš„æ¶ˆæ¯æ›´æ–°å™¨ï¼Œèƒ½å¤„ç†å­—ç¬¦ä¸²ç±»å‹çš„è¿›åº¦"""
                                            # ä» message_updater çš„é—­åŒ…ä¸­æå–å¿…è¦çš„å¯¹è±¡
                                            if hasattr(message_updater, '__closure__') and message_updater.__closure__:
                                                for cell in message_updater.__closure__:
                                                    try:
                                                        value = cell.cell_contents
                                                        # æ‰¾åˆ° TG æ¶ˆæ¯å¯¹è±¡
                                                        if hasattr(value, 'edit_text') and hasattr(value, 'chat_id'):
                                                            status_msg = value
                                                            # æ‰¾åˆ°äº‹ä»¶å¾ªç¯
                                                            for cell2 in message_updater.__closure__:
                                                                try:
                                                                    value2 = cell2.cell_contents
                                                                    if hasattr(value2, 'run_until_complete'):
                                                                        event_loop = value2
                                                                        # ç›´æ¥æ›´æ–° TG æ¶ˆæ¯
                                                                        def fix_markdown_v2(text):
                                                                            text = text.replace('\\', '')
                                                                            special_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
                                                                            for char in special_chars:
                                                                                text = text.replace(char, f'\\{char}')
                                                                            return text

                                                                        try:
                                                                            fixed_text = fix_markdown_v2(text)
                                                                            future = asyncio.run_coroutine_threadsafe(
                                                                                status_msg.edit_text(fixed_text, parse_mode=None),
                                                                                event_loop
                                                                            )
                                                                            future.result(timeout=3.0)
                                                                            return True
                                                                        except:
                                                                            # é™çº§åˆ°æ™®é€šæ–‡æœ¬
                                                                            clean_text = text.replace('\\', '')
                                                                            future = asyncio.run_coroutine_threadsafe(
                                                                                status_msg.edit_text(clean_text),
                                                                                event_loop
                                                                            )
                                                                            future.result(timeout=3.0)
                                                                            return True
                                                                except:
                                                                    continue
                                                    except:
                                                        continue

                                            # å¦‚æœæå–å¤±è´¥ï¼Œè°ƒç”¨åŸå‡½æ•°ï¼ˆä½†è¿™ä¼šå¤±è´¥ï¼‰
                                            logger.warning(f"âš ï¸ æ— æ³•ä» message_updater æå– TG å¯¹è±¡ï¼Œå°è¯•åŸè°ƒç”¨")
                                            return False

                                        # ä½¿ç”¨ä¿®å¤çš„å‡½æ•°
                                        if not fixed_message_updater(progress_text):
                                            logger.warning(f"âš ï¸ ä¿®å¤çš„ message_updater å¤±è´¥")

                                    except Exception as e:
                                        logger.error(f"âŒ è°ƒç”¨ä¿®å¤çš„ message_updater å¤±è´¥: {e}")

                                if not tg_updated and not message_updater:
                                    logger.warning(f"âš ï¸ æ²¡æœ‰å¯ç”¨çš„æ¶ˆæ¯æ›´æ–°æ–¹æ³•")
                        elif d.get("status") == "finished":
                            if progress_data and isinstance(progress_data, dict):
                                progress_data["downloaded_videos"] += 1
                                logger.info(
                                    f"âœ… æ’­æ”¾åˆ—è¡¨ {progress_data['playlist_title']} ç¬¬ {progress_data['downloaded_videos']} ä¸ªè§†é¢‘ä¸‹è½½å®Œæˆ"
                                )

                            # ç›‘æ§æ–‡ä»¶åˆå¹¶çŠ¶æ€
                            if 'filename' in d:
                                filename = d['filename']
                                if filename.endswith('.part'):
                                    logger.warning(f"âš ï¸ æ–‡ä»¶åˆå¹¶å¯èƒ½å¤±è´¥: {filename}")
                                else:
                                    logger.info(f"âœ… æ–‡ä»¶ä¸‹è½½å¹¶åˆå¹¶æˆåŠŸ: {filename}")

                    return progress_callback

                # ä¸‹è½½æ’­æ”¾åˆ—è¡¨
                logger.info(f"ğŸ¬ å¼€å§‹ä¸‹è½½æ’­æ”¾åˆ—è¡¨ {i}/{len(playlist_entries)}: {playlist_title}")
                progress_callback = create_playlist_progress_callback(playlist_progress_data)
                logger.info(f"ğŸ”§ åˆ›å»ºè¿›åº¦å›è°ƒå‡½æ•°: {type(progress_callback)}")
                logger.info(f"ğŸ”§ è¿›åº¦å›è°ƒå‡½æ•°æ˜¯å¦ä¸ºNone: {progress_callback is None}")
                logger.info(f"ğŸ”§ message_updateræ˜¯å¦ä¸ºNone: {message_updater is None}")
                result = await self._download_youtube_playlist_with_progress(
                    playlist_id,
                    channel_path,
                    progress_callback,
                )

                if result.get("success"):
                    downloaded_playlists.append(
                        result.get("playlist_title", playlist_title)
                    )

                    # æ›´æ–°å®ŒæˆçŠ¶æ€æ¶ˆæ¯
                    if message_updater:
                        try:
                            if asyncio.iscoroutinefunction(message_updater):
                                if result.get("already_downloaded", False):
                                    await message_updater(
                                        f"âœ… ç¬¬ {i}/{len(playlist_entries)} ä¸ªæ’­æ”¾åˆ—è¡¨ï¼š{playlist_title} (å·²å­˜åœ¨)"
                                    )
                                else:
                                    await message_updater(
                                        f"âœ… ç¬¬ {i}/{len(playlist_entries)} ä¸ªæ’­æ”¾åˆ—è¡¨ï¼š{playlist_title} (ä¸‹è½½å®Œæˆ)"
                                    )
                            else:
                                if result.get("already_downloaded", False):
                                    message_updater(
                                        f"âœ… ç¬¬ {i}/{len(playlist_entries)} ä¸ªæ’­æ”¾åˆ—è¡¨ï¼š{playlist_title} (å·²å­˜åœ¨)"
                                    )
                                else:
                                    message_updater(
                                        f"âœ… ç¬¬ {i}/{len(playlist_entries)} ä¸ªæ’­æ”¾åˆ—è¡¨ï¼š{playlist_title} (ä¸‹è½½å®Œæˆ)"
                                    )
                        except Exception as e:
                            logger.warning(f"æ›´æ–°å®ŒæˆçŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")

                    # è·å–è§†é¢‘æ•°é‡ï¼Œå¦‚æœresultä¸­æ²¡æœ‰ï¼Œåˆ™é€šè¿‡æ‰«æç›®å½•è®¡ç®—
                    video_count = result.get("video_count", 0)
                    if video_count == 0:
                        # å¤‡ç”¨æ–¹æ³•ï¼šæ‰«ææ’­æ”¾åˆ—è¡¨ç›®å½•è®¡ç®—å®é™…æ–‡ä»¶æ•°é‡
                        playlist_path = Path(result.get("download_path", ""))
                        if playlist_path.exists():
                            video_files = (
                                list(playlist_path.glob("*.mp4"))
                                + list(playlist_path.glob("*.mkv"))
                                + list(playlist_path.glob("*.webm"))
                            )
                            video_count = len(video_files)
                            logger.info(f"ğŸ“Š é€šè¿‡æ‰«æç›®å½•è®¡ç®—æ’­æ”¾åˆ—è¡¨ '{playlist_title}' çš„é›†æ•°: {video_count}")

                    playlist_stats.append(
                        {
                            # ä¼˜å…ˆä½¿ç”¨resultä¸­çš„æ’­æ”¾åˆ—è¡¨æ ‡é¢˜ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä½¿ç”¨playlist_title
                            "title": result.get("playlist_title", playlist_title),
                            "video_count": video_count,
                            "download_path": result.get("download_path", ""),
                            "total_size_mb": result.get("total_size_mb", 0),
                            "resolution": result.get("resolution", "æœªçŸ¥"),
                            # æ·»åŠ PARTæ–‡ä»¶ç»Ÿè®¡ä¿¡æ¯
                            "success_count": result.get("success_count", video_count),
                            "part_count": result.get("part_count", 0),
                        }
                    )
                    # æ›´æ–°å…¨å±€è¿›åº¦
                    global_progress["completed_playlists"] += 1
                    logger.info(f"    âœ… æ’­æ”¾åˆ—è¡¨ '{playlist_title}' ä¸‹è½½æˆåŠŸï¼Œé›†æ•°: {video_count}")
                else:
                    error_msg = result.get("error", "æœªçŸ¥é”™è¯¯")
                    logger.error(
                        f"    âŒ æ’­æ”¾åˆ—è¡¨ '{playlist_title}' ä¸‹è½½å¤±è´¥: {error_msg}"
                    )

            logger.info(
                f"ğŸ“Š ä¸‹è½½å®Œæˆç»Ÿè®¡: {len(downloaded_playlists)}/{len(playlist_entries)} ä¸ªæ’­æ”¾åˆ—è¡¨æˆåŠŸ"
            )
            if not downloaded_playlists:
                logger.error("âŒ æ‰€æœ‰æ’­æ”¾åˆ—è¡¨éƒ½ä¸‹è½½å¤±è´¥äº†")
                if message_updater:
                    try:
                        if asyncio.iscoroutinefunction(message_updater):
                            await message_updater("âŒ é¢‘é“ä¸­çš„æ‰€æœ‰æ’­æ”¾åˆ—è¡¨éƒ½ä¸‹è½½å¤±è´¥äº†ã€‚")
                        else:
                            message_updater("âŒ é¢‘é“ä¸­çš„æ‰€æœ‰æ’­æ”¾åˆ—è¡¨éƒ½ä¸‹è½½å¤±è´¥äº†ã€‚")
                    except Exception as e:
                        logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")
                return {"success": False, "error": "é¢‘é“ä¸­çš„æ‰€æœ‰æ’­æ”¾åˆ—è¡¨éƒ½ä¸‹è½½å¤±è´¥äº†ã€‚"}
            logger.info("ğŸ‰ é¢‘é“æ’­æ”¾åˆ—è¡¨ä¸‹è½½ä»»åŠ¡å®Œæˆ!")

            # æ„å»ºè¯¦ç»†çš„å®Œæˆç»Ÿè®¡ä¿¡æ¯
            total_videos = sum(stat["video_count"] for stat in playlist_stats)
            total_size_mb = sum(stat["total_size_mb"] for stat in playlist_stats)

            # æŒ‰å…ˆè·å–ä¸‹è½½åˆ—è¡¨çš„æ–‡ä»¶æŸ¥æ‰¾é€»è¾‘ï¼šæ ¹æ®ä¸‹è½½åˆ—è¡¨ä¸­çš„æ–‡ä»¶åç²¾ç¡®æŸ¥æ‰¾
            downloaded_files = []
            for stat in playlist_stats:
                playlist_path = Path(stat["download_path"])
                if playlist_path.exists():
                    # å…ˆè·å–è¯¥æ’­æ”¾åˆ—è¡¨çš„ä¸‹è½½ä¿¡æ¯ï¼Œç„¶åæ ¹æ®æ–‡ä»¶åç²¾ç¡®æŸ¥æ‰¾
                    try:
                        # è·å–æ’­æ”¾åˆ—è¡¨ä¿¡æ¯ä»¥è·å–é¢„æœŸçš„æ–‡ä»¶ååˆ—è¡¨
                        info_opts = {
                            "quiet": True,
                            "extract_flat": True,
                            "ignoreerrors": True,
                        }
                        if self.proxy_host:
                            info_opts["proxy"] = self.proxy_host
                        if self.youtube_cookies_path and os.path.exists(
                            self.youtube_cookies_path
                        ):
                            info_opts["cookiefile"] = self.youtube_cookies_path

                        # ä»æ’­æ”¾åˆ—è¡¨è·¯å¾„ä¸­æå–playlist_id - æ”¹è¿›ç‰ˆæœ¬
                        playlist_id = ""
                        path_name = playlist_path.name

                        # å°è¯•ä»æ–¹æ‹¬å·ä¸­æå–å®Œæ•´çš„æ’­æ”¾åˆ—è¡¨ID
                        if path_name.startswith("[") and path_name.endswith("]"):
                            playlist_id = path_name[1:-1]  # ç§»é™¤æ–¹æ‹¬å·
                            logger.info(f"ğŸ” ä»è·¯å¾„æå–æ’­æ”¾åˆ—è¡¨ID: {playlist_id}")
                        else:
                            # å›é€€æ–¹æ¡ˆï¼šä»ä¸‹åˆ’çº¿åˆ†å‰²
                            playlist_id = (
                                path_name.split("_")[-1]
                                if "_" in path_name
                                else ""
                            )
                            logger.info(f"ğŸ” ä»ä¸‹åˆ’çº¿åˆ†å‰²æå–æ’­æ”¾åˆ—è¡¨ID: {playlist_id}")

                        if not playlist_id:
                            # å¦‚æœæ— æ³•ä»è·¯å¾„æå–ï¼Œå°è¯•ä»statä¸­è·å–
                            playlist_id = stat.get("playlist_id", "")
                            logger.info(f"ğŸ” ä»statè·å–æ’­æ”¾åˆ—è¡¨ID: {playlist_id}")

                        if playlist_id:
                            with yt_dlp.YoutubeDL(info_opts) as ydl:
                                playlist_info = ydl.extract_info(
                                    f"https://www.youtube.com/playlist?list={playlist_id}",
                                    download=False,
                                )
                                entries = playlist_info.get("entries", [])

                                # æ ¹æ®ä¸‹è½½åˆ—è¡¨ä¸­çš„æ¡ç›®æŸ¥æ‰¾å¯¹åº”çš„æ–‡ä»¶
                                for i, entry in enumerate(entries, 1):
                                    if entry:
                                        # æ„é€ é¢„æœŸçš„æ–‡ä»¶å - ä¿®å¤ç‰ˆæœ¬
                                        title = entry.get("title", f"Video_{i}")

                                        # æ›´å‡†ç¡®çš„æ–‡ä»¶åå¤„ç†ï¼Œä¿æŒä¸yt-dlpä¸€è‡´
                                        # 1. åªç§»é™¤çœŸæ­£æœ‰é—®é¢˜çš„åç¼€æ¨¡å¼ï¼ˆä¸ç§»é™¤ï½œç¬¦å·ï¼‰
                                        clean_title = re.sub(r'#.*$', '', title)  # åªç§»é™¤#åçš„å†…å®¹

                                        # 2. æ¸…ç†æ–‡ä»¶ç³»ç»Ÿä¸æ”¯æŒçš„ç‰¹æ®Šå­—ç¬¦ï¼Œä½†ä¿ç•™ï½œç¬¦å·
                                        # yt-dlpé€šå¸¸åªæ¸…ç†çœŸæ­£æœ‰é—®é¢˜çš„å­—ç¬¦
                                        safe_title = re.sub(r'[\\/:*?"<>]', "", clean_title)

                                        # 3. é™åˆ¶é•¿åº¦ï¼ˆä½†ä¸è¦å¤ªçŸ­ï¼Œé¿å…æˆªæ–­é‡è¦ä¿¡æ¯ï¼‰
                                        safe_title = safe_title.strip()[:80]  # å¢åŠ åˆ°80å­—ç¬¦

                                        expected_filename = f"{i:02d}. {safe_title}.mp4"

                                        # ç²¾ç¡®æŸ¥æ‰¾è¯¥æ–‡ä»¶
                                        expected_file_path = (
                                            playlist_path / expected_filename
                                        )
                                        if expected_file_path.exists():
                                            file_size = (
                                                expected_file_path.stat().st_size
                                                / (1024 * 1024)
                                            )  # MB
                                            downloaded_files.append(
                                                {
                                                    "filename": expected_filename,
                                                    "path": str(expected_file_path),
                                                    "size_mb": file_size,
                                                    "playlist": stat["title"],
                                                    "video_title": title,
                                                }
                                            )
                                            logger.info(
                                                f"âœ… æ‰¾åˆ°æ–‡ä»¶: {expected_filename} ({file_size:.2f}MB)")
                                        else:
                                            # å¦‚æœç²¾ç¡®åŒ¹é…å¤±è´¥ï¼Œå°è¯•æ™ºèƒ½æ¨¡ç³ŠåŒ¹é…
                                            logger.info(f"ğŸ” ç²¾ç¡®åŒ¹é…å¤±è´¥ï¼Œå°è¯•æ™ºèƒ½æ¨¡ç³ŠåŒ¹é…: {expected_filename}")

                                            # å¤šç§åŒ¹é…ç­–ç•¥
                                            found_file = None

                                            # ç­–ç•¥1: æŒ‰ç¼–å·åŒ¹é…ï¼ˆæœ€å®½æ¾ï¼‰
                                            matching_files = list(playlist_path.glob(f"{i:02d}.*"))
                                            if not matching_files:
                                                matching_files = list(playlist_path.glob(f"{i}.*"))

                                            if matching_files:
                                                found_file = matching_files[0]
                                                logger.info(f"âœ… é€šè¿‡ç¼–å·åŒ¹é…æ‰¾åˆ°æ–‡ä»¶: {found_file.name}")
                                            else:
                                                # ç­–ç•¥2: æŒ‰æ ‡é¢˜å…³é”®è¯åŒ¹é…
                                                # æå–æ ‡é¢˜çš„å‰å‡ ä¸ªå…³é”®è¯
                                                title_words = re.findall(r'[\u4e00-\u9fff]+|[a-zA-Z]+', title)
                                                if title_words and len(title_words) >= 2:
                                                    # ä½¿ç”¨å‰ä¸¤ä¸ªå…³é”®è¯æœç´¢
                                                    keyword1 = title_words[0][:10]  # é™åˆ¶é•¿åº¦
                                                    keyword2 = title_words[1][:10] if len(title_words) > 1 else ""

                                                    for file_path in playlist_path.glob("*.mp4"):
                                                        if keyword1 in file_path.name and (not keyword2 or keyword2 in file_path.name):
                                                            found_file = file_path
                                                            logger.info(f"âœ… é€šè¿‡å…³é”®è¯åŒ¹é…æ‰¾åˆ°æ–‡ä»¶: {found_file.name}")
                                                            break

                                            if found_file:
                                                # æ‰¾åˆ°åŒ¹é…çš„æ–‡ä»¶
                                                file_size = (
                                                    found_file.stat().st_size
                                                    / (1024 * 1024)
                                                )  # MB
                                                downloaded_files.append(
                                                    {
                                                        "filename": found_file.name,
                                                        "path": str(found_file),
                                                        "size_mb": file_size,
                                                        "playlist": stat["title"],
                                                        "video_title": title,
                                                    }
                                                )
                                                logger.info(
                                                    f"âœ… é€šè¿‡æ™ºèƒ½åŒ¹é…æ‰¾åˆ°æ–‡ä»¶: {found_file.name} ({file_size:.2f}MB)"
                                                )
                                            else:
                                                logger.warning(
                                                    f"âš ï¸ æ¨¡ç³ŠåŒ¹é…ä¹Ÿæœªæ‰¾åˆ°æ–‡ä»¶ï¼Œç¼–å·: {i}, æ ‡é¢˜: {safe_title}"
                                                )
                    except Exception as e:
                        logger.warning(f"âš ï¸ è·å–æ’­æ”¾åˆ—è¡¨ä¿¡æ¯å¤±è´¥ (ID: {playlist_id}): {e}")
                        logger.info(f"ğŸ’¡ è¿™é€šå¸¸æ˜¯å› ä¸ºæ’­æ”¾åˆ—è¡¨å·²è¢«åˆ é™¤æˆ–è®¾ä¸ºç§æœ‰ï¼Œä¸å½±å“å·²ä¸‹è½½çš„æ–‡ä»¶")
                        logger.info(f"ğŸ”„ å›é€€åˆ°ç›®å½•æ‰«ææ¨¡å¼æ¥ç»Ÿè®¡æ–‡ä»¶...")
                        # å¦‚æœè·å–åˆ—è¡¨å¤±è´¥ï¼Œå›é€€åˆ°æ‰«æç›®å½•
                        video_files = (
                            list(playlist_path.glob("*.mp4"))
                            + list(playlist_path.glob("*.mkv"))
                            + list(playlist_path.glob("*.webm"))
                        )
                        for video_file in video_files:
                            file_size = video_file.stat().st_size / (1024 * 1024)  # MB
                            downloaded_files.append(
                                {
                                    "filename": video_file.name,
                                    "path": str(video_file),
                                    "size_mb": file_size,
                                    "playlist": stat["title"],
                                }
                            )

            # è®¡ç®—æ€»æ–‡ä»¶å¤§å°å’ŒPARTæ–‡ä»¶ç»Ÿè®¡
            total_size_mb = sum(stat['total_size_mb'] for stat in playlist_stats)
            total_size_gb = total_size_mb / 1024

            # è®¡ç®—æ€»çš„æˆåŠŸå’Œæœªå®Œæˆæ–‡ä»¶æ•°é‡
            total_success_count = sum(stat.get('success_count', stat.get('video_count', 0)) for stat in playlist_stats)
            total_part_count = sum(stat.get('part_count', 0) for stat in playlist_stats)

            # è®¡ç®—æ€»è®¡æ•°é‡å’Œå¤±è´¥æ•°é‡
            total_video_count = sum(stat.get('video_count', 0) for stat in playlist_stats)
            total_failed_count = total_video_count - total_success_count

            # æ ¼å¼åŒ–æ€»å¤§å°æ˜¾ç¤º - åªæ˜¾ç¤ºä¸€ä¸ªå•ä½
            if total_size_gb >= 1.0:
                total_size_str = f"{total_size_gb:.2f}GB"
            else:
                total_size_str = f"{total_size_mb:.2f}MB"

            # è®¡ç®—æˆåŠŸç‡
            if total_video_count > 0:
                success_rate = (total_success_count / total_video_count) * 100
            else:
                success_rate = 0.0

            # æ„å»ºå®Œæˆæ¶ˆæ¯
            completion_text = (
                f"ğŸ“º YouTubeé¢‘é“æ’­æ”¾åˆ—è¡¨ä¸‹è½½å®Œæˆ\n\n"
                f"ğŸ“º é¢‘é“: {channel_name}\n"
                f"ğŸ“Š æ’­æ”¾åˆ—è¡¨æ•°é‡: {len(downloaded_playlists)}\n\n"
                f"å·²ä¸‹è½½çš„æ’­æ”¾åˆ—è¡¨:\n\n"
            )

            for i, stat in enumerate(playlist_stats, 1):
                completion_text += (
                    f"    {i}. {stat['title']} ({stat['video_count']} é›†)\n"
                )

            # æ„å»ºä¸‹è½½ç»Ÿè®¡ä¿¡æ¯
            stats_text = f"æ€»è®¡: {total_video_count} ä¸ª\nâœ… æˆåŠŸ: {total_success_count} ä¸ª\nâŒ å¤±è´¥: {total_failed_count} ä¸ª\nğŸ“ŠæˆåŠŸç‡: {success_rate:.1f}%"

            if total_part_count > 0:
                stats_text += f"\nâš ï¸ æœªå®Œæˆ: {total_part_count} ä¸ª"
                stats_text += f"\nğŸ’¡ æç¤º: å‘ç°æœªå®Œæˆæ–‡ä»¶ï¼Œå¯èƒ½éœ€è¦é‡æ–°ä¸‹è½½"

            # æ·»åŠ ç»Ÿè®¡ä¿¡æ¯ã€æ€»å¤§å°å’Œä¿å­˜ä½ç½®ï¼ˆåœ¨æ–‡ä»¶æ€»å¤§å°å‰åŠ ç©ºè¡Œï¼‰
            completion_text += (
                f"\nğŸ“Š ä¸‹è½½ç»Ÿè®¡:\n{stats_text}\n\n"
                f"ğŸ’¾ æ–‡ä»¶æ€»å¤§å°: {total_size_str}\n"
                f"ğŸ“‚ ä¿å­˜ä½ç½®: {channel_path}"
            )

            if message_updater:
                try:
                    if asyncio.iscoroutinefunction(message_updater):
                        await message_updater(completion_text)
                    else:
                        message_updater(completion_text)
                except Exception as e:
                    logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")

            return {
                "success": True,
                "is_channel": True,
                "channel_title": channel_name,
                    "download_path": str(channel_path),
                    "playlists_downloaded": downloaded_playlists,
                    "playlist_stats": playlist_stats,
                    "total_videos": total_videos,
                    "total_size_mb": total_size_mb,
                    "downloaded_files": downloaded_files,
                }

        except Exception as e:
            logger.error(f"âŒ YouTubeé¢‘é“æ’­æ”¾åˆ—è¡¨ä¸‹è½½å¤±è´¥: {e}")
            import traceback

            logger.error(f"è¯¦ç»†é”™è¯¯ä¿¡æ¯: {traceback.format_exc()}")
            if message_updater:
                try:
                    if asyncio.iscoroutinefunction(message_updater):
                        await message_updater(f"âŒ ä¸‹è½½å¤±è´¥: {str(e)}")
                    else:
                        message_updater(f"âŒ ä¸‹è½½å¤±è´¥: {str(e)}")
                except Exception as e2:
                    logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e2}")
            return {"success": False, "error": str(e)}

    def smart_download_bilibili(
        self, url: str, download_path: str, progress_callback=None, auto_playlist=False
    ):
        """æ™ºèƒ½ä¸‹è½½Bç«™è§†é¢‘ï¼Œæ”¯æŒå•è§†é¢‘ã€åˆ†é›†ã€åˆé›†"""
        import re
        import subprocess
        import os
        import threading
        import asyncio
        from pathlib import Path

        logger.info(f"ğŸ¬ å¼€å§‹æ™ºèƒ½ä¸‹è½½Bç«™è§†é¢‘: {url}")
        logger.info(f"ğŸ“ ä¸‹è½½è·¯å¾„: {download_path}")
        logger.info(f"ğŸ”„ è‡ªåŠ¨ä¸‹è½½å…¨é›†: {auto_playlist}")

        # ä¿å­˜åŸå§‹å·¥ä½œç›®å½•
        original_cwd = os.getcwd()
        logger.info(f"ğŸ“ åŸå§‹å·¥ä½œç›®å½•: {original_cwd}")

        try:
            # æ£€æŸ¥æ˜¯å¦ä¸ºBç«™ç”¨æˆ·åˆ—è¡¨URL
            is_list, uid, list_id = self.is_bilibili_list_url(url)
            if is_list:
                logger.info(f"ğŸ“‹ æ£€æµ‹åˆ°Bç«™ç”¨æˆ·åˆ—è¡¨: UID={uid}, ListID={list_id}")

                # ä½¿ç”¨BVå·å¾ªç¯æ³•ä¸‹è½½ç”¨æˆ·åˆ—è¡¨
                bv_list = self.get_bilibili_list_videos(uid, list_id)
                if not bv_list:
                    return {"status": "failure", "error": "æ— æ³•è·å–ç”¨æˆ·åˆ—è¡¨è§†é¢‘ä¿¡æ¯"}

                logger.info(f"ğŸ“‹ è·å–åˆ° {len(bv_list)} ä¸ªè§†é¢‘")

                # è·å–åˆ—è¡¨æ ‡é¢˜
                try:
                    list_info = self.get_bilibili_list_info(uid, list_id)
                    playlist_title = list_info.get("title", f"BilibiliList-{list_id}")
                except BaseException:
                    playlist_title = f"BilibiliList-{list_id}"
                safe_playlist_title = re.sub(
                    r'[\\/:*?"<>|]', "_", playlist_title
                ).strip()
                final_download_path = Path(download_path) / safe_playlist_title
                final_download_path.mkdir(parents=True, exist_ok=True)
                logger.info(f"ğŸ“ ä¸ºåˆé›†åˆ›å»ºä¸‹è½½ç›®å½•: {final_download_path}")
                # ä½¿ç”¨yt-dlp printè®°å½•æ–‡ä»¶åçš„æ–¹æ¡ˆï¼ˆä¸å¤šPä¸‹è½½ä¿æŒä¸€è‡´ï¼‰
                success_count = 0
                downloaded_files = []  # è®°å½•å®é™…ä¸‹è½½çš„æ–‡ä»¶ä¿¡æ¯

                for idx, (bv, title) in enumerate(bv_list, 1):
                    safe_title = re.sub(r'[\\/:*?"<>|]', "", title)[:60]
                    # ä½¿ç”¨ç»å¯¹è·¯å¾„æ„å»ºè¾“å‡ºæ¨¡æ¿
                    outtmpl = str(
                        final_download_path / f"{idx:02d}. {safe_title}.%(ext)s"
                    )

                    # æ›´æ–°ä¸‹è½½è¿›åº¦æ˜¾ç¤º
                    if progress_callback:
                        progress_callback({
                            'status': 'downloading',
                            'filename': f'{idx:02d}. {safe_title}',
                            '_percent_str': f'{idx}/{len(bv_list)}',
                            '_eta_str': f'ç¬¬{idx}ä¸ªï¼Œå…±{len(bv_list)}ä¸ª',
                            'info_dict': {'title': title}
                        })

                    # 1. å…ˆç”¨yt-dlp printè·å–å®é™…æ–‡ä»¶å
                    video_url = f"https://www.bilibili.com/video/{bv}"
                    cmd_print = [
                        "yt-dlp", "--print", "filename", "-o", outtmpl, video_url
                    ]

                    try:
                        print_result = subprocess.run(cmd_print, capture_output=True, text=True, cwd=str(final_download_path))
                        if print_result.returncode == 0:
                            full_expected_path = print_result.stdout.strip()
                            # åªä¿ç•™æ–‡ä»¶åéƒ¨åˆ†ï¼Œä¸åŒ…å«è·¯å¾„
                            expected_filename = os.path.basename(full_expected_path)
                            logger.info(f"ğŸ“ é¢„æœŸæ–‡ä»¶å: {expected_filename}")
                        else:
                            # å¦‚æœprintå¤±è´¥ï¼Œä½¿ç”¨æ„é€ çš„æ–‡ä»¶å
                            expected_filename = f"{idx:02d}. {safe_title}.mp4"
                            logger.warning(f"âš ï¸ printæ–‡ä»¶åå¤±è´¥ï¼Œä½¿ç”¨æ„é€ æ–‡ä»¶å: {expected_filename}")
                    except Exception as e:
                        expected_filename = f"{idx:02d}. {safe_title}.mp4"
                        logger.warning(f"âš ï¸ printæ–‡ä»¶åå¼‚å¸¸: {e}ï¼Œä½¿ç”¨æ„é€ æ–‡ä»¶å: {expected_filename}")

                    # 2. æ‰§è¡Œä¸‹è½½ï¼ˆä½¿ç”¨yt-dlp Python APIæ”¯æŒè¿›åº¦å›è°ƒï¼‰
                    # åˆ›å»ºå®‰å…¨çš„è¿›åº¦å›è°ƒå‡½æ•°ï¼Œé¿å… 'NoneType' object is not callable é”™è¯¯
                    def safe_progress_hook(d):
                        try:
                            if progress_callback and callable(progress_callback):
                                if asyncio.iscoroutinefunction(progress_callback):
                                    # å¼‚æ­¥å‡½æ•°å¤„ç†
                                    try:
                                        loop = asyncio.get_running_loop()
                                        asyncio.run_coroutine_threadsafe(progress_callback(d), loop)
                                    except RuntimeError:
                                        logger.warning("æ²¡æœ‰è¿è¡Œçš„äº‹ä»¶å¾ªç¯ï¼Œè·³è¿‡å¼‚æ­¥è¿›åº¦å›è°ƒ")
                                else:
                                    # åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                                    progress_callback(d)
                            # å¦‚æœprogress_callbackä¸ºNoneæˆ–ä¸å¯è°ƒç”¨ï¼Œé™é»˜å¿½ç•¥
                        except Exception as e:
                            logger.error(f"Bç«™ä¸‹è½½è¿›åº¦å›è°ƒé”™è¯¯: {e}")
                    
                    ydl_opts_single = {
                        'outtmpl': outtmpl,
                        'merge_output_format': 'mp4',
                        'quiet': False,
                        'no_warnings': False,
                        'progress_hooks': [safe_progress_hook],
                        # ğŸ¯ Bç«™4Kæ”¯æŒï¼šä½¿ç”¨å¤šç­–ç•¥æ ¼å¼é€‰æ‹©ï¼Œä¼˜å…ˆ4Kï¼Œå›é€€åˆ°ä¼šå‘˜/éä¼šå‘˜å¯ç”¨æ ¼å¼
                        'format': self._get_bilibili_best_format(),
                    }

                    # æ·»åŠ ä»£ç†å’Œcookiesé…ç½®
                    if self.proxy_host:
                        ydl_opts_single['proxy'] = self.proxy_host
                if self.b_cookies_path and os.path.exists(self.b_cookies_path):
                    ydl_opts_single['cookiefile'] = self.b_cookies_path

                    logger.info(f"ğŸš€ ä¸‹è½½ç¬¬{idx}ä¸ª: {bv} - {title}")
                    logger.info(f"ğŸ“ æ–‡ä»¶åæ¨¡æ¿: {outtmpl}")

                    try:
                        # ä½¿ç”¨yt-dlp Python APIï¼Œæ”¯æŒè¿›åº¦å›è°ƒ
                        with yt_dlp.YoutubeDL(ydl_opts_single) as ydl:
                            ydl.download([video_url])
                        success_count += 1
                        logger.info(f"âœ… ç¬¬{idx}ä¸ªä¸‹è½½æˆåŠŸ")

                        # 3. æ ¹æ®é¢„æœŸæ–‡ä»¶åæŸ¥æ‰¾å®é™…æ–‡ä»¶
                        expected_path = final_download_path / expected_filename
                        if expected_path.exists():
                            size_mb = os.path.getsize(expected_path) / (1024 * 1024)
                            media_info = self.get_media_info(str(expected_path))
                            downloaded_files.append({
                                'filename': expected_filename,
                                'size_mb': size_mb,
                                'resolution': media_info.get('resolution', 'æœªçŸ¥'),
                                'abr': media_info.get('bit_rate')
                            })
                            logger.info(f"ğŸ“ è®°å½•æ–‡ä»¶: {expected_filename} ({size_mb:.1f}MB)")
                        else:
                            logger.warning(f"âš ï¸ é¢„æœŸæ–‡ä»¶ä¸å­˜åœ¨: {expected_filename}")
                    except Exception as e:
                        logger.error(f"âŒ ç¬¬{idx}ä¸ªä¸‹è½½å¤±è´¥: {e}")

                logger.info(
                    f"ğŸ‰ BVå·å¾ªç¯æ³•ä¸‹è½½å®Œæˆ: {success_count}/{len(bv_list)} ä¸ªæˆåŠŸ"
                )

                if success_count > 0:
                    # ä½¿ç”¨å·²è®°å½•çš„æ–‡ä»¶ä¿¡æ¯ï¼ˆä¸éå†ç›®å½•ï¼‰
                    total_size_mb = sum(file_info['size_mb'] for file_info in downloaded_files)
                    all_resolutions = {file_info['resolution'] for file_info in downloaded_files if file_info['resolution'] != 'æœªçŸ¥'}

                    filename_list = [info['filename'] for info in downloaded_files]
                    filename_display = '\n'.join([f"  {i+1:02d}. {name}" for i, name in enumerate(filename_list)])
                    resolution_display = ', '.join(sorted(all_resolutions)) if all_resolutions else 'æœªçŸ¥'

                    logger.info(f"ğŸ“Š ç”¨æˆ·åˆ—è¡¨ä¸‹è½½ç»Ÿè®¡: {len(downloaded_files)}ä¸ªæ–‡ä»¶, æ€»å¤§å°{total_size_mb:.1f}MB")

                    return {
                        "status": "success",
                        "video_type": "playlist",
                        "count": success_count,
                        "playlist_title": safe_playlist_title,
                        "download_path": str(final_download_path),
                        # ä½¿ç”¨é¢„æœŸæ–‡ä»¶ä¿¡æ¯ï¼Œé¿å…ç›®å½•éå†
                        "is_playlist": True,
                        "file_count": len(downloaded_files),
                        "total_size_mb": total_size_mb,
                        "files": downloaded_files,
                        "platform": "bilibili",
                        "filename": filename_display,
                        "size_mb": total_size_mb,
                        "resolution": resolution_display,
                        "episode_count": len(downloaded_files)
                    }
                else:
                    return {"status": "failure", "error": "ç”¨æˆ·åˆ—è¡¨è§†é¢‘å…¨éƒ¨ä¸‹è½½å¤±è´¥"}
            # ä¸‹é¢æ˜¯åŸæœ‰çš„Bç«™å•è§†é¢‘/åˆé›†/åˆ†é›†ä¸‹è½½é€»è¾‘
            logger.info(f"ğŸ” æ­£åœ¨æ£€æŸ¥è§†é¢‘ç±»å‹: {url}")

            # å¤„ç†çŸ­é“¾æ¥ï¼Œæå–BVå·
            original_url = url
            if "b23.tv" in url or "b23.wtf" in url:
                logger.info("ğŸ”„ æ£€æµ‹åˆ°Bç«™çŸ­é“¾æ¥ï¼Œå°è¯•æå–BVå·...")
                try:
                    # å…ˆè·å–é‡å®šå‘åçš„URL
                    temp_opts = {
                        "quiet": True,
                        "no_warnings": True,
                    }
                    with yt_dlp.YoutubeDL(temp_opts) as ydl:
                        temp_info = ydl.extract_info(url, download=False)

                    if temp_info.get("webpage_url"):
                        redirected_url = temp_info["webpage_url"]
                        logger.info(f"ğŸ”„ çŸ­é“¾æ¥é‡å®šå‘åˆ°: {redirected_url}")

                        # ä»é‡å®šå‘URLä¸­æå–BVå·
                        bv_match = re.search(r"BV[0-9A-Za-z]+", redirected_url)
                        if bv_match:
                            bv_id = bv_match.group()
                            # æ„é€ åŸå§‹é“¾æ¥ï¼ˆä¸å¸¦åˆ†Pæ ‡è¯†ï¼‰
                            original_url = f"https://www.bilibili.com/video/{bv_id}/"
                            logger.info(f"ğŸ”„ æå–åˆ°BVå·: {bv_id}")
                            logger.info(f"ğŸ”„ ä½¿ç”¨åŸå§‹é“¾æ¥: {original_url}")
                        else:
                            logger.warning("âš ï¸ æ— æ³•ä»é‡å®šå‘URLä¸­æå–BVå·")
                    else:
                        logger.warning("âš ï¸ çŸ­é“¾æ¥é‡å®šå‘å¤±è´¥")
                except Exception as e:
                    logger.warning(f"âš ï¸ å¤„ç†çŸ­é“¾æ¥æ—¶å‡ºé”™: {e}")

            # ä¿®æ”¹æ£€æµ‹é€»è¾‘ï¼Œç¡®ä¿èƒ½æ­£ç¡®è¯†åˆ«å¤šPè§†é¢‘
            if auto_playlist:
                # å¼€å¯è‡ªåŠ¨ä¸‹è½½å…¨é›†æ—¶ï¼Œå¼ºåˆ¶æ£€æµ‹playlist
                check_opts = {
                    "quiet": True,
                    "flat_playlist": True,
                    "extract_flat": True,
                    "print": "%(id)s %(title)s",
                    "noplaylist": False,  # å…³é”®ï¼šä¸é˜»æ­¢playlistæ£€æµ‹
                    "yes_playlist": True,  # å…³é”®ï¼šå…è®¸playlistæ£€æµ‹
                    "extract_flat": True,  # ç¡®ä¿æå–æ‰€æœ‰æ¡ç›®
                }
            else:
                # å…³é—­è‡ªåŠ¨ä¸‹è½½å…¨é›†æ—¶ï¼Œé˜»æ­¢playlistæ£€æµ‹
                check_opts = {
                    "quiet": True,
                    "flat_playlist": True,
                    "extract_flat": True,
                    "print": "%(id)s %(title)s",
                    "noplaylist": True,  # é˜»æ­¢playlistæ£€æµ‹
                }

            # ä½¿ç”¨å¤„ç†åçš„URLè¿›è¡Œæ£€æµ‹
            with yt_dlp.YoutubeDL(check_opts) as ydl:
                info = ydl.extract_info(original_url, download=False)

            entries = info.get("entries", [])
            count = len(entries) if entries else 1
            logger.info(f"ğŸ“‹ æ£€æµ‹åˆ° {count} ä¸ªè§†é¢‘")

            # å¦‚æœåªæœ‰ä¸€ä¸ªè§†é¢‘ï¼Œå°è¯•anthologyæ£€æµ‹å’Œå¼ºåˆ¶playlistæ£€æµ‹
            if count == 1:
                # ç‰¹æ®Šæ£€æµ‹ï¼šä½¿ç”¨æ¨¡æ‹Ÿä¸‹è½½æ£€æµ‹anthology
                logger.info("ğŸ” ä½¿ç”¨æ¨¡æ‹Ÿä¸‹è½½æ£€æµ‹anthology...")
                anthology_detected = False
                try:
                    # æ•è·yt-dlpçš„è¾“å‡ºæ¥æ£€æµ‹anthology
                    cmd_simulate = ['yt-dlp', '--simulate', '--verbose', original_url]
                    result = subprocess.run(cmd_simulate, capture_output=True, text=True)
                    output = result.stdout + result.stderr

                    if 'extracting videos in anthology' in output.lower():
                        anthology_detected = True
                        logger.info("âœ… æ£€æµ‹åˆ°anthologyå…³é”®è¯ï¼Œè¿™æ˜¯ä¸€ä¸ªåˆé›†")
                    else:
                        logger.info("âŒ æœªæ£€æµ‹åˆ°anthologyå…³é”®è¯")

                except Exception as e:
                    logger.warning(f"âš ï¸ anthologyæ£€æµ‹å¤±è´¥: {e}")

                # å¦‚æœæ£€æµ‹åˆ°anthologyæˆ–å¼€å¯äº†auto_playlistï¼Œå°è¯•å¼ºåˆ¶æ£€æµ‹playlist
                if anthology_detected or auto_playlist:
                    if anthology_detected:
                        logger.info("ğŸ”„ æ£€æµ‹åˆ°anthologyï¼Œå¼ºåˆ¶ä½¿ç”¨åˆé›†æ¨¡å¼")
                    else:
                        logger.info("ğŸ”„ å¼€å¯è‡ªåŠ¨ä¸‹è½½å…¨é›†ï¼Œå°è¯•å¼ºåˆ¶æ£€æµ‹playlist...")

                    force_check_opts = {
                        "quiet": True,
                        "flat_playlist": True,
                        "extract_flat": True,
                        "print": "%(id)s %(title)s",
                        "noplaylist": False,
                        "yes_playlist": True,
                    }

                    try:
                        with yt_dlp.YoutubeDL(force_check_opts) as ydl:
                            force_info = ydl.extract_info(original_url, download=False)
                        force_entries = force_info.get("entries", [])
                        force_count = len(force_entries) if force_entries else 1

                        if force_count > count:
                            logger.info(f"ğŸ”„ å¼ºåˆ¶æ£€æµ‹æˆåŠŸï¼æ£€æµ‹åˆ° {force_count} ä¸ªè§†é¢‘")
                            entries = force_entries
                            count = force_count
                            info = force_info
                        elif anthology_detected:
                            # æ£€æµ‹åˆ°anthologyï¼Œä½†éœ€è¦è¿›ä¸€æ­¥ç¡®è®¤æ˜¯å¦çœŸçš„æ˜¯å¤šé›†
                            logger.info("ğŸ”„ anthologyæ£€æµ‹æˆåŠŸï¼Œä½†éœ€è¦ç¡®è®¤æ˜¯å¦çœŸçš„æ˜¯å¤šé›†")
                            # ä¸å¼ºåˆ¶è®¾ç½®countï¼Œä¿æŒåŸæœ‰çš„æ£€æµ‹ç»“æœ
                            if count <= 1:
                                logger.info("ğŸ” anthologyæ£€æµ‹åˆ°ï¼Œä½†å®é™…åªæœ‰1é›†ï¼ŒæŒ‰å•é›†å¤„ç†")
                            else:
                                logger.info(f"ğŸ” anthologyæ£€æµ‹åˆ°ï¼Œç¡®è®¤æœ‰{count}é›†ï¼ŒæŒ‰åˆé›†å¤„ç†")
                    except Exception as e:
                        logger.warning(f"âš ï¸ å¼ºåˆ¶æ£€æµ‹å¤±è´¥: {e}")
                        if anthology_detected:
                            # å¦‚æœanthologyæ£€æµ‹æˆåŠŸä½†å¼ºåˆ¶æ£€æµ‹å¤±è´¥ï¼Œéœ€è¦è°¨æ…å¤„ç†
                            logger.info("ğŸ”„ anthologyæ£€æµ‹æˆåŠŸï¼Œä½†å¼ºåˆ¶æ£€æµ‹å¤±è´¥ï¼ŒæŒ‰å®é™…æ£€æµ‹ç»“æœå¤„ç†")
                            # ä¸å¼ºåˆ¶è®¾ç½®countï¼Œä¿æŒåŸæœ‰çš„æ£€æµ‹ç»“æœ
                            if count <= 1:
                                logger.info("ğŸ” anthologyæ£€æµ‹åˆ°ä½†å¼ºåˆ¶æ£€æµ‹å¤±è´¥ï¼Œä¸”å®é™…åªæœ‰1é›†ï¼ŒæŒ‰å•é›†å¤„ç†")
                            else:
                                logger.info(f"ğŸ” anthologyæ£€æµ‹åˆ°ï¼Œå®é™…æœ‰{count}é›†ï¼ŒæŒ‰åˆé›†å¤„ç†")
            playlist_title = info.get("title", "Unknown Playlist")
            safe_playlist_title = re.sub(r'[\\/:*?"<>|]', "_", playlist_title).strip()

            if count > 1 and auto_playlist:
                final_download_path = Path(download_path) / safe_playlist_title
                final_download_path.mkdir(parents=True, exist_ok=True)
                logger.info(
                    f"ğŸ“ ä¸ºåˆé›† '{safe_playlist_title}' åˆ›å»ºä¸‹è½½ç›®å½•: {final_download_path}"
                )
            else:
                final_download_path = Path(download_path)
                logger.info(f"ğŸ“ ä½¿ç”¨é»˜è®¤ä¸‹è½½ç›®å½•: {final_download_path}")
            # ç§»é™¤ os.chdir() è°ƒç”¨ï¼Œä½¿ç”¨ç»å¯¹è·¯å¾„

            if count == 1:
                video_type = "single"
                logger.info("ğŸ¬ æ£€æµ‹åˆ°å•è§†é¢‘")
            else:
                first_id = entries[0].get("id", "") if entries else ""
                all_same_id = all(
                    entry.get("id", "") == first_id for entry in entries if entry
                )
                if all_same_id:
                    video_type = "episodes"
                    logger.info(f"ğŸ“º æ£€æµ‹åˆ°åˆ†é›†è§†é¢‘ï¼Œå…± {count} é›†")
                    logger.info("ğŸ“‹ åˆ†é›†è¯¦æƒ…:")
                    for i, entry in enumerate(entries, 1):
                        if entry:
                            episode_title = entry.get("title", "unknown")
                            episode_id = entry.get("id", "unknown")
                            logger.info(
                                f"  {i:02d}. {episode_title} (ID: {episode_id})"
                            )
                else:
                    video_type = "playlist"
                    logger.info(f"ğŸ“š æ£€æµ‹åˆ°åˆé›†ï¼Œå…± {count} ä¸ªè§†é¢‘")
                    logger.info("ğŸ“‹ åˆé›†è¯¦æƒ…:")
                    for i, entry in enumerate(entries, 1):
                        if entry:
                            video_title = entry.get("title", "unknown")
                            video_id = entry.get("id", "unknown")
                            logger.info(f"  {i:02d}. {video_title} (ID: {video_id})")

            # æ ¹æ®è§†é¢‘ç±»å‹å†³å®šä¸‹è½½ç­–ç•¥
            if video_type == "single":
                # smart_download_bilibili ä¸“é—¨å¤„ç†å¤šPå’Œåˆé›†ï¼Œå•è§†é¢‘åº”è¯¥ç”±é€šç”¨ä¸‹è½½å™¨å¤„ç†
                logger.info("âš ï¸ smart_download_bilibili æ£€æµ‹åˆ°å•è§†é¢‘")
                if auto_playlist:
                    logger.info("ğŸ’¡ è™½ç„¶å¼€å¯äº†è‡ªåŠ¨ä¸‹è½½å…¨é›†ï¼Œä½†è¿™ç¡®å®æ˜¯å•è§†é¢‘ï¼Œå»ºè®®ä½¿ç”¨é€šç”¨ä¸‹è½½å™¨")
                else:
                    logger.info("ğŸ’¡ è¿™æ˜¯å•è§†é¢‘ï¼Œå»ºè®®ä½¿ç”¨é€šç”¨ä¸‹è½½å™¨")

                # è¿”å›ç‰¹æ®ŠçŠ¶æ€ï¼Œè®©è°ƒç”¨æ–¹çŸ¥é“è¿™æ˜¯å•è§†é¢‘
                return {
                    "status": "single_video",
                    "message": "è¿™æ˜¯å•è§†é¢‘ï¼Œå»ºè®®ä½¿ç”¨é€šç”¨ä¸‹è½½å™¨",
                    "video_type": "single"
                }
            elif video_type == "episodes":
                if auto_playlist:
                    # è‡ªåŠ¨ä¸‹è½½å…¨é›† - ç›´æ¥ä½¿ç”¨å®Œæ•´æ ‡é¢˜ï¼Œä¸åšå¤æ‚å¤„ç†
                    output_template = str(
                        final_download_path / "%(title)s.%(ext)s"
                    )
                    # æ·»åŠ æ˜æ˜¾çš„outtmplæ—¥å¿—
                    logger.info(
                        f"ğŸ”§ [BILIBILI_EPISODES] outtmpl ä½¿ç”¨å®Œæ•´æ ‡é¢˜: {output_template}"
                    )

                    # åˆ›å»ºç®€å•çš„è¿›åº¦å›è°ƒï¼Œä¸éœ€è¦é‡å‘½å
                    def enhanced_progress_callback(d):
                        # æ‰§è¡ŒåŸæœ‰çš„è¿›åº¦å›è°ƒé€»è¾‘ï¼ˆæ˜¾ç¤ºå®Œæ•´æ ‡é¢˜ï¼‰
                        if progress_callback:
                            progress_callback(d)

                    ydl_opts = {
                        "outtmpl": output_template,
                        "merge_output_format": "mp4",
                        "quiet": False,
                        "yes_playlist": True,
                        "extract_flat": False,
                        "progress_hooks": [enhanced_progress_callback],
                        # ğŸ¯ Bç«™4Kæ”¯æŒï¼šä½¿ç”¨å¤šç­–ç•¥æ ¼å¼é€‰æ‹©ï¼Œä¼˜å…ˆ4Kï¼Œå›é€€åˆ°ä¼šå‘˜/éä¼šå‘˜å¯ç”¨æ ¼å¼
                        "format": self._get_bilibili_best_format(),
                    }
                    logger.info("ğŸ”„ è‡ªåŠ¨ä¸‹è½½å…¨é›†æ¨¡å¼ï¼šå°†ä¸‹è½½æ‰€æœ‰åˆ†Pè§†é¢‘")
                else:
                    # åªä¸‹è½½å½“å‰åˆ†P
                    output_template = str(final_download_path / "%(title)s.%(ext)s")
                    # æ·»åŠ æ˜æ˜¾çš„outtmplæ—¥å¿—
                    logger.info(
                        f"ğŸ”§ [BILIBILI_SINGLE_EPISODE] outtmpl ç»å¯¹è·¯å¾„: {output_template}"
                    )
                    ydl_opts = {
                        "outtmpl": output_template,
                        "merge_output_format": "mp4",
                        "quiet": False,
                        "noplaylist": True,
                        "progress_hooks": [
                            lambda d: (
                                progress_callback(d) if progress_callback else None
                            )
                        ],
                        # ğŸ¯ Bç«™4Kæ”¯æŒï¼šä½¿ç”¨å¤šç­–ç•¥æ ¼å¼é€‰æ‹©ï¼Œä¼˜å…ˆ4Kï¼Œå›é€€åˆ°ä¼šå‘˜/éä¼šå‘˜å¯ç”¨æ ¼å¼
                        "format": self._get_bilibili_best_format(),
                    }
                    logger.info("ğŸ”„ å•Pæ¨¡å¼ï¼šåªä¸‹è½½å½“å‰åˆ†Pè§†é¢‘")
            else:  # playlist - å’Œå¤šPä¸‹è½½ä¸€æ ·ç®€å•
                # å¯¹äºåˆé›†ï¼Œç›´æ¥ä½¿ç”¨yt-dlpæ’­æ”¾åˆ—è¡¨åŠŸèƒ½ï¼ˆå’Œå¤šPä¸‹è½½ä¸€æ ·ï¼‰
                logger.info(f"ğŸ”§ æ£€æµ‹åˆ°åˆé›†ï¼Œä½¿ç”¨yt-dlpæ’­æ”¾åˆ—è¡¨åŠŸèƒ½ä¸‹è½½")
                logger.info(f"   - è§†é¢‘æ•°é‡: {count}")

                # ä½¿ç”¨å’Œå¤šPä¸‹è½½å®Œå…¨ç›¸åŒçš„é€»è¾‘ï¼ŒBç«™ä¸ä½¿ç”¨IDæ ‡ç­¾
                output_template = str(
                    final_download_path / "%(playlist_index)s. %(title)s.%(ext)s"
                )
                logger.info(f"ğŸ”§ [BILIBILI_PLAYLIST] outtmpl ç»å¯¹è·¯å¾„: {output_template}")

                # ä½¿ç”¨å¢å¼ºç‰ˆè¿›åº¦å›è°ƒæ¥ç”Ÿæˆè¯¦ç»†çš„è¿›åº¦æ˜¾ç¤ºæ ¼å¼
                progress_data = {
                    "final_filename": None,
                    "lock": threading.Lock(),
                    "downloaded_files": [],  # æ·»åŠ ä¸‹è½½æ–‡ä»¶åˆ—è¡¨
                    "expected_files": []     # æ·»åŠ é¢„æœŸæ–‡ä»¶åˆ—è¡¨
                }

                # æ£€æŸ¥ progress_callback æ˜¯å¦æ˜¯å¢å¼ºç‰ˆè¿›åº¦å›è°ƒå‡½æ•°
                if callable(progress_callback) and progress_callback.__name__ == 'enhanced_progress_callback':
                    # å¦‚æœæ˜¯å¢å¼ºç‰ˆè¿›åº¦å›è°ƒï¼Œç›´æ¥ä½¿ç”¨å®ƒè¿”å›çš„ progress_hook
                    progress_hook = progress_callback(progress_data)
                else:
                    # å¦åˆ™ä½¿ç”¨æ ‡å‡†çš„ single_video_progress_hook
                    progress_hook = single_video_progress_hook(message_updater=progress_callback, progress_data=progress_data, status_message=status_message, context=context)

                ydl_opts = {
                    "outtmpl": output_template,
                    "merge_output_format": "mp4",
                    "quiet": False,
                    "yes_playlist": True,
                    "extract_flat": False,
                    "progress_hooks": [progress_hook],
                    # ğŸ¯ Bç«™4Kæ”¯æŒï¼šä½¿ç”¨å¤šç­–ç•¥æ ¼å¼é€‰æ‹©ï¼Œä¼˜å…ˆ4Kï¼Œå›é€€åˆ°ä¼šå‘˜/éä¼šå‘˜å¯ç”¨æ ¼å¼
                    "format": self._get_bilibili_best_format(),
                }
                logger.info("ğŸ”„ åˆé›†æ¨¡å¼ï¼šå°†ä¸‹è½½æ‰€æœ‰åˆé›†è§†é¢‘")

            # å¯¹äºå•è§†é¢‘å’Œåˆ†é›†è§†é¢‘ï¼Œä½¿ç”¨yt-dlpä¸‹è½½
            if video_type in ["single", "episodes"]:
                # æ·»åŠ ä»£ç†å’Œcookiesé…ç½®
                if self.proxy_host:
                    ydl_opts["proxy"] = self.proxy_host
                if self.b_cookies_path and os.path.exists(self.b_cookies_path):
                    ydl_opts["cookiefile"] = self.b_cookies_path
                    logger.info(f"ğŸª ä½¿ç”¨Bç«™cookies: {self.b_cookies_path}")
                else:
                    logger.warning("âš ï¸ æœªè®¾ç½®Bç«™cookiesï¼Œå¯èƒ½æ— æ³•ä¸‹è½½æŸäº›è§†é¢‘")
                    logger.warning("ğŸ’¡ è¯·è®¾ç½®BILIBILI_COOKIESç¯å¢ƒå˜é‡æŒ‡å‘cookiesæ–‡ä»¶")

                # ä¸ºBç«™æ·»åŠ æ›´å¼ºçš„é‡è¯•å’Œå»¶è¿Ÿæœºåˆ¶
                if self.is_bilibili_url(url):
                    ydl_opts.update({
                        "retries": 10,  # å¢åŠ é‡è¯•æ¬¡æ•°
                        "fragment_retries": 10,
                        "socket_timeout": 60,  # å¢åŠ è¶…æ—¶æ—¶é—´
                        "sleep_interval": 2,   # æ·»åŠ è¯·æ±‚é—´éš”
                        "max_sleep_interval": 5,
                        # æ·»åŠ æ›´è¯¦ç»†çš„é”™è¯¯å¤„ç†
                        "ignoreerrors": False,  # ä¸å¿½ç•¥é”™è¯¯ï¼Œä¾¿äºè°ƒè¯•
                    })
                    logger.info("ğŸ”§ ä¸ºBç«™é“¾æ¥å¯ç”¨å¢å¼ºé‡è¯•æœºåˆ¶")

                # æ·»åŠ å¼¹å¹•ä¸‹è½½é€‰é¡¹
                ydl_opts = self._add_danmaku_options(ydl_opts, url)

                # å¦‚æœæ˜¯Bç«™é“¾æ¥ä¸”å¼€å¯äº†å°é¢ä¸‹è½½ï¼Œæ·»åŠ ç¼©ç•¥å›¾ä¸‹è½½é€‰é¡¹
                if hasattr(self, 'bot') and hasattr(self.bot, 'bilibili_thumbnail_download') and self.bot.bilibili_thumbnail_download:
                    ydl_opts["writethumbnail"] = True
                    # æ·»åŠ ç¼©ç•¥å›¾æ ¼å¼è½¬æ¢åå¤„ç†å™¨ï¼šWebP -> JPG
                    if "postprocessors" not in ydl_opts:
                        ydl_opts["postprocessors"] = []
                    ydl_opts["postprocessors"].append({
                        'key': 'FFmpegThumbnailsConvertor',
                        'format': 'jpg',
                        'when': 'before_dl'
                    })
                    logger.info("ğŸ–¼ï¸ å¼€å¯Bç«™å°é¢ä¸‹è½½ï¼ˆè½¬æ¢ä¸ºJPGæ ¼å¼ï¼‰")

                logger.info(f"ğŸ”§ [BILIBILI_DOWNLOAD] æœ€ç»ˆydl_opts: {ydl_opts}")
                logger.info(f"ğŸ“ æœ€ç»ˆè¾“å‡ºæ¨¡æ¿: {output_template}")
                logger.info(f"ğŸ“ ä¸‹è½½ç›®å½•: {final_download_path}")

                # æ‰§è¡Œä¸‹è½½
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    ydl.download([original_url])

                logger.info("âœ… Bç«™è§†é¢‘ä¸‹è½½å®Œæˆ")
                logger.info("ğŸ¯ ä½¿ç”¨postprocessoræ™ºèƒ½æ–‡ä»¶åï¼Œæ— éœ€é‡å‘½å")

                # ç®€åŒ–ï¼šBç«™å¤šPä¸‹è½½å®Œæˆï¼Œç›´æ¥è¿”å›æˆåŠŸï¼Œæ–‡ä»¶æŸ¥æ‰¾äº¤ç»™ç›®å½•éå†
                logger.info("ğŸ¯ Bç«™å¤šPä¸‹è½½å®Œæˆï¼Œä½¿ç”¨ç›®å½•éå†æŸ¥æ‰¾æ–‡ä»¶")

                return {
                    "status": "success",
                    "video_type": video_type,
                    "count": count,
                    "playlist_title": safe_playlist_title if count > 1 else None,
                    "download_path": str(final_download_path),
                    # ç®€åŒ–ï¼šä¸ä¼ é€’é¢„æœŸæ–‡ä»¶ä¿¡æ¯ï¼Œä½¿ç”¨ç›®å½•éå†
                }

        except Exception as e:
            logger.error(f"âŒ Bç«™è§†é¢‘ä¸‹è½½å¤±è´¥: {e}")
            return {"status": "failure", "error": str(e)}
        finally:
            # æ¢å¤åŸå§‹å·¥ä½œç›®å½•
            try:
                os.chdir(original_cwd)
                logger.info(f"ğŸ“ å·²æ¢å¤å·¥ä½œç›®å½•: {original_cwd}")
            except Exception as e:
                logger.warning(f"âš ï¸ æ¢å¤å·¥ä½œç›®å½•å¤±è´¥: {e}")

    def get_bilibili_list_videos(self, uid: str, list_id: str) -> list:
        """
        é€šè¿‡Bç«™APIè·å–ç”¨æˆ·è‡ªå®šä¹‰åˆ—è¡¨ä¸­çš„è§†é¢‘

        Args:
            uid: ç”¨æˆ·ID (å¦‚ 477348669)
            list_id: åˆ—è¡¨ID (å¦‚ 2111173)

        Returns:
            list: [(bv, title), ...]
        """
        try:
            # Bç«™ç”¨æˆ·åˆ—è¡¨API
            api_url = f"https://api.bilibili.com/x/space/fav/season/list"
            params = {
                "season_id": list_id,
                "pn": 1,
                "ps": 20,  # æ¯é¡µ20ä¸ª
                "jsonp": "jsonp",
            }

            headers = {
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",
                "Referer": f"https://space.bilibili.com/{uid}/lists/{list_id}",
            }

            logger.info(f"ğŸ” è·å–Bç«™åˆ—è¡¨API: {api_url}")
            response = requests.get(api_url, params=params, headers=headers, timeout=10, verify=False)
            response.raise_for_status()

            data = response.json()
            if data.get("code") != 0:
                logger.error(f"âŒ APIè¿”å›é”™è¯¯: {data.get('message', 'æœªçŸ¥é”™è¯¯')}")
                return []

            # è§£æè§†é¢‘åˆ—è¡¨
            videos = []
            archives = data.get("data", {}).get("medias", [])

            for archive in archives:
                bv = archive.get("bvid", "")
                title = archive.get("title", "")
                if bv and title:
                    videos.append((bv, title))
                    logger.info(f"  ğŸ“º {bv}: {title}")

            logger.info(f"ğŸ“¦ ä»APIè·å–åˆ° {len(videos)} ä¸ªè§†é¢‘")
            return videos

        except Exception as e:
            logger.error(f"âŒ è·å–Bç«™åˆ—è¡¨å¤±è´¥: {e}")
            return []

    def download_bilibili_list_bv_method(
        self, uid: str, list_id: str, download_path: str
    ) -> bool:
        """
        ä½¿ç”¨BVå·å¾ªç¯æ³•ä¸‹è½½Bç«™ç”¨æˆ·è‡ªå®šä¹‰åˆ—è¡¨

        Args:
            uid: ç”¨æˆ·ID
            list_id: åˆ—è¡¨ID
            download_path: ä¸‹è½½è·¯å¾„

        Returns:
            bool: ä¸‹è½½æ˜¯å¦æˆåŠŸ
        """
        import subprocess
        import re

        logger.info(f"ğŸ”§ ä½¿ç”¨BVå·å¾ªç¯æ³•ä¸‹è½½Bç«™åˆ—è¡¨:")
        logger.info(f"   - ç”¨æˆ·ID: {uid}")
        logger.info(f"   - åˆ—è¡¨ID: {list_id}")

        # 1. é€šè¿‡APIè·å–è§†é¢‘åˆ—è¡¨
        bv_list = self.get_bilibili_list_videos(uid, list_id)

        if not bv_list:
            logger.error("âŒ æœªæ‰¾åˆ°ä»»ä½•è§†é¢‘")
            return False

        logger.info(f"ğŸ“¦ æ‰¾åˆ° {len(bv_list)} ä¸ªè§†é¢‘ï¼Œå¼€å§‹é€ä¸ªä¸‹è½½")

        # 2. ä¾æ¬¡ä¸‹è½½æ¯ä¸ªBVå·
        success_count = 0
        for idx, (bv, title) in enumerate(bv_list, 1):
            # æ¸…ç†æ ‡é¢˜ä¸­çš„éæ³•å­—ç¬¦
            safe_title = re.sub(r'[\\/:*?"<>|]', "", title)[:60]
            outtmpl = f"{idx:02d}. {safe_title}.%(ext)s"
            cmd_dl = [
                "yt-dlp",
                "-o",
                outtmpl,
                "--merge-output-format",
                "mp4",
                f"https://www.bilibili.com/video/{bv}",
            ]
            logger.info(f"ğŸš€ ä¸‹è½½ç¬¬{idx}ä¸ª: {bv} - {title}")
            logger.info(f"ğŸ“ æ–‡ä»¶åæ¨¡æ¿: {outtmpl}")

            result = subprocess.run(cmd_dl, cwd=download_path)
            if result.returncode == 0:
                success_count += 1
                logger.info(f"âœ… ç¬¬{idx}ä¸ªä¸‹è½½æˆåŠŸ")
            else:
                logger.error(f"âŒ ç¬¬{idx}ä¸ªä¸‹è½½å¤±è´¥")

        logger.info(f"ğŸ‰ BVå·å¾ªç¯æ³•ä¸‹è½½å®Œæˆ: {success_count}/{len(bv_list)} ä¸ªæˆåŠŸ")
        return success_count > 0

    async def _download_bilibili_ugc_season(
        self, bv_id: str, season_id: str, download_path: Path, message_updater=None
    ) -> Dict[str, Any]:
        """ä¸‹è½½Bç«™UGCåˆé›†"""
        logger.info(f"ğŸ¬ å¼€å§‹ä¸‹è½½Bç«™UGCåˆé›†: BV={bv_id}, Season={season_id}")

        try:
            # æ­¥éª¤1: è·å–åˆé›†ä¿¡æ¯
            logger.info("ğŸ” æ­¥éª¤1: è·å–UGCåˆé›†ä¿¡æ¯...")

            import requests
            api_url = f"https://api.bilibili.com/x/web-interface/view?bvid={bv_id}"
            headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                'Referer': 'https://www.bilibili.com/',
            }

            if message_updater:
                try:
                    import asyncio
                    if asyncio.iscoroutinefunction(message_updater):
                        await message_updater("ğŸ” æ­£åœ¨è·å–UGCåˆé›†ä¿¡æ¯...")
                    else:
                        message_updater("ğŸ” æ­£åœ¨è·å–UGCåˆé›†ä¿¡æ¯...")
                except Exception as e:
                    logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")

            try:
                response = requests.get(api_url, headers=headers, timeout=30)
                response.raise_for_status()  # æ£€æŸ¥HTTPçŠ¶æ€ç 
                data = response.json()
            except requests.exceptions.HTTPError as e:
                if response.status_code == 404:
                    error_msg = f"è§†é¢‘ä¸å­˜åœ¨: BVå· {bv_id} æ— æ•ˆæˆ–è§†é¢‘å·²è¢«åˆ é™¤"
                else:
                    error_msg = f"HTTPè¯·æ±‚å¤±è´¥: {e}"
                logger.error(error_msg)
                return {'success': False, 'error': error_msg}
            except requests.exceptions.RequestException as e:
                error_msg = f"ç½‘ç»œè¯·æ±‚å¤±è´¥: {e}"
                logger.error(error_msg)
                return {'success': False, 'error': error_msg}
            except ValueError as e:
                error_msg = f"å“åº”è§£æå¤±è´¥: {e}"
                logger.error(error_msg)
                return {'success': False, 'error': error_msg}

            if data.get('code') != 0:
                error_msg = f"è·å–åˆé›†ä¿¡æ¯å¤±è´¥: {data.get('message', 'æœªçŸ¥é”™è¯¯')}"
                logger.error(error_msg)
                return {'success': False, 'error': error_msg}

            ugc_season = data.get('data', {}).get('ugc_season')
            if not ugc_season:
                error_msg = "è§†é¢‘ä¸å±äºUGCåˆé›†"
                logger.error(error_msg)
                return {'success': False, 'error': error_msg}

            season_title = ugc_season.get('title', 'æœªçŸ¥åˆé›†')
            logger.info(f"ğŸ“‹ åˆé›†æ ‡é¢˜: {season_title}")

            # åˆ›å»ºåˆé›†ä¸“ç”¨å­ç›®å½•
            safe_season_title = self._sanitize_filename(season_title, max_length=50)
            season_download_path = download_path / safe_season_title
            season_download_path.mkdir(parents=True, exist_ok=True)
            logger.info(f"ğŸ“ åˆ›å»ºåˆé›†ç›®å½•: {season_download_path}")

            # æ­¥éª¤2: æå–æ‰€æœ‰è§†é¢‘
            all_videos = []
            sections = ugc_season.get('sections', [])

            for section in sections:
                episodes = section.get('episodes', [])
                for episode in episodes:
                    video_info = {
                        'bvid': episode.get('bvid'),
                        'title': episode.get('title'),
                        'aid': episode.get('aid'),
                        'cid': episode.get('cid'),
                    }
                    if video_info['bvid']:
                        all_videos.append(video_info)

            if not all_videos:
                error_msg = "åˆé›†ä¸­æ²¡æœ‰æ‰¾åˆ°è§†é¢‘"
                logger.error(error_msg)
                return {'success': False, 'error': error_msg}

            logger.info(f"ğŸ“‹ æ‰¾åˆ° {len(all_videos)} ä¸ªè§†é¢‘:")
            for i, video in enumerate(all_videos, 1):
                logger.info(f"  {i:02d}. {video['title']} ({video['bvid']})")

            # æ­¥éª¤3: é€ä¸ªä¸‹è½½è§†é¢‘
            logger.info("ğŸ” æ­¥éª¤3: å¼€å§‹é€ä¸ªä¸‹è½½è§†é¢‘...")

            downloaded_files = []
            success_count = 0
            total_size_mb = 0
            failed_videos = []

            # åˆ›å»ºå¢å¼ºçš„è¿›åº¦å›è°ƒå‡½æ•°ï¼Œç”¨äºæ˜¾ç¤ºåˆé›†ä¸‹è½½è¿›åº¦
            def create_ugc_progress_callback(video_index, video_title, total_count):
                """ä¸ºUGCåˆé›†ä¸­çš„æ¯ä¸ªè§†é¢‘åˆ›å»ºä¸“é—¨çš„è¿›åº¦å›è°ƒ"""
                def ugc_video_progress_hook(d):
                    try:
                        if d.get('status') == 'downloading':
                            downloaded_bytes = d.get('downloaded_bytes', 0)
                            total_bytes = d.get('total_bytes', 0)
                            speed = d.get('speed', 0)
                            eta = d.get('eta', 0)
                            filename = d.get('filename', video_title)

                            if total_bytes and total_bytes > 0:
                                percent = (downloaded_bytes / total_bytes) * 100
                                downloaded_mb = downloaded_bytes / (1024 * 1024)
                                total_mb = total_bytes / (1024 * 1024)
                                speed_mb = speed / (1024 * 1024) if speed else 0

                                # åˆ›å»ºè¿›åº¦æ¡ (20ä¸ªå­—ç¬¦)
                                progress_bar_length = 20
                                # ä¿®å¤è¿›åº¦æ¡è®¡ç®—ï¼šç¡®ä¿è‡³å°‘æ˜¾ç¤º1ä¸ªå®å¿ƒå—å½“è¿›åº¦>0æ—¶
                                if percent > 0:
                                    filled_length = max(1, int(progress_bar_length * percent / 100))
                                else:
                                    filled_length = 0
                                bar = 'â–ˆ' * filled_length + 'â–‘' * (progress_bar_length - filled_length)

                                # æ ¼å¼åŒ–ETA
                                if eta and eta > 0:
                                    if eta < 60:
                                        eta_str = f"{int(eta)}ç§’"
                                    elif eta < 3600:
                                        eta_str = f"{int(eta//60)}åˆ†{int(eta%60)}ç§’"
                                    else:
                                        eta_str = f"{int(eta//3600)}æ—¶{int((eta%3600)//60)}åˆ†"
                                else:
                                    eta_str = "è®¡ç®—ä¸­..."

                                # æ„å»ºå›¾ç‰‡æ ¼å¼çš„è¿›åº¦æ¶ˆæ¯
                                # ä½¿ç”¨ä¸Šé¢å·²ç»è®¡ç®—å¥½çš„bar

                                progress_msg = (
                                    f"ğŸ“¥ ä¸‹è½½ä¸­\n"
                                    f"ğŸ“ æ–‡ä»¶å: {filename}\n"
                                    f"ğŸ’¾ å¤§å°: {downloaded_mb:.2f}MB / {total_mb:.2f}MB\n"
                                    f"âš¡ é€Ÿåº¦: {speed_mb:.2f}MB/s\n"
                                    f"â³ é¢„è®¡å‰©ä½™: {eta_str}\n"
                                    f"ğŸ“Š è¿›åº¦: {bar} {percent:.1f}%"
                                )

                                # æ›´æ–°çŠ¶æ€æ¶ˆæ¯
                                if message_updater:
                                    try:
                                        import asyncio
                                        if asyncio.iscoroutinefunction(message_updater):
                                            # å¯¹äºåç¨‹å‡½æ•°ï¼Œéœ€è¦åœ¨äº‹ä»¶å¾ªç¯ä¸­è¿è¡Œ
                                            try:
                                                loop = asyncio.get_running_loop()
                                                asyncio.run_coroutine_threadsafe(message_updater(progress_msg), loop)
                                            except RuntimeError:
                                                pass  # å¦‚æœæ²¡æœ‰è¿è¡Œçš„äº‹ä»¶å¾ªç¯ï¼Œè·³è¿‡
                                        else:
                                            message_updater(progress_msg)
                                    except Exception as e:
                                        logger.debug(f"æ›´æ–°è¿›åº¦æ¶ˆæ¯å¤±è´¥: {e}")

                        elif d.get('status') == 'finished':
                            filename = d.get('filename', '')
                            if filename:
                                logger.info(f"âœ… [{video_index}/{total_count}] ä¸‹è½½å®Œæˆ: {filename}")

                                # æ˜¾ç¤ºå®Œæˆæ¶ˆæ¯
                                complete_msg = (
                                    f"âœ… ä¸‹è½½å®Œæˆ [{video_index}/{total_count}]\n"
                                    f"ğŸ“ æ–‡ä»¶åï¼š{filename}\n"
                                    f"ğŸ“Š è¿›åº¦ï¼šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 100.0%"
                                )
                                if message_updater:
                                    try:
                                        import asyncio
                                        if asyncio.iscoroutinefunction(message_updater):
                                            try:
                                                loop = asyncio.get_running_loop()
                                                asyncio.run_coroutine_threadsafe(message_updater(complete_msg), loop)
                                            except RuntimeError:
                                                pass
                                        else:
                                            message_updater(complete_msg)
                                    except Exception as e:
                                        logger.debug(f"æ›´æ–°å®Œæˆæ¶ˆæ¯å¤±è´¥: {e}")

                    except Exception as e:
                        logger.debug(f"UGCè¿›åº¦å›è°ƒå¤„ç†å¤±è´¥: {e}")

                return ugc_video_progress_hook

            for i, video in enumerate(all_videos, 1):
                try:
                    # æ˜¾ç¤ºå¼€å§‹ä¸‹è½½çš„æ¶ˆæ¯ - ä½¿ç”¨è¯¦ç»†æ ¼å¼
                    start_msg = (
                        f"ğŸ“¥ å‡†å¤‡ä¸‹è½½ [{i}/{len(all_videos)}]\n"
                        f"ğŸ“ æ–‡ä»¶åï¼š{video['title']}\n"
                        f"ğŸ’¾ å¤§å°ï¼šè·å–ä¸­...\n"
                        f"âš¡ é€Ÿåº¦ï¼šå‡†å¤‡ä¸­...\n"
                        f"â³ é¢„è®¡å‰©ä½™ï¼šè®¡ç®—ä¸­...\n"
                        f"ğŸ“Š è¿›åº¦ï¼šâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ 0.0%"
                    )
                    logger.info(f"ğŸ¬ å¼€å§‹ä¸‹è½½: {video['title']}")

                    if message_updater:
                        try:
                            import asyncio
                            if asyncio.iscoroutinefunction(message_updater):
                                await message_updater(start_msg)
                            else:
                                message_updater(start_msg)
                        except Exception as e:
                            logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")

                    # æ„å»ºå•ä¸ªè§†é¢‘çš„URL
                    video_url = f"https://www.bilibili.com/video/{video['bvid']}/"

                    # ä½¿ç”¨æ ‡å‡†çš„single_video_progress_hookï¼Œä½†æ·»åŠ UGCåˆé›†ä¿¡æ¯
                    import threading
                    progress_data = {"final_filename": None, "lock": threading.Lock()}

                    # åˆ›å»ºUGCä¸“ç”¨çš„æ¶ˆæ¯æ›´æ–°å™¨ï¼Œåœ¨æ ‡å‡†è¿›åº¦æ¶ˆæ¯å‰æ·»åŠ åˆé›†ä¿¡æ¯
                    def ugc_message_updater(msg_or_dict):
                        """UGCä¸“ç”¨æ¶ˆæ¯æ›´æ–°å™¨ï¼Œæ·»åŠ åˆé›†ä¿¡æ¯"""
                        try:
                            if isinstance(msg_or_dict, str):
                                # å­—ç¬¦ä¸²æ¶ˆæ¯ï¼Œç›´æ¥ä¼ é€’
                                ugc_msg = f"ğŸ“¥ UGCåˆé›† [{i}/{len(all_videos)}]\n{msg_or_dict}"
                                if message_updater:
                                    message_updater(ugc_msg)
                            elif isinstance(msg_or_dict, dict):
                                # å­—å…¸æ¶ˆæ¯ï¼Œä¼ é€’ç»™åŸå§‹æ›´æ–°å™¨å¤„ç†
                                if message_updater:
                                    message_updater(msg_or_dict)
                        except Exception as e:
                            logger.error(f"âŒ UGCæ¶ˆæ¯æ›´æ–°å™¨å¤±è´¥: {e}")

                    # ä½¿ç”¨æ ‡å‡†çš„single_video_progress_hook
                    progress_callback = single_video_progress_hook(
                        message_updater=ugc_message_updater,
                        progress_data=progress_data,
                        status_message=status_message,
                        context=context
                    )

                    # ä½¿ç”¨smart_download_bilibiliä¸‹è½½Bç«™è§†é¢‘ï¼Œè·å¾—æ›´å¥½çš„è¿›åº¦æ˜¾ç¤º
                    # å¯¹äºUGCåˆé›†ï¼Œå³ä½¿æ˜¯å•è§†é¢‘ä¹Ÿåº”è¯¥ç»§ç»­ä¸‹è½½
                    import asyncio
                    loop = asyncio.get_running_loop()
                    result = await loop.run_in_executor(
                        None,
                        self.smart_download_bilibili_for_ugc,
                        video_url,
                        str(season_download_path),
                        progress_callback,
                        False  # auto_playlist=Falseï¼Œåªä¸‹è½½å•ä¸ªè§†é¢‘
                    )

                    # å¤„ç†smart_download_bilibiliçš„è¿”å›ç»“æœ
                    if isinstance(result, dict) and result.get('status') == 'success':
                        success_count += 1
                        file_info = {
                            'filename': result.get('filename', ''),
                            'full_path': result.get('download_path', ''),
                            'size_mb': result.get('size_mb', 0),
                            'title': video['title'],
                            'bvid': video['bvid'],
                            'resolution': result.get('resolution', ''),
                            'duration': result.get('duration', ''),
                        }
                        downloaded_files.append(file_info)
                        total_size_mb += result.get('size_mb', 0)

                        success_msg = f"âœ… ç¬¬ {i}/{len(all_videos)} ä¸ªè§†é¢‘ä¸‹è½½æˆåŠŸ: {result.get('filename', '')}"
                        logger.info(success_msg)

                    elif result is True:
                        # smart_download_bilibiliæœ‰æ—¶è¿”å›Trueè¡¨ç¤ºæˆåŠŸï¼Œéœ€è¦ä»ç›®å½•ä¸­æŸ¥æ‰¾å®é™…æ–‡ä»¶
                        success_count += 1

                        # å°è¯•ä»ä¸‹è½½ç›®å½•ä¸­æ‰¾åˆ°å®é™…çš„æ–‡ä»¶å
                        actual_filename = None
                        logger.info(f"ğŸ” æŸ¥æ‰¾ç¬¬{i}ä¸ªè§†é¢‘çš„å®é™…æ–‡ä»¶åï¼Œç›®å½•: {season_download_path}")
                        try:
                            import os
                            all_files = os.listdir(season_download_path)
                            logger.info(f"ğŸ“ ç›®å½•ä¸­çš„æ‰€æœ‰æ–‡ä»¶: {all_files}")

                            video_files = [f for f in all_files if f.endswith(('.mp4', '.mkv', '.avi', '.flv', '.webm'))]
                            logger.info(f"ğŸ¬ è§†é¢‘æ–‡ä»¶: {video_files}")

                            for file in video_files:
                                # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦ä¸å½“å‰è§†é¢‘ç›¸å…³ï¼ˆç®€å•çš„æ ‡é¢˜åŒ¹é…ï¼‰
                                if any(word in file for word in video['title'].split()[:3]):
                                    actual_filename = file
                                    logger.info(f"âœ… æ‰¾åˆ°åŒ¹é…æ–‡ä»¶: {actual_filename}")
                                    break

                            # å¦‚æœæ²¡æ‰¾åˆ°åŒ¹é…çš„æ–‡ä»¶ï¼Œä½¿ç”¨æœ€æ–°çš„è§†é¢‘æ–‡ä»¶
                            if not actual_filename and video_files:
                                # æŒ‰ä¿®æ”¹æ—¶é—´æ’åºï¼Œå–æœ€æ–°çš„
                                video_files.sort(key=lambda x: os.path.getmtime(season_download_path / x), reverse=True)
                                actual_filename = video_files[0]
                                logger.info(f"ğŸ“Š ä½¿ç”¨æœ€æ–°æ–‡ä»¶: {actual_filename}")
                        except Exception as e:
                            logger.warning(f"æŸ¥æ‰¾å®é™…æ–‡ä»¶åå¤±è´¥: {e}")

                        if not actual_filename:
                            actual_filename = f"{video['title']}.mp4"
                            logger.warning(f"âš ï¸ æœªæ‰¾åˆ°å®é™…æ–‡ä»¶ï¼Œä½¿ç”¨é»˜è®¤åç§°: {actual_filename}")

                        # è·å–æ–‡ä»¶å¤§å°
                        file_size_mb = 0
                        try:
                            file_path = season_download_path / actual_filename
                            if file_path.exists():
                                file_size_mb = file_path.stat().st_size / (1024 * 1024)
                        except Exception as e:
                            logger.debug(f"è·å–æ–‡ä»¶å¤§å°å¤±è´¥: {e}")

                        # æ£€æµ‹æ–‡ä»¶åˆ†è¾¨ç‡å’Œæ—¶é•¿
                        resolution_info = ''
                        duration_info = ''
                        try:
                            file_path = season_download_path / actual_filename
                            if file_path.exists():
                                # ä½¿ç”¨ç°æœ‰çš„get_media_infoæ–¹æ³•æ£€æµ‹è§†é¢‘ä¿¡æ¯
                                media_info = self.get_media_info(str(file_path))
                                resolution_info = media_info.get('resolution', '')
                                duration_info = media_info.get('duration', '')
                                logger.info(f"ğŸ” æ£€æµ‹åˆ°è§†é¢‘ä¿¡æ¯: åˆ†è¾¨ç‡={resolution_info}, æ—¶é•¿={duration_info}")
                        except Exception as e:
                            logger.debug(f"æ£€æµ‹è§†é¢‘ä¿¡æ¯å¤±è´¥: {e}")

                        file_info = {
                            'filename': actual_filename,
                            'full_path': str(season_download_path / actual_filename),
                            'size_mb': file_size_mb,
                            'title': video['title'],
                            'bvid': video['bvid'],
                            'resolution': resolution_info,
                            'duration': duration_info,
                        }
                        downloaded_files.append(file_info)
                        total_size_mb += file_size_mb

                        success_msg = f"âœ… ç¬¬ {i}/{len(all_videos)} ä¸ªè§†é¢‘ä¸‹è½½æˆåŠŸ: {actual_filename}"
                        logger.info(success_msg)
                    else:
                        error_msg = f"âŒ ç¬¬ {i}/{len(all_videos)} ä¸ªè§†é¢‘ä¸‹è½½å¤±è´¥"
                        if isinstance(result, dict):
                            error_msg += f": {result.get('error', 'æœªçŸ¥é”™è¯¯')}"
                        logger.error(error_msg)
                        failed_videos.append({
                            'index': i,
                            'title': video['title'],
                            'bvid': video['bvid'],
                            'error': result.get('error', 'æœªçŸ¥é”™è¯¯') if isinstance(result, dict) else 'ä¸‹è½½å¤±è´¥'
                        })

                except Exception as e:
                    error_msg = f"âŒ ä¸‹è½½ç¬¬ {i}/{len(all_videos)} ä¸ªè§†é¢‘æ—¶å‡ºé”™: {e}"
                    logger.error(error_msg)
                    failed_videos.append({
                        'index': i,
                        'title': video['title'],
                        'bvid': video['bvid'],
                        'error': str(e)
                    })

            # æ­¥éª¤4: ç”Ÿæˆè¯¦ç»†çš„ä¸‹è½½ç»“æœæŠ¥å‘Š
            logger.info("ğŸ” æ­¥éª¤4: ç”Ÿæˆä¸‹è½½ç»“æœæŠ¥å‘Š...")

            # è®¡ç®—æ€»æ—¶é•¿å’Œå¹³å‡æ–‡ä»¶å¤§å°
            total_duration_seconds = 0
            for file_info in downloaded_files:
                duration_str = file_info.get('duration', '')
                if duration_str and ':' in duration_str:
                    try:
                        parts = duration_str.split(':')
                        if len(parts) == 2:  # MM:SS
                            minutes, seconds = map(int, parts)
                            total_duration_seconds += minutes * 60 + seconds
                        elif len(parts) == 3:  # HH:MM:SS
                            hours, minutes, seconds = map(int, parts)
                            total_duration_seconds += hours * 3600 + minutes * 60 + seconds
                    except ValueError:
                        pass

            # æ ¼å¼åŒ–æ€»æ—¶é•¿
            if total_duration_seconds > 0:
                hours = total_duration_seconds // 3600
                minutes = (total_duration_seconds % 3600) // 60
                seconds = total_duration_seconds % 60
                if hours > 0:
                    total_duration_str = f"{hours:02d}:{minutes:02d}:{seconds:02d}"
                else:
                    total_duration_str = f"{minutes:02d}:{seconds:02d}"
            else:
                total_duration_str = "æœªçŸ¥"

            # ç”Ÿæˆè¯¦ç»†çš„ç»“æœæŠ¥å‘Š
            if success_count > 0:
                # æˆåŠŸä¸‹è½½çš„ç»Ÿè®¡
                avg_size_mb = total_size_mb / success_count if success_count > 0 else 0

                logger.info("ğŸ¬ **è§†é¢‘ä¸‹è½½å®Œæˆ**")
                logger.info(f"ğŸ“‹ åˆé›†æ ‡é¢˜: {season_title}")
                logger.info("")
                logger.info("ğŸ“ æ–‡ä»¶å:")

                # æ˜¾ç¤ºæ–‡ä»¶åˆ—è¡¨ï¼Œæ ¼å¼ä¸æœ€ç»ˆæ¶ˆæ¯ä¸€è‡´
                for i, file_info in enumerate(downloaded_files, 1):
                    logger.info(f"  {i:02d}. {file_info['filename']}")

                logger.info("")
                logger.info(f"ğŸ’¾ æ–‡ä»¶å¤§å°: {total_size_mb:.2f} MB")
                logger.info(f"ğŸ“Š é›†æ•°: {success_count} é›†")

                # è·å–åˆ†è¾¨ç‡ä¿¡æ¯ - ä½¿ç”¨ffprobeæ£€æµ‹å®é™…æ–‡ä»¶
                resolution_display = "æœªçŸ¥"
                logger.info(f"ğŸ” å¼€å§‹åˆ†è¾¨ç‡æ£€æµ‹ï¼Œä¸‹è½½æ–‡ä»¶æ•°é‡: {len(downloaded_files) if downloaded_files else 0}")
                logger.info(f"ğŸ” åˆå§‹resolution_displayå€¼: '{resolution_display}'")

                if downloaded_files:
                    logger.info(f"âœ… æœ‰ä¸‹è½½æ–‡ä»¶ä¿¡æ¯ï¼Œå¼€å§‹æ£€æµ‹åˆ†è¾¨ç‡")
                    # å°è¯•ä»ç¬¬ä¸€ä¸ªä¸‹è½½çš„æ–‡ä»¶è·å–åˆ†è¾¨ç‡
                    first_file = downloaded_files[0]
                    file_path = first_file.get('full_path', '')
                    logger.info(f"ğŸ” æ£€æµ‹æ–‡ä»¶è·¯å¾„: {file_path}")

                    import os
                    if file_path and os.path.exists(file_path):
                        logger.info(f"âœ… æ–‡ä»¶å­˜åœ¨ï¼Œå¼€å§‹æ£€æµ‹åˆ†è¾¨ç‡")
                        try:
                            logger.info(f"ğŸ” ä½¿ç”¨get_media_infoæ£€æµ‹åˆ†è¾¨ç‡: {file_path}")

                            # ä½¿ç”¨ç°æœ‰çš„get_media_infoæ–¹æ³•
                            media_info = self.get_media_info(file_path)
                            if media_info.get('resolution'):
                                resolution_display = media_info['resolution']
                                logger.info(f"âœ… æˆåŠŸè·å–åˆ†è¾¨ç‡: {resolution_display}")
                                logger.info(f"ğŸ” resolution_displayå˜é‡å½“å‰å€¼: '{resolution_display}'")
                            else:
                                logger.warning("âš ï¸ æ— æ³•è·å–åˆ†è¾¨ç‡ä¿¡æ¯")

                        except Exception as e:
                            logger.warning(f"âš ï¸ ffprobeè¾“å‡ºè§£æå¤±è´¥: {e}")
                        except Exception as e:
                            logger.warning(f"âš ï¸ è·å–åˆ†è¾¨ç‡æ—¶å‘ç”Ÿé”™è¯¯: {e}")
                    else:
                        logger.warning(f"âš ï¸ æ–‡ä»¶ä¸å­˜åœ¨æˆ–è·¯å¾„æ— æ•ˆ: {file_path}")
                else:
                    logger.warning("âš ï¸ æ²¡æœ‰ä¸‹è½½æ–‡ä»¶ä¿¡æ¯ï¼Œæ— æ³•æ£€æµ‹åˆ†è¾¨ç‡")

                logger.info(f"ğŸ“Š æœ€ç»ˆåˆ†è¾¨ç‡å€¼: '{resolution_display}'")
                logger.info(f"ğŸ–¼ï¸ åˆ†è¾¨ç‡: {resolution_display}")

                logger.info(f"ğŸ“‚ ä¿å­˜ä½ç½®: {season_download_path}")

                # æ˜¾ç¤ºè¯¦ç»†ç»Ÿè®¡ä¿¡æ¯ï¼ˆä»…åœ¨æ—¥å¿—ä¸­ï¼‰
                logger.info("")
                logger.info("ğŸ“Š è¯¦ç»†ç»Ÿè®¡:")
                logger.info(f"  âœ… æˆåŠŸ: {success_count}/{len(all_videos)} ä¸ªè§†é¢‘")
                logger.info(f"  ğŸ“ å¹³å‡å¤§å°: {avg_size_mb:.1f}MB")
                logger.info(f"  â±ï¸ æ€»æ—¶é•¿: {total_duration_str}")

                if failed_videos:
                    logger.info(f"  âŒ å¤±è´¥: {len(failed_videos)} ä¸ªè§†é¢‘")
                    for failed in failed_videos:
                        logger.warning(f"    - ç¬¬{failed['index']}ä¸ª: {failed['title']} (é”™è¯¯: {failed['error']})")

                # ç”Ÿæˆç¾åŒ–çš„æœ€ç»ˆçŠ¶æ€æ¶ˆæ¯
                logger.info(f"ğŸ” å¼€å§‹ç”Ÿæˆæœ€ç»ˆæ¶ˆæ¯ï¼Œå½“å‰resolution_displayå€¼: '{resolution_display}'")
                final_msg = f"ğŸ¬ è§†é¢‘ä¸‹è½½å®Œæˆ\n\n"
                final_msg += f"ğŸ“ æ–‡ä»¶å:\n"

                # æ·»åŠ æ–‡ä»¶åˆ—è¡¨ï¼ŒæŒ‰åºå·æ’åˆ—
                for i, file_info in enumerate(downloaded_files, 1):
                    filename = file_info['filename']
                    final_msg += f"  {i:02d}. {filename}\n"

                # æ·»åŠ ç»Ÿè®¡ä¿¡æ¯
                final_msg += f"\nğŸ’¾ æ–‡ä»¶å¤§å°: {total_size_mb:.2f} MB\n"
                final_msg += f"ğŸ“Š ä¸‹è½½ç»Ÿè®¡:\n"
                final_msg += f"âœ… æˆåŠŸ: {success_count} ä¸ª\n"

                # æ·»åŠ åˆ†è¾¨ç‡ä¿¡æ¯åˆ°æœ€ç»ˆæ¶ˆæ¯
                logger.info(f"ğŸ” æ·»åŠ åˆ†è¾¨ç‡åˆ°æ¶ˆæ¯ï¼Œresolution_displayå€¼: '{resolution_display}'")
                final_msg += f"ğŸ–¼ï¸ åˆ†è¾¨ç‡: {resolution_display}\n"
                final_msg += f"ğŸ“‚ ä¿å­˜ä½ç½®: {season_download_path}"

                logger.info(f"ğŸ” æœ€ç»ˆæ¶ˆæ¯ç”Ÿæˆå®Œæˆï¼Œæ¶ˆæ¯é•¿åº¦: {len(final_msg)} å­—ç¬¦")
                logger.info(f"ğŸ” æœ€ç»ˆæ¶ˆæ¯é¢„è§ˆ: {final_msg[:200]}...")

                if failed_videos:
                    final_msg += f"\n\nâŒ å¤±è´¥: {len(failed_videos)} ä¸ªè§†é¢‘"
                    for failed in failed_videos:
                        final_msg += f"\n  - {failed['title']}"

                # ä¸åœ¨è¿™é‡Œå‘é€æ¶ˆæ¯ï¼Œè®©ä¸»ç¨‹åºå¤„ç†
                logger.info(f"ğŸ” UGCåˆé›†ä¸‹è½½å®Œæˆï¼Œè¿”å›ç»“æœç»™ä¸»ç¨‹åºå¤„ç†æ¶ˆæ¯")

                return {
                    'success': True,
                    'is_playlist': True,  # æ”¹ä¸ºTrueï¼Œè®©ä¸»ç¨‹åºå¤„ç†æ¶ˆæ¯
                    'file_count': success_count,
                    'total_size_mb': total_size_mb,
                    'files': downloaded_files,
                    'platform': 'bilibili',  # ä½¿ç”¨æ ‡å‡†çš„bilibiliæ ‡è¯†
                    'download_path': str(season_download_path),  # ä½¿ç”¨åˆé›†å­ç›®å½•
                    'base_download_path': str(download_path),    # ä¿ç•™åŸºç¡€ä¸‹è½½è·¯å¾„
                    'season_title': season_title,
                    'season_id': season_id,
                    'failed_count': len(failed_videos),
                    'failed_videos': failed_videos,
                    'total_duration': total_duration_str,
                    'average_size_mb': avg_size_mb,
                    'ugc_season': True,  # ä¿ç•™UGCåˆé›†æ ‡è¯†
                    'video_type': 'playlist',  # æ ‡è¯†ä¸ºæ’­æ”¾åˆ—è¡¨ç±»å‹
                    'count': success_count,  # æ·»åŠ countå­—æ®µ
                    'resolution': resolution_display,  # æ·»åŠ åˆ†è¾¨ç‡ä¿¡æ¯
                }
            else:
                error_msg = f"UGCåˆé›†ä¸‹è½½å¤±è´¥: æ‰€æœ‰ {len(all_videos)} ä¸ªè§†é¢‘éƒ½ä¸‹è½½å¤±è´¥"
                logger.error(error_msg)
                logger.error("å¤±è´¥è¯¦æƒ…:")
                for failed in failed_videos:
                    logger.error(f"  - ç¬¬{failed['index']}ä¸ª: {failed['title']} (é”™è¯¯: {failed['error']})")

                if message_updater:
                    try:
                        import asyncio
                        if asyncio.iscoroutinefunction(message_updater):
                            await message_updater(f"âŒ UGCåˆé›†ä¸‹è½½å¤±è´¥: æ‰€æœ‰è§†é¢‘éƒ½ä¸‹è½½å¤±è´¥")
                        else:
                            message_updater(f"âŒ UGCåˆé›†ä¸‹è½½å¤±è´¥: æ‰€æœ‰è§†é¢‘éƒ½ä¸‹è½½å¤±è´¥")
                    except Exception as e:
                        logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")

                return {
                    'success': False,
                    'error': error_msg,
                    'failed_videos': failed_videos,
                    'season_title': season_title,
                    'season_id': season_id,
                    'download_path': str(season_download_path),
                    'base_download_path': str(download_path),
                }

        except Exception as e:
            error_msg = f"UGCåˆé›†ä¸‹è½½è¿‡ç¨‹ä¸­å‡ºé”™: {e}"
            logger.error(error_msg)
            return {'success': False, 'error': error_msg}

    async def _download_bilibili_user_all_videos(
        self, uid: str, download_path: Path, message_updater=None
    ) -> Dict[str, Any]:
        """ä¸‹è½½Bç«™UPä¸»çš„æ‰€æœ‰è§†é¢‘ï¼ˆå‚è€ƒYouTubeé¢‘é“ä¸‹è½½æ¨¡å¼ï¼‰"""
        import re  # åœ¨å‡½æ•°å¼€å¤´å¯¼å…¥ï¼Œç¡®ä¿æ•´ä¸ªå‡½æ•°éƒ½èƒ½ä½¿ç”¨
        import time
        import os

        logger.info(f"ğŸ¬ å¼€å§‹ä¸‹è½½Bç«™UPä¸»çš„æ‰€æœ‰è§†é¢‘: UID={uid}")
        logger.info(f"ğŸ” message_updaterå‚æ•°: type={type(message_updater)}, callable={callable(message_updater)}")

        try:
            # æ­¥éª¤1: ä½¿ç”¨yt-dlpè·å–UPä¸»çš„è§†é¢‘åˆ—è¡¨
            logger.info("ğŸ” æ­¥éª¤1: ä½¿ç”¨yt-dlpè·å–UPä¸»çš„è§†é¢‘åˆ—è¡¨...")

            if message_updater:
                try:
                    import asyncio
                    if asyncio.iscoroutinefunction(message_updater):
                        await message_updater("ğŸ” æ­£åœ¨è·å–UPä¸»çš„è§†é¢‘åˆ—è¡¨...")
                    else:
                        message_updater("ğŸ” æ­£åœ¨è·å–UPä¸»çš„è§†é¢‘åˆ—è¡¨...")
                except Exception as e:
                    logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")

            # æ„å»ºUPä¸»ç©ºé—´URL
            user_space_url = f"https://space.bilibili.com/{uid}"

            # é…ç½®yt-dlpé€‰é¡¹ï¼Œå¢å¼ºå¯¹Bç«™çš„å…¼å®¹æ€§
            ydl_opts = {
                "quiet": True,
                "no_warnings": True,
                "extract_flat": True,
                "socket_timeout": 120,  # å¢åŠ è¶…æ—¶æ—¶é—´
                "retries": 10,  # å¢åŠ é‡è¯•æ¬¡æ•°
                "playlistend": None,  # ä¸é™åˆ¶ï¼Œè·å–æ‰€æœ‰è§†é¢‘
                "sleep_interval": 2,  # æ·»åŠ è¯·æ±‚é—´éš”
                "max_sleep_interval": 5,
                "sleep_interval_subtitles": 1,
                # æ·»åŠ æ›´å¤šBç«™å…¼å®¹æ€§é€‰é¡¹
                "extractor_args": {
                    "bilibili": {
                        "api_version": "app",  # ä½¿ç”¨APP API
                    }
                },
                # æ·»åŠ ç”¨æˆ·ä»£ç†
                "http_headers": {
                    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                    "Referer": "https://www.bilibili.com/",
                    "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8",
                    "Accept-Language": "zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2",
                    "Accept-Encoding": "gzip, deflate, br",
                }
            }

            if self.proxy_host:
                ydl_opts["proxy"] = self.proxy_host
            if self.b_cookies_path and os.path.exists(self.b_cookies_path):
                ydl_opts["cookiefile"] = self.b_cookies_path
                logger.info(f"ğŸª ä½¿ç”¨Bç«™cookiesæ–‡ä»¶: {self.b_cookies_path}")

                # æ£€æŸ¥cookiesæ–‡ä»¶å†…å®¹
                try:
                    with open(self.b_cookies_path, 'r', encoding='utf-8') as f:
                        cookies_content = f.read()
                        if 'SESSDATA' in cookies_content:
                            logger.info("âœ… Cookiesæ–‡ä»¶åŒ…å«SESSDATAï¼Œæ ¼å¼æ­£ç¡®")
                        else:
                            logger.warning("âš ï¸ Cookiesæ–‡ä»¶å¯èƒ½ç¼ºå°‘SESSDATAå­—æ®µ")

                        # æ£€æŸ¥æ–‡ä»¶å¤§å°
                        file_size = len(cookies_content)
                        logger.info(f"ğŸ“Š Cookiesæ–‡ä»¶å¤§å°: {file_size} å­—ç¬¦")

                except Exception as e:
                    logger.warning(f"âš ï¸ æ— æ³•è¯»å–cookiesæ–‡ä»¶å†…å®¹: {e}")
            else:
                logger.warning("âš ï¸ æœªé…ç½®Bç«™cookiesï¼Œå¯èƒ½æ— æ³•è®¿é—®æŸäº›å†…å®¹")

            import yt_dlp

            # å°è¯•å¤šç§æ–¹å¼è·å–UPä¸»çš„è§†é¢‘åˆ—è¡¨
            info = None
            last_error = None

            # æ–¹å¼1: ç›´æ¥è®¿é—®UPä¸»ç©ºé—´
            try:
                logger.info(f"ğŸ” æ–¹å¼1: ç›´æ¥è®¿é—®UPä¸»ç©ºé—´ {user_space_url}")
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    info = ydl.extract_info(user_space_url, download=False)
                logger.info("âœ… æ–¹å¼1æˆåŠŸ")
            except Exception as e:
                last_error = str(e)
                logger.warning(f"âŒ æ–¹å¼1å¤±è´¥: {e}")

                # æ–¹å¼2: å°è¯•ä½¿ç”¨æŠ•ç¨¿é¡µé¢
                try:
                    video_url = f"https://space.bilibili.com/{uid}/video"
                    logger.info(f"ğŸ” æ–¹å¼2: å°è¯•æŠ•ç¨¿é¡µé¢ {video_url}")
                    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                        info = ydl.extract_info(video_url, download=False)
                    logger.info("âœ… æ–¹å¼2æˆåŠŸ")
                except Exception as e2:
                    last_error = str(e2)
                    logger.warning(f"âŒ æ–¹å¼2å¤±è´¥: {e2}")

                    # æ–¹å¼3: å°è¯•ä½¿ç”¨ä¸åŒçš„URLæ ¼å¼
                    try:
                        channel_url = f"https://space.bilibili.com/{uid}/channel/series"
                        logger.info(f"ğŸ” æ–¹å¼3: å°è¯•é¢‘é“ç³»åˆ—é¡µé¢ {channel_url}")
                        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                            info = ydl.extract_info(channel_url, download=False)
                        logger.info("âœ… æ–¹å¼3æˆåŠŸ")
                    except Exception as e3:
                        last_error = str(e3)
                        logger.warning(f"âŒ æ–¹å¼3å¤±è´¥: {e3}")

                        # æ–¹å¼4: é™çº§å¤„ç†ï¼Œä½¿ç”¨æ›´å®½æ¾çš„é…ç½®
                        try:
                            logger.info(f"ğŸ” æ–¹å¼4: é™çº§å¤„ç†ï¼Œä½¿ç”¨æ›´å®½æ¾çš„é…ç½®")
                            limited_opts = {
                                "quiet": True,
                                "extract_flat": True,
                                "socket_timeout": 180,
                                "retries": 3,
                                "playlistend": None,  # ä¸é™åˆ¶ï¼Œè·å–æ‰€æœ‰è§†é¢‘
                                "sleep_interval": 1,  # å‡å°‘è¯·æ±‚é—´éš”
                            }
                            if self.proxy_host:
                                limited_opts["proxy"] = self.proxy_host
                            if self.b_cookies_path and os.path.exists(self.b_cookies_path):
                                limited_opts["cookiefile"] = self.b_cookies_path

                            with yt_dlp.YoutubeDL(limited_opts) as ydl:
                                info = ydl.extract_info(user_space_url, download=False)
                            logger.info("âœ… æ–¹å¼4æˆåŠŸï¼ˆå®½æ¾é…ç½®ï¼‰")
                        except Exception as e4:
                            last_error = str(e4)
                            logger.error(f"âŒ æ–¹å¼4å¤±è´¥: {e4}")

                            # æ–¹å¼5: æœ€åå°è¯•ï¼Œä½¿ç”¨æœ€ç®€å•çš„é…ç½®ä½†è·å–æ‰€æœ‰è§†é¢‘
                            try:
                                logger.info(f"ğŸ” æ–¹å¼5: æœ€ç®€é…ç½®å°è¯•ï¼ˆè·å–æ‰€æœ‰è§†é¢‘ï¼‰")
                                simple_opts = {
                                    "quiet": True,
                                    "extract_flat": True,
                                    "playlistend": None,  # ä¸é™åˆ¶ï¼Œè·å–æ‰€æœ‰è§†é¢‘
                                    "socket_timeout": 120,
                                    "retries": 3,
                                }
                                if self.b_cookies_path and os.path.exists(self.b_cookies_path):
                                    simple_opts["cookiefile"] = self.b_cookies_path

                                with yt_dlp.YoutubeDL(simple_opts) as ydl:
                                    info = ydl.extract_info(user_space_url, download=False)
                                logger.info("âœ… æ–¹å¼5æˆåŠŸï¼ˆæœ€ç®€æ¨¡å¼ï¼Œè·å–æ‰€æœ‰è§†é¢‘ï¼‰")
                            except Exception as e5:
                                last_error = str(e5)
                                logger.error(f"âŒ æ–¹å¼5å¤±è´¥: {e5}")

                                # æ–¹å¼6: å¦‚æœè¿˜æ˜¯å¤±è´¥ï¼Œå°è¯•åˆ†é¡µè·å–
                                try:
                                    logger.info(f"ğŸ” æ–¹å¼6: åˆ†é¡µè·å–æ¨¡å¼")
                                    paginated_opts = {
                                        "quiet": True,
                                        "extract_flat": True,
                                        "playlistend": 500,  # é™åˆ¶ä¸º500ä¸ªï¼Œé¿å…è¶…æ—¶
                                        "socket_timeout": 180,
                                        "retries": 2,
                                    }
                                    if self.b_cookies_path and os.path.exists(self.b_cookies_path):
                                        paginated_opts["cookiefile"] = self.b_cookies_path

                                    with yt_dlp.YoutubeDL(paginated_opts) as ydl:
                                        info = ydl.extract_info(user_space_url, download=False)
                                    logger.info("âœ… æ–¹å¼6æˆåŠŸï¼ˆåˆ†é¡µæ¨¡å¼ï¼‰")
                                except Exception as e6:
                                    last_error = str(e6)
                                    logger.error(f"âŒ æ–¹å¼6å¤±è´¥: {e6}")

            if not info:
                error_msg = f"æ— æ³•è·å–UPä¸» {uid} çš„è§†é¢‘ä¿¡æ¯ã€‚æœ€åé”™è¯¯: {last_error}"
                logger.error(error_msg)

                # æ£€æŸ¥æ˜¯å¦æ˜¯Bç«™é™åˆ¶é—®é¢˜
                if "352" in str(last_error) or "rejected by server" in str(last_error).lower():
                    error_msg += "\n\nğŸ’¡ å»ºè®®è§£å†³æ–¹æ¡ˆ:\n1. é…ç½®Bç«™cookiesæ–‡ä»¶\n2. ä½¿ç”¨ä»£ç†æœåŠ¡å™¨\n3. ç¨åé‡è¯•"

                return {'success': False, 'error': error_msg}

            # è·å–UPä¸»ä¿¡æ¯
            uploader_name = info.get('uploader', f'UPä¸»_{uid}')
            uploader_id = info.get('uploader_id', uid)

            # è·å–è§†é¢‘åˆ—è¡¨
            entries = info.get('entries', [])
            if not entries:
                error_msg = f"UPä¸» {uid} æ²¡æœ‰ä»»ä½•è§†é¢‘"
                logger.error(error_msg)
                return {'success': False, 'error': error_msg}

            logger.info(f"ğŸ“Š æ‰¾åˆ° {len(entries)} ä¸ªè§†é¢‘")

            # æ£€æŸ¥æ˜¯å¦è·å–å®Œæ•´
            total_count = info.get('playlist_count') or info.get('_total_count') or len(entries)
            if total_count and total_count > len(entries):
                logger.warning(f"âš ï¸ å¯èƒ½æœªè·å–å®Œæ•´è§†é¢‘åˆ—è¡¨: è·å–åˆ° {len(entries)} ä¸ªï¼Œé¢„æœŸ {total_count} ä¸ª")
            else:
                logger.info(f"âœ… æˆåŠŸè·å–å®Œæ•´è§†é¢‘åˆ—è¡¨: {len(entries)} ä¸ªè§†é¢‘")

            if message_updater:
                try:
                    # message_updateræ˜¯åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                    message_updater(f"ğŸ” æ­£åœ¨åˆ†æ {len(entries)} ä¸ªè§†é¢‘...")
                except Exception as e:
                    logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")

            # æ­¥éª¤2: åˆ›å»ºUPä¸»ä¸“ç”¨ä¸‹è½½ç›®å½•ï¼ˆå‚è€ƒYouTubeé¢‘é“æ¨¡å¼ï¼‰
            # æ¸…ç†UPä¸»åç§°ï¼Œç§»é™¤æ–‡ä»¶ç³»ç»Ÿä¸æ”¯æŒçš„å­—ç¬¦
            clean_uploader_name = re.sub(r'[\\/:*?"<>|]', "_", uploader_name).strip()
            user_download_path = download_path / clean_uploader_name
            user_download_path.mkdir(parents=True, exist_ok=True)
            logger.info(f"ğŸ“ UPä¸»ç›®å½•: {user_download_path}")

            # æ­¥éª¤3: ç®€åŒ–åˆ†æï¼šæŒ‰æ’­æ”¾åˆ—è¡¨åˆ†ç»„ï¼Œä½†ä¸è¿›è¡Œå¤æ‚çš„ç±»å‹æ£€æµ‹
            logger.info("ğŸš€ é‡‡ç”¨ç®€åŒ–æ’­æ”¾åˆ—è¡¨åˆ†æ–‡ä»¶å¤¹æ¨¡å¼")
            logger.info("ğŸ” æ­¥éª¤3: ç®€å•åˆ†ææ’­æ”¾åˆ—è¡¨...")

            if message_updater and callable(message_updater):
                try:
                    # message_updateræ˜¯åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                    message_updater(f"ğŸ” æ­£åœ¨åˆ†æ {len(entries)} ä¸ªè§†é¢‘çš„æ’­æ”¾åˆ—è¡¨...")
                except Exception as e:
                    logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")
            elif message_updater:
                logger.warning("âš ï¸ message_updater ä¸æ˜¯å¯è°ƒç”¨å¯¹è±¡")

            # å¢å¼ºåˆé›†è¯†åˆ«ï¼šåŸºäºURLç‰¹å¾ã€æ ‡é¢˜æ¨¡å¼å’ŒBVå·
            playlists = {}
            single_videos = []

            # ç”¨äºå­˜å‚¨BVå·å¯¹åº”çš„åˆé›†ä¿¡æ¯
            bv_playlists = {}

            for entry in entries:
                if not entry:
                    continue

                video_url = entry.get('url') or entry.get('webpage_url')
                video_title = entry.get('title', '')

                if not video_url:
                    single_videos.append(entry)
                    continue

                # æ£€æŸ¥URLä¸­æ˜¯å¦æœ‰æ˜æ˜¾çš„æ’­æ”¾åˆ—è¡¨æ ‡è¯†
                playlist_id = None
                playlist_name = "æœªçŸ¥æ’­æ”¾åˆ—è¡¨"
                playlist_type = "unknown"

                # æ£€æŸ¥UGCåˆé›† (list_idå‚æ•°)
                if 'list_id=' in video_url:
                    match = re.search(r'list_id=(\d+)', video_url)
                    if match:
                        playlist_id = f"ugc_{match.group(1)}"
                        playlist_name = f"UGCåˆé›†_{match.group(1)}"
                        playlist_type = "ugc"

                # æ£€æŸ¥å¤šPè§†é¢‘ (p=å‚æ•°)
                elif '?p=' in video_url or '&p=' in video_url:
                    bv_match = re.search(r'BV([A-Za-z0-9]+)', video_url)
                    if bv_match:
                        bv_id = bv_match.group(1)
                        playlist_id = f"multipart_{bv_id}"
                        # ä»æ ‡é¢˜ä¸­æå–åˆé›†åç§°
                        if 'ã€' in video_title and 'ã€‘' in video_title:
                            # æå–ã€ã€‘ä¸­çš„å†…å®¹ä½œä¸ºåˆé›†å
                            title_match = re.search(r'ã€([^ã€‘]+)ã€‘', video_title)
                            if title_match:
                                playlist_name = title_match.group(1)
                            else:
                                playlist_name = f"å¤šPè§†é¢‘_{bv_id}"
                        else:
                            playlist_name = f"å¤šPè§†é¢‘_{bv_id}"
                        playlist_type = "multipart"

                # å¢å¼ºï¼šæ£€æŸ¥æ ‡é¢˜æ¨¡å¼è¯†åˆ«åˆé›†
                if not playlist_id and video_title:
                    # æ£€æŸ¥æ ‡é¢˜ä¸­çš„åˆé›†æ ‡è¯†
                    title_patterns = [
                        r'ç¬¬(\d+)é›†',           # ç¬¬Xé›†
                        r'Part\s*(\d+)',       # Part X
                        r'(\d+)\s*[è¯è©±]',     # Xè¯
                        r'ç¬¬(\d+)ç« ',           # ç¬¬Xç« 
                        r'ç¬¬(\d+)å›',           # ç¬¬Xå›
                        r'(\d+)\s*[æœŸæœŸ]',     # XæœŸ
                        r'ç¬¬(\d+)è¯¾',           # ç¬¬Xè¯¾
                        r'ç¬¬(\d+)è®²',           # ç¬¬Xè®²
                    ]

                    for pattern in title_patterns:
                        match = re.search(pattern, video_title)
                        if match:
                            episode_num = match.group(1)
                            # æå–åˆé›†åç§°ï¼ˆå»æ‰é›†æ•°éƒ¨åˆ†ï¼‰
                            clean_title = re.sub(pattern, '', video_title).strip()
                            clean_title = re.sub(r'[ã€ã€‘\[\]\(\)ï¼ˆï¼‰]', '', clean_title).strip()

                            if clean_title:
                                # ä½¿ç”¨æ¸…ç†åçš„æ ‡é¢˜ä½œä¸ºåˆé›†å
                                playlist_id = f"title_pattern_{clean_title}"
                                playlist_name = clean_title
                                playlist_type = "title_pattern"
                                break

                # å¦‚æœé€šè¿‡æ ‡é¢˜æ¨¡å¼è¯†åˆ«åˆ°åˆé›†ï¼Œæ£€æŸ¥æ˜¯å¦æœ‰å¯¹åº”çš„BVå·
                if playlist_id and playlist_type == "title_pattern":
                    bv_match = re.search(r'BV([A-Za-z0-9]+)', video_url)
                    if bv_match:
                        bv_id = bv_match.group(1)
                        # æ£€æŸ¥æ˜¯å¦æœ‰ç›¸åŒBVå·çš„å…¶ä»–è§†é¢‘
                        if bv_id in bv_playlists:
                            # å¦‚æœBVå·å·²å­˜åœ¨ï¼Œä½¿ç”¨ç›¸åŒçš„playlist_id
                            playlist_id = bv_playlists[bv_id]
                        else:
                            # è®°å½•è¿™ä¸ªBVå·å¯¹åº”çš„playlist_id
                            bv_playlists[bv_id] = playlist_id

                if playlist_id:
                    if playlist_id not in playlists:
                        playlists[playlist_id] = {
                            'name': playlist_name,
                            'type': playlist_type,
                            'videos': []
                        }
                    playlists[playlist_id]['videos'].append(entry)
                else:
                    single_videos.append(entry)

            logger.info(f"ğŸ“Š ç®€å•åˆ†ç»„ç»“æœ: {len(playlists)} ä¸ªæ’­æ”¾åˆ—è¡¨, {len(single_videos)} ä¸ªå•ç‹¬è§†é¢‘")

            # æ˜¾ç¤ºé¢„æœŸçš„ç›®å½•ç»“æ„
            logger.info("ğŸ“ é¢„æœŸç›®å½•ç»“æ„:")
            logger.info(f"  ğŸ“‚ UPä¸»ç›®å½•: {user_download_path}")
            for playlist_id, playlist_info in playlists.items():
                playlist_name = playlist_info['name']
                logger.info(f"    ğŸ“ åˆé›†: {playlist_name}/")
            if single_videos:
                logger.info(f"    ğŸ“ å•ç‹¬è§†é¢‘/")

            # æ­¥éª¤5: ä½¿ç”¨ç°æœ‰ä¸‹è½½æ–¹æ³•ï¼Œå¤ç”¨è¿›åº¦æ˜¾ç¤ºå’Œå®Œæˆé€»è¾‘
            logger.info("ğŸ” æ­¥éª¤5: ä½¿ç”¨ç°æœ‰ä¸‹è½½æ–¹æ³•å¤„ç†å„ç±»è§†é¢‘...")

            downloaded_results = []
            total_downloaded = 0
            total_failed = 0
            total_size_mb = 0

            # å¤„ç†æ’­æ”¾åˆ—è¡¨ï¼ˆUGCåˆé›†ã€å¤šPè§†é¢‘ç­‰ï¼‰
            playlist_index = 0
            for playlist_id, playlist_info in playlists.items():
                try:
                    playlist_index += 1
                    playlist_name = playlist_info['name']
                    videos = playlist_info['videos']

                    if message_updater:
                        try:
                            initial_msg = f"""ğŸ“¥ æ­£åœ¨ä¸‹è½½ç¬¬{playlist_index}/{len(playlists)}ä¸ªæ’­æ”¾åˆ—è¡¨ï¼š{playlist_name}

ğŸ“º æ€»è§†é¢‘æ•°: {len(videos)}
ğŸ“Š çŠ¶æ€: å¼€å§‹ä¸‹è½½..."""
                            import asyncio
                            if asyncio.iscoroutinefunction(message_updater):
                                await message_updater(initial_msg)
                            elif callable(message_updater):
                                message_updater(initial_msg)
                        except Exception as e:
                            logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")

                    logger.info(f"ğŸ¬ å¼€å§‹å¤„ç†æ’­æ”¾åˆ—è¡¨: {playlist_name} ({len(videos)} ä¸ªè§†é¢‘)")

                    # ä¸ºæ’­æ”¾åˆ—è¡¨ä¸­çš„æ¯ä¸ªè§†é¢‘è°ƒç”¨ç°æœ‰çš„ä¸‹è½½æ–¹æ³•
                    playlist_downloaded = 0
                    playlist_failed = 0

                    # åˆ›å»ºæ’­æ”¾åˆ—è¡¨ç›®å½•
                    playlist_path = user_download_path / playlist_name
                    playlist_path.mkdir(parents=True, exist_ok=True)
                    logger.info(f"ğŸ“ åˆ›å»ºæ’­æ”¾åˆ—è¡¨ç›®å½•: {playlist_path}")

                    for video_idx, video in enumerate(videos, 1):
                        video_url = video.get('url') or video.get('webpage_url')
                        video_title = video.get('title', '')

                        if video_url:
                            try:
                                logger.info(f"ğŸ¬ è°ƒç”¨ç°æœ‰ä¸‹è½½æ–¹æ³•å¤„ç†è§†é¢‘ {video_idx}/{len(videos)}: {video_url}")
                                logger.info(f"ğŸ” ä¼ é€’ç»™download_videoçš„message_updater: {type(message_updater)}, callable: {callable(message_updater)}")

                                # ç”Ÿæˆæ›´å¥½çš„æ–‡ä»¶å
                                clean_title = re.sub(r'[\\/:*?"<>|]', "_", video_title).strip()
                                if playlist_type == "multipart":
                                    # å¤šPè§†é¢‘ä½¿ç”¨é›†æ•°å‘½å
                                    episode_match = re.search(r'p=(\d+)', video_url)
                                    if episode_match:
                                        episode_num = episode_match.group(1)
                                        filename = f"{episode_num:02d}. {clean_title}.mp4"
                                    else:
                                        filename = f"{video_idx:02d}. {clean_title}.mp4"
                                elif playlist_type == "title_pattern":
                                    # æ ‡é¢˜æ¨¡å¼è¯†åˆ«çš„åˆé›†ï¼Œå°è¯•æå–é›†æ•°
                                    episode_patterns = [
                                        r'ç¬¬(\d+)é›†', r'Part\s*(\d+)', r'(\d+)\s*[è¯è©±]',
                                        r'ç¬¬(\d+)ç« ', r'ç¬¬(\d+)å›', r'(\d+)\s*[æœŸæœŸ]',
                                        r'ç¬¬(\d+)è¯¾', r'ç¬¬(\d+)è®²'
                                    ]
                                    episode_num = None
                                    for pattern in episode_patterns:
                                        match = re.search(pattern, video_title)
                                        if match:
                                            episode_num = int(match.group(1))
                                            break

                                    if episode_num:
                                        filename = f"{episode_num:02d}. {clean_title}.mp4"
                                    else:
                                        filename = f"{video_idx:02d}. {clean_title}.mp4"
                                else:
                                    # å…¶ä»–ç±»å‹ä½¿ç”¨ç´¢å¼•å‘½å
                                    filename = f"{video_idx:02d}. {clean_title}.mp4"

                                logger.info(f"ğŸ“ ç”Ÿæˆæ–‡ä»¶å: {filename}")



                                # ä¸´æ—¶ä¿®æ”¹ä¸‹è½½è·¯å¾„åˆ°æ’­æ”¾åˆ—è¡¨ç›®å½•
                                original_bilibili_path = self.bilibili_download_path
                                self.bilibili_download_path = playlist_path
                                logger.info(f"ğŸ”§ ä¸´æ—¶ä¿®æ”¹Bç«™ä¸‹è½½è·¯å¾„: {self.bilibili_download_path}")

                                try:
                                    # åˆ›å»ºåŒæ­¥è¿›åº¦æ›´æ–°å™¨ï¼Œå…¼å®¹yt-dlpçš„è¿›åº¦å›è°ƒ
                                    def progress_updater(progress_text):
                                        logger.info(f"ğŸ” æ’­æ”¾åˆ—è¡¨è¿›åº¦æ›´æ–°å™¨è¢«è°ƒç”¨: type={type(progress_text)}")

                                        if isinstance(progress_text, str):
                                            # å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œç›´æ¥æ˜¾ç¤º
                                            logger.info(f"ğŸ” æ”¶åˆ°å­—ç¬¦ä¸²æ¶ˆæ¯: {progress_text[:100]}...")
                                            # å¯¹äºå­—ç¬¦ä¸²æ¶ˆæ¯ï¼Œæˆ‘ä»¬æš‚æ—¶è·³è¿‡ï¼Œå› ä¸ºå¼‚æ­¥è°ƒç”¨å¤æ‚
                                            logger.info(f"âš ï¸ è·³è¿‡å­—ç¬¦ä¸²æ¶ˆæ¯çš„å¼‚æ­¥è°ƒç”¨")
                                        else:
                                            # å¦‚æœæ˜¯å­—å…¸ï¼ˆyt-dlpè¿›åº¦æ•°æ®ï¼‰ï¼Œè½¬æ¢ä¸ºæ ¼å¼åŒ–æ¶ˆæ¯
                                            d = progress_text
                                            logger.info(f"ğŸ” æ”¶åˆ°è¿›åº¦å­—å…¸: status={d.get('status')}, filename={d.get('filename', 'N/A')}")

                                            if d.get("status") == "downloading":
                                                # æ§åˆ¶æ›´æ–°é¢‘ç‡
                                                import time
                                                current_time = time.time()
                                                if not hasattr(progress_updater, 'last_update'):
                                                    progress_updater.last_update = 0

                                                if current_time - progress_updater.last_update < 3:  # 3ç§’æ›´æ–°ä¸€æ¬¡
                                                    return
                                                progress_updater.last_update = current_time
                                                # è·å–è¿›åº¦ä¿¡æ¯
                                                filename = d.get("filename", "æœªçŸ¥æ–‡ä»¶")
                                                if filename:
                                                    filename = os.path.basename(filename)

                                                # è°ƒè¯•ï¼šæ‰“å°æ‰€æœ‰å¯ç”¨çš„å­—æ®µ
                                                logger.info(f"ğŸ” æ’­æ”¾åˆ—è¡¨è¿›åº¦å­—å…¸æ‰€æœ‰å­—æ®µ: {list(d.keys())}")
                                                logger.info(f"ğŸ” æ’­æ”¾åˆ—è¡¨è¿›åº¦å­—å…¸å†…å®¹: {d}")

                                                downloaded_bytes = d.get("downloaded_bytes", 0)
                                                total_bytes = d.get("total_bytes") or d.get("total_bytes_estimate", 0)
                                                speed = d.get("speed", 0)

                                                # è°ƒè¯•ï¼šæ‰“å°åŸå§‹æ•°å€¼
                                                logger.info(f"ğŸ” æ’­æ”¾åˆ—è¡¨åŸå§‹æ•°å€¼: downloaded_bytes={downloaded_bytes}, total_bytes={total_bytes}, speed={speed}")

                                                # æ ¼å¼åŒ–å¤§å°å’Œé€Ÿåº¦
                                                downloaded_mb = downloaded_bytes / (1024 * 1024) if downloaded_bytes else 0
                                                total_mb = total_bytes / (1024 * 1024) if total_bytes else 0
                                                speed_mb = speed / (1024 * 1024) if speed else 0

                                                # è®¡ç®—è¿›åº¦
                                                if total_bytes > 0:
                                                    progress_percent = (downloaded_bytes / total_bytes) * 100
                                                else:
                                                    progress_percent = 0

                                                # è®¡ç®—é¢„è®¡å‰©ä½™æ—¶é—´
                                                eta_seconds = d.get("eta", 0)
                                                if eta_seconds and eta_seconds > 0:
                                                    eta_minutes = eta_seconds // 60
                                                    eta_secs = eta_seconds % 60
                                                    eta_str = f"{eta_minutes:02d}:{eta_secs:02d}"
                                                else:
                                                    eta_str = "æœªçŸ¥"

                                                # åˆ›å»ºè¿›åº¦æ¡
                                                bar_length = 20
                                                filled_length = int(bar_length * progress_percent / 100)
                                                bar = 'â–ˆ' * filled_length + 'â–‘' * (bar_length - filled_length)

                                                # æ„å»ºè¯¦ç»†çš„è¿›åº¦æ¶ˆæ¯
                                                progress_text = f"""ğŸ“¥ æ­£åœ¨ä¸‹è½½ç¬¬{playlist_index}/{len(playlists)}ä¸ªæ’­æ”¾åˆ—è¡¨ï¼š{playlist_name}

ğŸ“º å½“å‰è§†é¢‘: {video_idx}/{len(videos)}
ğŸ“ æ–‡ä»¶: {filename}
ğŸ’¾ å¤§å°: {downloaded_mb:.2f}MB / {total_mb:.2f}MB
âš¡ï¸ é€Ÿåº¦: {speed_mb:.2f}MB/s
â³ é¢„è®¡å‰©ä½™: {eta_str}
ğŸ“Š è¿›åº¦: [{bar}] {progress_percent:.1f}%"""

                                                # å‘é€è¿›åº¦æ¶ˆæ¯ï¼ˆä½¿ç”¨çº¿ç¨‹å®‰å…¨çš„æ–¹å¼ï¼‰
                                                if message_updater and callable(message_updater):
                                                    try:
                                                        import asyncio
                                                        import threading

                                                        # ç›´æ¥è°ƒç”¨åŒæ­¥çš„message_updaterï¼ˆupdate_progressï¼‰ï¼Œçº¿ç¨‹å®‰å…¨åœ°ç¼–è¾‘TGæ¶ˆæ¯
                                                        try:
                                                            message_updater(progress_text)
                                                            logger.info(f"âœ… æ’­æ”¾åˆ—è¡¨è¿›åº¦æ¶ˆæ¯å‘é€æˆåŠŸ")
                                                        except Exception as e:
                                                            logger.warning(f"å‘é€æ’­æ”¾åˆ—è¡¨è¿›åº¦æ¶ˆæ¯å¤±è´¥: {e}")

                                                    except Exception as e:
                                                        logger.warning(f"åˆ›å»ºæ’­æ”¾åˆ—è¡¨è¿›åº¦æ¶ˆæ¯çº¿ç¨‹å¤±è´¥: {e}")

                                    # åˆ›å»ºç®€åŒ–çš„è¿›åº¦æ›´æ–°å™¨
                                    async def simple_progress_updater(progress_text):
                                        try:
                                            logger.info(f"ğŸ” [DEBUG] æ’­æ”¾åˆ—è¡¨simple_progress_updaterè¢«è°ƒç”¨: type={type(progress_text)}")
                                            logger.info(f"ğŸ” [DEBUG] æ’­æ”¾åˆ—è¡¨message_updaterçŠ¶æ€: {message_updater}, type={type(message_updater)}")

                                            if isinstance(progress_text, str):
                                                # å­—ç¬¦ä¸²æ¶ˆæ¯ç›´æ¥å‘é€
                                                if message_updater and callable(message_updater):
                                                    logger.info(f"ğŸ” [DEBUG] æ’­æ”¾åˆ—è¡¨å‡†å¤‡è°ƒç”¨message_updater")
                                                    # message_updateræ˜¯åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                                                    message_updater(progress_text)
                                                    logger.info(f"âœ… [DEBUG] æ’­æ”¾åˆ—è¡¨message_updaterè°ƒç”¨æˆåŠŸ")
                                                else:
                                                    logger.warning(f"âš ï¸ [DEBUG] æ’­æ”¾åˆ—è¡¨message_updaterä¸å¯ç”¨: {message_updater}")
                                            else:
                                                # å­—å…¸æ•°æ®å¤„ç†ï¼Œè½¬æ¢ä¸ºè¿›åº¦æ¶ˆæ¯
                                                logger.info(f"ğŸ” [DEBUG] æ’­æ”¾åˆ—è¡¨å¤„ç†å­—å…¸æ•°æ®: {progress_text}")

                                                if isinstance(progress_text, dict) and progress_text.get("status") == "downloading":
                                                    d = progress_text

                                                    # è·å–è¿›åº¦ä¿¡æ¯
                                                    filename = d.get("filename", "æœªçŸ¥æ–‡ä»¶")
                                                    if filename:
                                                        filename = os.path.basename(filename)

                                                    downloaded_bytes = d.get("downloaded_bytes", 0)
                                                    total_bytes = d.get("total_bytes") or d.get("total_bytes_estimate", 0)
                                                    speed = d.get("speed", 0)

                                                    # æ ¼å¼åŒ–å¤§å°å’Œé€Ÿåº¦
                                                    downloaded_mb = downloaded_bytes / (1024 * 1024) if downloaded_bytes else 0
                                                    total_mb = total_bytes / (1024 * 1024) if total_bytes else 0
                                                    speed_mb = speed / (1024 * 1024) if speed else 0

                                                    # è®¡ç®—è¿›åº¦
                                                    if total_bytes > 0:
                                                        progress_percent = (downloaded_bytes / total_bytes) * 100
                                                    else:
                                                        progress_percent = 0

                                                    # è®¡ç®—é¢„è®¡å‰©ä½™æ—¶é—´
                                                    eta_seconds = d.get("eta", 0)
                                                    if eta_seconds and eta_seconds > 0:
                                                        if eta_seconds >= 3600:  # è¶…è¿‡1å°æ—¶
                                                            eta_hours = eta_seconds // 3600
                                                            eta_minutes = (eta_seconds % 3600) // 60
                                                            eta_str = f"{eta_hours}å°æ—¶{eta_minutes}åˆ†é’Ÿ"
                                                        elif eta_seconds >= 60:  # è¶…è¿‡1åˆ†é’Ÿ
                                                            eta_minutes = eta_seconds // 60
                                                            eta_secs = eta_seconds % 60
                                                            eta_str = f"{eta_minutes}åˆ†{eta_secs:02d}ç§’"
                                                        else:  # å°äº1åˆ†é’Ÿ
                                                            eta_str = f"{eta_seconds}ç§’"
                                                    else:
                                                        eta_str = "æœªçŸ¥"

                                                    # åˆ›å»ºè¿›åº¦æ¡ï¼ˆä½¿ç”¨ä½ è¦çš„æ ¼å¼ï¼‰
                                                    bar_length = 20
                                                    filled_length = int(bar_length * progress_percent / 100)
                                                    bar = 'â–ˆ' * filled_length + 'â–‘' * (bar_length - filled_length)

                                                    # æ„å»ºç®€æ´çš„è¿›åº¦æ¶ˆæ¯ï¼ˆä½ è¦çš„æ ¼å¼ï¼‰
                                                    progress_text = f"""ğŸ“¥ ä¸‹è½½ä¸­ ({video_idx}/{len(videos)})
ğŸ“ æ–‡ä»¶å: {filename}
ğŸ’¾ å¤§å°: {downloaded_mb:.2f}MB / {total_mb:.2f}MB
âš¡ï¸ é€Ÿåº¦: {speed_mb:.2f}MB/s
â³ é¢„è®¡å‰©ä½™: {eta_str}
ğŸ“Š è¿›åº¦: {bar} {progress_percent:.1f}%"""

                                                    # å‘é€è¿›åº¦æ¶ˆæ¯
                                                    if message_updater and callable(message_updater):
                                                        logger.info(f"ğŸ” [DEBUG] æ’­æ”¾åˆ—è¡¨å‘é€å®æ—¶è¿›åº¦æ¶ˆæ¯")
                                                        try:
                                                            # message_updateræ˜¯åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                                                            logger.info(f"ğŸ” [DEBUG] æ’­æ”¾åˆ—è¡¨è°ƒç”¨message_updater(dict): {type(message_updater)}")
                                                            message_updater(d)
                                                            logger.info(f"âœ… [DEBUG] æ’­æ”¾åˆ—è¡¨å®æ—¶è¿›åº¦å­—å…¸å‘é€æˆåŠŸ")
                                                        except Exception as e:
                                                            logger.warning(f"âŒ [DEBUG] æ’­æ”¾åˆ—è¡¨å®æ—¶è¿›åº¦æ¶ˆæ¯å‘é€å¤±è´¥: {e}")
                                                            logger.warning(f"ğŸ” [DEBUG] æ’­æ”¾åˆ—è¡¨message_updaterè¯¦æƒ…: {type(message_updater)}")
                                                            import traceback
                                                            logger.warning(f"ğŸ” [DEBUG] æ’­æ”¾åˆ—è¡¨å®Œæ•´é”™è¯¯å †æ ˆ: {traceback.format_exc()}")
                                                else:
                                                    logger.info(f"ğŸ” [DEBUG] æ’­æ”¾åˆ—è¡¨è·³è¿‡éä¸‹è½½çŠ¶æ€çš„å­—å…¸æ•°æ®: {progress_text.get('status') if isinstance(progress_text, dict) else 'unknown'}")
                                        except Exception as e:
                                            logger.warning(f"æ’­æ”¾åˆ—è¡¨ç®€åŒ–è¿›åº¦æ›´æ–°å¤±è´¥: {e}")
                                            logger.warning(f"ğŸ” [DEBUG] æ’­æ”¾åˆ—è¡¨å¼‚å¸¸è¯¦æƒ…: message_updater={message_updater}, progress_text={progress_text}")

                                    # è°ƒç”¨download_videoï¼Œç›´æ¥ä¼ é€’ä¸Šå±‚çš„message_updaterä»¥ä½¿ç”¨ç»Ÿä¸€çš„è¿›åº¦ç®¡é“
                                    result = await self.download_video(video_url, message_updater if message_updater else None)

                                    # æ‰‹åŠ¨å‘é€è¿›åº¦æ›´æ–°ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
                                    if message_updater and callable(message_updater):
                                        try:
                                            # è·å–æ–‡ä»¶å
                                            filename = "æœªçŸ¥æ–‡ä»¶"
                                            if result.get('success', False) and result.get('filename'):
                                                filename = os.path.basename(result.get('filename'))

                                            progress_msg = f"""ğŸ“¥ æ­£åœ¨ä¸‹è½½ç¬¬{playlist_index}/{len(playlists)}ä¸ªæ’­æ”¾åˆ—è¡¨ï¼š{playlist_name}

ğŸ“º å½“å‰è§†é¢‘: {video_idx}/{len(videos)}
ğŸ“ æ–‡ä»¶: {filename}
ğŸ“Š çŠ¶æ€: âœ… ä¸‹è½½å®Œæˆ
ğŸ’¾ å¤§å°: {result.get('size_mb', 0):.2f} MB"""
                                            # message_updateræ˜¯åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                                            message_updater(progress_msg)
                                            logger.info(f"âœ… æ‰‹åŠ¨å‘é€æ’­æ”¾åˆ—è¡¨è¿›åº¦æ›´æ–°æˆåŠŸ")
                                        except Exception as e:
                                            logger.warning(f"æ‰‹åŠ¨å‘é€æ’­æ”¾åˆ—è¡¨è¿›åº¦æ›´æ–°å¤±è´¥: {e}")

                                    # å‘é€ç®€æ´çš„è¿›åº¦æ›´æ–°ï¼Œè€Œä¸æ˜¯è¯¦ç»†çš„å®Œæˆæ¶ˆæ¯
                                    if result.get('success', False) and message_updater and callable(message_updater):
                                        try:
                                            # åªæ˜¾ç¤ºç®€å•çš„è¿›åº¦æ›´æ–°ï¼Œè¯¦ç»†æ€»ç»“åœ¨æœ€åæ˜¾ç¤º
                                            progress_text = f"""ğŸ“¥ æ­£åœ¨ä¸‹è½½ç¬¬{playlist_index}/{len(playlists)}ä¸ªæ’­æ”¾åˆ—è¡¨ï¼š{playlist_name}

ğŸ“º å½“å‰è§†é¢‘: {video_idx}/{len(videos)} âœ… ä¸‹è½½å®Œæˆ
ğŸ“ æ–‡ä»¶: {os.path.basename(result.get('filename', 'æœªçŸ¥æ–‡ä»¶'))}
ğŸ’¾ å¤§å°: {result.get('size_mb', 0):.2f} MB"""
                                            # message_updateræ˜¯åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                                            message_updater(progress_text)
                                            logger.info(f"âœ… æ’­æ”¾åˆ—è¡¨è§†é¢‘è¿›åº¦æ›´æ–°å·²å‘é€")
                                        except Exception as e:
                                            logger.warning(f"å‘é€æ’­æ”¾åˆ—è¡¨è§†é¢‘è¿›åº¦æ›´æ–°å¤±è´¥: {e}")

                                except Exception as e:
                                    logger.error(f"æ’­æ”¾åˆ—è¡¨è§†é¢‘ä¸‹è½½å¼‚å¸¸: {e}")
                                    if message_updater and callable(message_updater):
                                        try:
                                            # message_updateræ˜¯åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                                            message_updater(f"âŒ è§†é¢‘ä¸‹è½½å¤±è´¥: {str(e)}")
                                        except Exception as msg_e:
                                            logger.warning(f"å‘é€é”™è¯¯æ¶ˆæ¯å¤±è´¥: {msg_e}")
                                    result = {'success': False, 'error': str(e)}
                                finally:
                                    # æ¢å¤åŸå§‹ä¸‹è½½è·¯å¾„
                                    self.bilibili_download_path = original_bilibili_path
                                    logger.info(f"ğŸ”§ æ¢å¤Bç«™ä¸‹è½½è·¯å¾„: {self.bilibili_download_path}")

                                if result.get('success', False):
                                    playlist_downloaded += 1
                                    total_downloaded += 1
                                    # ç´¯è®¡æ–‡ä»¶å¤§å°
                                    if 'size_mb' in result:
                                        total_size_mb += result['size_mb']
                                    logger.info(f"âœ… æ’­æ”¾åˆ—è¡¨è§†é¢‘ä¸‹è½½æˆåŠŸ: {video_idx}/{len(videos)}")
                                else:
                                    playlist_failed += 1
                                    total_failed += 1
                                    logger.error(f"âŒ æ’­æ”¾åˆ—è¡¨è§†é¢‘ä¸‹è½½å¤±è´¥: {video_idx}/{len(videos)} - {result.get('error', 'æœªçŸ¥é”™è¯¯')}")

                            except Exception as e:
                                playlist_failed += 1
                                total_failed += 1
                                logger.error(f"âŒ æ’­æ”¾åˆ—è¡¨è§†é¢‘ä¸‹è½½å¼‚å¸¸: {video_idx}/{len(videos)} - {e}")

                    # è®°å½•æ’­æ”¾åˆ—è¡¨ç»“æœ
                    if playlist_downloaded > 0:
                        playlist_result = {
                            'title': playlist_name,
                            'type': 'æ’­æ”¾åˆ—è¡¨',
                            'video_count': playlist_downloaded,
                            'failed_count': playlist_failed,
                            'download_path': str(user_download_path / playlist_name)
                        }
                        downloaded_results.append(playlist_result)
                        logger.info(f"âœ… æ’­æ”¾åˆ—è¡¨å¤„ç†å®Œæˆ: {playlist_name} (æˆåŠŸ: {playlist_downloaded}, å¤±è´¥: {playlist_failed})")

                except Exception as e:
                    logger.error(f"âŒ æ’­æ”¾åˆ—è¡¨å¤„ç†å¼‚å¸¸: {playlist_name} - {e}")
                    total_failed += len(videos)

            # ä¸‹è½½å•ç‹¬è§†é¢‘
            if single_videos:
                try:
                    single_playlist_index = len(playlists) + 1
                    total_playlists_with_single = len(playlists) + 1

                    if message_updater:
                        try:
                            initial_msg = f"""ğŸ“¥ æ­£åœ¨ä¸‹è½½ç¬¬{single_playlist_index}/{total_playlists_with_single}ä¸ªæ’­æ”¾åˆ—è¡¨ï¼šå•ç‹¬è§†é¢‘

ğŸ“º æ€»è§†é¢‘æ•°: {len(single_videos)}
ğŸ“Š çŠ¶æ€: å¼€å§‹ä¸‹è½½..."""
                            import asyncio
                            if asyncio.iscoroutinefunction(message_updater):
                                await message_updater(initial_msg)
                            elif callable(message_updater):
                                message_updater(initial_msg)
                        except Exception as e:
                            logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")

                    logger.info(f"ğŸ¬ å¼€å§‹å¤„ç†å•ç‹¬è§†é¢‘: {len(single_videos)} ä¸ª")

                    # ä¸ºæ¯ä¸ªå•ç‹¬è§†é¢‘è°ƒç”¨ç°æœ‰çš„ä¸‹è½½æ–¹æ³•
                    single_downloaded = 0
                    single_failed = 0

                    for video_idx, video in enumerate(single_videos, 1):
                        video_url = video.get('url') or video.get('webpage_url')
                        if video_url:
                            try:
                                logger.info(f"ğŸ¬ è°ƒç”¨ç°æœ‰ä¸‹è½½æ–¹æ³•å¤„ç†å•ç‹¬è§†é¢‘ {video_idx}/{len(single_videos)}: {video_url}")
                                logger.info(f"ğŸ” ä¼ é€’ç»™download_videoçš„message_updater: {type(message_updater)}, callable: {callable(message_updater)}")



                                # åˆ›å»ºå•ç‹¬è§†é¢‘ç›®å½•ï¼ˆä¸åˆé›†åŒçº§ï¼‰
                                single_video_path = user_download_path / "å•ç‹¬è§†é¢‘"
                                single_video_path.mkdir(parents=True, exist_ok=True)
                                logger.info(f"ğŸ“ åˆ›å»ºå•ç‹¬è§†é¢‘ç›®å½•: {single_video_path}")

                                # ç”Ÿæˆæ›´å¥½çš„æ–‡ä»¶å
                                video_title = video.get('title', '')
                                clean_title = re.sub(r'[\\/:*?"<>|]', '_', video_title).strip()
                                filename = f"{video_idx:02d}. {clean_title}.mp4"
                                logger.info(f"ğŸ“ ç”Ÿæˆå•è§†é¢‘æ–‡ä»¶å: {filename}")



                                # ä¸´æ—¶ä¿®æ”¹ä¸‹è½½è·¯å¾„åˆ°å•ç‹¬è§†é¢‘ç›®å½•
                                original_bilibili_path = self.bilibili_download_path
                                self.bilibili_download_path = single_video_path
                                logger.info(f"ğŸ”§ ä¸´æ—¶ä¿®æ”¹Bç«™ä¸‹è½½è·¯å¾„: {self.bilibili_download_path}")

                                try:
                                    # åˆ›å»ºç®€åŒ–çš„è¿›åº¦æ›´æ–°å™¨ï¼Œç¡®ä¿èƒ½æ­£å¸¸å·¥ä½œ
                                    def progress_updater(progress_text):
                                        logger.info(f"ğŸ” [DEBUG] å•ç‹¬è§†é¢‘è¿›åº¦æ›´æ–°å™¨è¢«è°ƒç”¨: type={type(progress_text)}")

                                        if isinstance(progress_text, str):
                                            # å¦‚æœæ˜¯å­—ç¬¦ä¸²ï¼Œç›´æ¥æ˜¾ç¤º
                                            logger.info(f"ğŸ” [DEBUG] æ”¶åˆ°å­—ç¬¦ä¸²æ¶ˆæ¯: {progress_text[:100]}...")
                                        else:
                                            # å¦‚æœæ˜¯å­—å…¸ï¼ˆyt-dlpè¿›åº¦æ•°æ®ï¼‰ï¼Œè½¬æ¢ä¸ºæ ¼å¼åŒ–æ¶ˆæ¯
                                            d = progress_text
                                            logger.info(f"ğŸ” [DEBUG] æ”¶åˆ°è¿›åº¦å­—å…¸: status={d.get('status')}")

                                            if d.get("status") == "downloading":
                                                logger.info(f"ğŸ” [DEBUG] å¤„ç†ä¸‹è½½è¿›åº¦...")

                                                # ç®€åŒ–çš„è¿›åº¦æ¶ˆæ¯ï¼Œå…ˆç¡®ä¿åŸºæœ¬åŠŸèƒ½å·¥ä½œ
                                                filename = d.get("filename", "æœªçŸ¥æ–‡ä»¶")
                                                if filename:
                                                    filename = os.path.basename(filename)

                                                simple_progress = f"""ğŸ“¥ æ­£åœ¨ä¸‹è½½ç¬¬{single_playlist_index}/{total_playlists_with_single}ä¸ªæ’­æ”¾åˆ—è¡¨ï¼šå•ç‹¬è§†é¢‘

ğŸ“º å½“å‰è§†é¢‘: {video_idx}/{len(single_videos)}
ğŸ“ æ–‡ä»¶: {filename}
ğŸ“Š çŠ¶æ€: ä¸‹è½½ä¸­..."""

                                                logger.info(f"ğŸ” [DEBUG] å‡†å¤‡å‘é€ç®€åŒ–è¿›åº¦æ¶ˆæ¯")

                                                # ç›´æ¥å°è¯•å‘é€æ¶ˆæ¯ï¼Œä¸ä½¿ç”¨å¤æ‚çš„çº¿ç¨‹
                                                if message_updater and callable(message_updater):
                                                    try:
                                                        logger.info(f"ğŸ” [DEBUG] å°è¯•å‘é€è¿›åº¦æ¶ˆæ¯...")
                                                        # æš‚æ—¶è·³è¿‡å¼‚æ­¥è°ƒç”¨ï¼Œåªè®°å½•æ—¥å¿—
                                                        logger.info(f"âœ… [DEBUG] æ¨¡æ‹Ÿå‘é€è¿›åº¦æ¶ˆæ¯æˆåŠŸ")
                                                    except Exception as e:
                                                        logger.warning(f"âŒ [DEBUG] å‘é€è¿›åº¦æ¶ˆæ¯å¤±è´¥: {e}")
                                                # è·å–è¿›åº¦ä¿¡æ¯
                                                filename = d.get("filename", "æœªçŸ¥æ–‡ä»¶")
                                                if filename:
                                                    filename = os.path.basename(filename)

                                                # è°ƒè¯•ï¼šæ‰“å°æ‰€æœ‰å¯ç”¨çš„å­—æ®µ
                                                logger.info(f"ğŸ” è¿›åº¦å­—å…¸æ‰€æœ‰å­—æ®µ: {list(d.keys())}")
                                                logger.info(f"ğŸ” è¿›åº¦å­—å…¸å†…å®¹: {d}")

                                                downloaded_bytes = d.get("downloaded_bytes", 0)
                                                total_bytes = d.get("total_bytes") or d.get("total_bytes_estimate", 0)
                                                speed = d.get("speed", 0)

                                                # è°ƒè¯•ï¼šæ‰“å°åŸå§‹æ•°å€¼
                                                logger.info(f"ğŸ” åŸå§‹æ•°å€¼: downloaded_bytes={downloaded_bytes}, total_bytes={total_bytes}, speed={speed}")

                                                # æ ¼å¼åŒ–å¤§å°å’Œé€Ÿåº¦
                                                downloaded_mb = downloaded_bytes / (1024 * 1024) if downloaded_bytes else 0
                                                total_mb = total_bytes / (1024 * 1024) if total_bytes else 0
                                                speed_mb = speed / (1024 * 1024) if speed else 0

                                                # è®¡ç®—è¿›åº¦
                                                if total_bytes > 0:
                                                    progress_percent = (downloaded_bytes / total_bytes) * 100
                                                else:
                                                    progress_percent = 0

                                                # è®¡ç®—é¢„è®¡å‰©ä½™æ—¶é—´
                                                eta_seconds = d.get("eta", 0)
                                                if eta_seconds and eta_seconds > 0:
                                                    eta_minutes = eta_seconds // 60
                                                    eta_secs = eta_seconds % 60
                                                    eta_str = f"{eta_minutes:02d}:{eta_secs:02d}"
                                                else:
                                                    eta_str = "æœªçŸ¥"

                                                # åˆ›å»ºè¿›åº¦æ¡
                                                bar_length = 20
                                                filled_length = int(bar_length * progress_percent / 100)
                                                bar = 'â–ˆ' * filled_length + 'â–‘' * (bar_length - filled_length)

                                                # æ„å»ºè¯¦ç»†çš„è¿›åº¦æ¶ˆæ¯
                                                progress_text = f"""ğŸ“¥ æ­£åœ¨ä¸‹è½½ç¬¬{single_playlist_index}/{total_playlists_with_single}ä¸ªæ’­æ”¾åˆ—è¡¨ï¼šå•ç‹¬è§†é¢‘

ğŸ“º å½“å‰è§†é¢‘: {video_idx}/{len(single_videos)}
ğŸ“ æ–‡ä»¶: {filename}
ğŸ’¾ å¤§å°: {downloaded_mb:.2f}MB / {total_mb:.2f}MB
âš¡ï¸ é€Ÿåº¦: {speed_mb:.2f}MB/s
â³ é¢„è®¡å‰©ä½™: {eta_str}
ğŸ“Š è¿›åº¦: [{bar}] {progress_percent:.1f}%"""

                                                # å‘é€è¿›åº¦æ¶ˆæ¯ï¼ˆä½¿ç”¨çº¿ç¨‹å®‰å…¨çš„æ–¹å¼ï¼‰
                                                if message_updater and callable(message_updater):
                                                    try:
                                                        import asyncio
                                                        import threading

                                                        # åˆ›å»ºä¸€ä¸ªæ–°çº¿ç¨‹æ¥å¤„ç†å¼‚æ­¥è°ƒç”¨
                                                        def send_progress_message():
                                                            try:
                                                                # åœ¨æ–°çº¿ç¨‹ä¸­åˆ›å»ºäº‹ä»¶å¾ªç¯
                                                                loop = asyncio.new_event_loop()
                                                                asyncio.set_event_loop(loop)

                                                                # è¿è¡Œå¼‚æ­¥å‡½æ•°
                                                                loop.run_until_complete(message_updater(progress_text))
                                                                loop.close()

                                                                logger.info(f"âœ… çº¿ç¨‹ä¸­æˆåŠŸå‘é€è¿›åº¦æ¶ˆæ¯")
                                                            except Exception as e:
                                                                logger.warning(f"çº¿ç¨‹ä¸­å‘é€è¿›åº¦æ¶ˆæ¯å¤±è´¥: {e}")

                                                        # å¯åŠ¨çº¿ç¨‹ï¼ˆä¸ç­‰å¾…å®Œæˆï¼‰
                                                        thread = threading.Thread(target=send_progress_message, daemon=True)
                                                        thread.start()

                                                    except Exception as e:
                                                        logger.warning(f"åˆ›å»ºè¿›åº¦æ¶ˆæ¯çº¿ç¨‹å¤±è´¥: {e}")

                                    # åˆ›å»ºç®€åŒ–çš„è¿›åº¦æ›´æ–°å™¨
                                    async def simple_progress_updater(progress_text):
                                        try:
                                            logger.info(f"ğŸ” [DEBUG] simple_progress_updaterè¢«è°ƒç”¨: type={type(progress_text)}")
                                            logger.info(f"ğŸ” [DEBUG] message_updaterçŠ¶æ€: {message_updater}, type={type(message_updater)}")

                                            if isinstance(progress_text, str):
                                                # å­—ç¬¦ä¸²æ¶ˆæ¯ç›´æ¥å‘é€
                                                if message_updater and callable(message_updater):
                                                    logger.info(f"ğŸ” [DEBUG] å‡†å¤‡è°ƒç”¨message_updater")
                                                    # message_updateræ˜¯åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                                                    message_updater(progress_text)
                                                    logger.info(f"âœ… [DEBUG] message_updaterè°ƒç”¨æˆåŠŸ")
                                                else:
                                                    logger.warning(f"âš ï¸ [DEBUG] message_updaterä¸å¯ç”¨: {message_updater}")
                                            else:
                                                # å­—å…¸æ•°æ®å¤„ç†ï¼Œè½¬æ¢ä¸ºè¿›åº¦æ¶ˆæ¯
                                                logger.info(f"ğŸ” [DEBUG] å¤„ç†å­—å…¸æ•°æ®: {progress_text}")

                                                if isinstance(progress_text, dict) and progress_text.get("status") == "downloading":
                                                    d = progress_text

                                                    # è·å–è¿›åº¦ä¿¡æ¯
                                                    filename = d.get("filename", "æœªçŸ¥æ–‡ä»¶")
                                                    if filename:
                                                        filename = os.path.basename(filename)

                                                    downloaded_bytes = d.get("downloaded_bytes", 0)
                                                    total_bytes = d.get("total_bytes") or d.get("total_bytes_estimate", 0)
                                                    speed = d.get("speed", 0)

                                                    # æ ¼å¼åŒ–å¤§å°å’Œé€Ÿåº¦
                                                    downloaded_mb = downloaded_bytes / (1024 * 1024) if downloaded_bytes else 0
                                                    total_mb = total_bytes / (1024 * 1024) if total_bytes else 0
                                                    speed_mb = speed / (1024 * 1024) if speed else 0

                                                    # è®¡ç®—è¿›åº¦
                                                    if total_bytes > 0:
                                                        progress_percent = (downloaded_bytes / total_bytes) * 100
                                                    else:
                                                        progress_percent = 0

                                                    # è®¡ç®—é¢„è®¡å‰©ä½™æ—¶é—´
                                                    eta_seconds = d.get("eta", 0)
                                                    if eta_seconds and eta_seconds > 0:
                                                        if eta_seconds >= 3600:  # è¶…è¿‡1å°æ—¶
                                                            eta_hours = eta_seconds // 3600
                                                            eta_minutes = (eta_seconds % 3600) // 60
                                                            eta_str = f"{eta_hours}å°æ—¶{eta_minutes}åˆ†é’Ÿ"
                                                        elif eta_seconds >= 60:  # è¶…è¿‡1åˆ†é’Ÿ
                                                            eta_minutes = eta_seconds // 60
                                                            eta_secs = eta_seconds % 60
                                                            eta_str = f"{eta_minutes}åˆ†{eta_secs:02d}ç§’"
                                                        else:  # å°äº1åˆ†é’Ÿ
                                                            eta_str = f"{eta_seconds}ç§’"
                                                    else:
                                                        eta_str = "æœªçŸ¥"

                                                    # åˆ›å»ºè¿›åº¦æ¡ï¼ˆä½¿ç”¨ä½ è¦çš„æ ¼å¼ï¼‰
                                                    bar_length = 20
                                                    filled_length = int(bar_length * progress_percent / 100)
                                                    bar = 'â–‘' * bar_length  # å…ˆå…¨éƒ¨ç”¨ç©ºå¿ƒ
                                                    # ç„¶åå¡«å……å®å¿ƒéƒ¨åˆ†ï¼ˆä»å·¦åˆ°å³ï¼‰
                                                    bar = 'â–ˆ' * filled_length + 'â–‘' * (bar_length - filled_length)

                                                    # æ„å»ºç®€æ´çš„è¿›åº¦æ¶ˆæ¯ï¼ˆä½ è¦çš„æ ¼å¼ï¼‰
                                                    progress_text = f"""ğŸ“¥ ä¸‹è½½ä¸­
ğŸ“ æ–‡ä»¶å: {filename}
ğŸ’¾ å¤§å°: {downloaded_mb:.2f}MB / {total_mb:.2f}MB
âš¡ï¸ é€Ÿåº¦: {speed_mb:.2f}MB/s
â³ é¢„è®¡å‰©ä½™: {eta_str}
ğŸ“Š è¿›åº¦: {bar} {progress_percent:.1f}%"""

                                                    # å‘é€è¿›åº¦æ¶ˆæ¯
                                                    if message_updater and callable(message_updater):
                                                        logger.info(f"ğŸ” [DEBUG] å‘é€å®æ—¶è¿›åº¦æ¶ˆæ¯")
                                                        try:
                                                            # message_updateræ˜¯åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                                                            logger.info(f"ğŸ” [DEBUG] è°ƒç”¨message_updater: {type(message_updater)}")
                                                            message_updater(progress_text)
                                                            logger.info(f"âœ… [DEBUG] å®æ—¶è¿›åº¦æ¶ˆæ¯å‘é€æˆåŠŸ")
                                                        except Exception as e:
                                                            logger.warning(f"âŒ [DEBUG] å®æ—¶è¿›åº¦æ¶ˆæ¯å‘é€å¤±è´¥: {e}")
                                                            logger.warning(f"ğŸ” [DEBUG] message_updaterè¯¦æƒ…: {type(message_updater)}")
                                                            import traceback
                                                            logger.warning(f"ğŸ” [DEBUG] å®Œæ•´é”™è¯¯å †æ ˆ: {traceback.format_exc()}")
                                                else:
                                                    logger.info(f"ğŸ” [DEBUG] è·³è¿‡éä¸‹è½½çŠ¶æ€çš„å­—å…¸æ•°æ®: {progress_text.get('status') if isinstance(progress_text, dict) else 'unknown'}")
                                        except Exception as e:
                                            logger.warning(f"ç®€åŒ–è¿›åº¦æ›´æ–°å¤±è´¥: {e}")
                                            logger.warning(f"ğŸ” [DEBUG] å¼‚å¸¸è¯¦æƒ…: message_updater={message_updater}, progress_text={progress_text}")

                                    # è°ƒç”¨download_videoï¼Œç›´æ¥ä¼ é€’ä¸Šå±‚çš„message_updaterä»¥ä½¿ç”¨ç»Ÿä¸€çš„è¿›åº¦ç®¡é“
                                    result = await self.download_video(video_url, message_updater if message_updater else None)

                                    # æ‰‹åŠ¨å‘é€è¿›åº¦æ›´æ–°ï¼ˆç®€åŒ–ç‰ˆæœ¬ï¼‰
                                    logger.info(f"ğŸ” æ£€æŸ¥message_updaterçŠ¶æ€: type={type(message_updater)}, callable={callable(message_updater) if message_updater else False}")
                                    if message_updater and callable(message_updater):
                                        try:
                                            # è·å–æ–‡ä»¶å
                                            filename = "æœªçŸ¥æ–‡ä»¶"
                                            if result.get('success', False) and result.get('filename'):
                                                filename = os.path.basename(result.get('filename'))

                                            progress_msg = f"""ğŸ“¥ æ­£åœ¨ä¸‹è½½ç¬¬{single_playlist_index}/{total_playlists_with_single}ä¸ªæ’­æ”¾åˆ—è¡¨ï¼šå•ç‹¬è§†é¢‘

ğŸ“º å½“å‰è§†é¢‘: {video_idx}/{len(single_videos)}
ğŸ“ æ–‡ä»¶: {filename}
ğŸ“Š çŠ¶æ€: âœ… ä¸‹è½½å®Œæˆ
ğŸ’¾ å¤§å°: {result.get('size_mb', 0):.2f} MB"""

                                            logger.info(f"ğŸ” å‡†å¤‡å‘é€è¿›åº¦æ¶ˆæ¯ï¼Œmessage_updaterç±»å‹: {type(message_updater)}")
                                            # message_updateræ˜¯åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                                            message_updater(progress_msg)
                                            logger.info(f"âœ… æ‰‹åŠ¨å‘é€è¿›åº¦æ›´æ–°æˆåŠŸ")
                                        except Exception as e:
                                            logger.warning(f"æ‰‹åŠ¨å‘é€è¿›åº¦æ›´æ–°å¤±è´¥: {e}")
                                    else:
                                        logger.warning(f"âš ï¸ message_updaterä¸å¯ç”¨: {message_updater}")

                                    # å‘é€ç®€æ´çš„è¿›åº¦æ›´æ–°ï¼Œè€Œä¸æ˜¯è¯¦ç»†çš„å®Œæˆæ¶ˆæ¯
                                    logger.info(f"ğŸ” æ£€æŸ¥è¿›åº¦æ›´æ–°å‘é€æ¡ä»¶: success={result.get('success', False)}, message_updater={type(message_updater)}")
                                    if result.get('success', False) and message_updater and callable(message_updater):
                                        try:
                                            # æ£€æŸ¥æ‰€æœ‰å˜é‡æ˜¯å¦ä¸ºNone
                                            filename = result.get('filename', 'æœªçŸ¥æ–‡ä»¶')
                                            size_mb = result.get('size_mb', 0)

                                            logger.info(f"ğŸ” [DEBUG] è¿›åº¦æ›´æ–°å˜é‡æ£€æŸ¥: filename={filename}, size_mb={size_mb}, single_video_path={single_video_path}")

                                            # åªæ˜¾ç¤ºç®€å•çš„è¿›åº¦æ›´æ–°ï¼Œè¯¦ç»†æ€»ç»“åœ¨æœ€åæ˜¾ç¤º
                                            progress_text = f"""ğŸ“¥ æ­£åœ¨ä¸‹è½½ç¬¬{single_playlist_index}/{total_playlists_with_single}ä¸ªæ’­æ”¾åˆ—è¡¨ï¼šå•ç‹¬è§†é¢‘

ğŸ“º å½“å‰è§†é¢‘: {video_idx}/{len(single_videos)} âœ… ä¸‹è½½å®Œæˆ
ğŸ“ æ–‡ä»¶: {os.path.basename(filename)}
ğŸ’¾ å¤§å°: {size_mb:.2f} MB"""

                                            logger.info(f"ğŸ” å‡†å¤‡å‘é€è¿›åº¦æ›´æ–°ï¼Œmessage_updaterç±»å‹: {type(message_updater)}")
                                            logger.info(f"ğŸ” [DEBUG] è¿›åº¦æ›´æ–°å†…å®¹: {progress_text}")

                                            # message_updateræ˜¯åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                                            message_updater(progress_text)
                                            logger.info(f"âœ… å•ç‹¬è§†é¢‘è¿›åº¦æ›´æ–°å·²å‘é€")
                                        except Exception as e:
                                            logger.warning(f"å‘é€å•ç‹¬è§†é¢‘è¿›åº¦æ›´æ–°å¤±è´¥: {e}")
                                            import traceback
                                            logger.warning(f"ğŸ” [DEBUG] è¿›åº¦æ›´æ–°å‘é€é”™è¯¯å †æ ˆ: {traceback.format_exc()}")
                                    else:
                                        logger.warning(f"âš ï¸ è·³è¿‡è¿›åº¦æ›´æ–°å‘é€: success={result.get('success', False)}, message_updater={message_updater}")

                                except Exception as e:
                                    logger.error(f"å•ç‹¬è§†é¢‘ä¸‹è½½å¼‚å¸¸: {e}")
                                    if message_updater and callable(message_updater):
                                        try:
                                            # message_updateræ˜¯åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                                            message_updater(f"âŒ è§†é¢‘ä¸‹è½½å¤±è´¥: {str(e)}")
                                        except Exception as msg_e:
                                            logger.warning(f"å‘é€é”™è¯¯æ¶ˆæ¯å¤±è´¥: {msg_e}")
                                    result = {'success': False, 'error': str(e)}
                                finally:
                                    # æ¢å¤åŸå§‹ä¸‹è½½è·¯å¾„
                                    self.bilibili_download_path = original_bilibili_path
                                    logger.info(f"ğŸ”§ æ¢å¤Bç«™ä¸‹è½½è·¯å¾„: {self.bilibili_download_path}")

                                if result.get('success', False):
                                    single_downloaded += 1
                                    total_downloaded += 1
                                    # ç´¯è®¡æ–‡ä»¶å¤§å°
                                    if 'size_mb' in result:
                                        total_size_mb += result['size_mb']
                                    logger.info(f"âœ… å•ç‹¬è§†é¢‘ä¸‹è½½æˆåŠŸ: {video_idx}/{len(single_videos)}")
                                else:
                                    single_failed += 1
                                    total_failed += 1
                                    logger.error(f"âŒ å•ç‹¬è§†é¢‘ä¸‹è½½å¤±è´¥: {video_idx}/{len(single_videos)} - {result.get('error', 'æœªçŸ¥é”™è¯¯')}")

                            except Exception as e:
                                single_failed += 1
                                total_failed += 1
                                logger.error(f"âŒ å•ç‹¬è§†é¢‘ä¸‹è½½å¼‚å¸¸: {video_idx}/{len(single_videos)} - {e}")

                    # è®°å½•å•ç‹¬è§†é¢‘ç»“æœ
                    if single_downloaded > 0:
                        single_result = {
                            'title': 'å•ç‹¬è§†é¢‘',
                            'type': 'å•ç‹¬è§†é¢‘',
                            'video_count': single_downloaded,
                            'failed_count': single_failed,
                            'download_path': str(user_download_path / "å•ç‹¬è§†é¢‘")
                        }
                        downloaded_results.append(single_result)
                        logger.info(f"âœ… å•ç‹¬è§†é¢‘å¤„ç†å®Œæˆ: (æˆåŠŸ: {single_downloaded}, å¤±è´¥: {single_failed})")

                except Exception as e:
                    logger.error(f"âŒ å•ç‹¬è§†é¢‘ä¸‹è½½å¼‚å¸¸: {e}")
                    total_failed += len(single_videos)

            # æ­¥éª¤6: ç»Ÿè®¡ä¸‹è½½ç»“æœ
            logger.info("ğŸ” æ­¥éª¤6: ç»Ÿè®¡ä¸‹è½½ç»“æœ...")

            # è®¡ç®—æˆåŠŸç‡å’Œå¤±è´¥æ•°é‡
            total_videos = len(entries)
            success_rate = (total_downloaded / total_videos) * 100 if total_videos > 0 else 0

            # æ ¼å¼åŒ–æ€»å¤§å°æ˜¾ç¤º
            if total_size_mb >= 1024:
                total_size_str = f"{total_size_mb / 1024:.2f}GB"
            else:
                total_size_str = f"{total_size_mb:.2f}MB"

            logger.info(f"ğŸ“Š ä¸‹è½½ç»Ÿè®¡: {total_downloaded}/{total_videos} ä¸ªè§†é¢‘æˆåŠŸï¼ŒæˆåŠŸç‡: {success_rate:.1f}%")
            logger.info(f"ğŸ“Š æ’­æ”¾åˆ—è¡¨ç»Ÿè®¡: {len(downloaded_results)} ä¸ªæ’­æ”¾åˆ—è¡¨")

            # æ­¥éª¤7: æ„å»ºå®Œæˆæ¶ˆæ¯
            if message_updater and callable(message_updater):
                try:
                    completion_text = f"""ğŸ“º Bç«™UPä¸»æ’­æ”¾åˆ—è¡¨ä¸‹è½½å®Œæˆ

ğŸ“º UPä¸»: {clean_uploader_name}
ğŸ“Š æ’­æ”¾åˆ—è¡¨æ•°é‡: {len(downloaded_results)}
ğŸ“Š å•é›†æ•°é‡: {total_videos}

å·²ä¸‹è½½çš„æ’­æ”¾åˆ—è¡¨:

"""

                    # æ·»åŠ æ¯ä¸ªæ’­æ”¾åˆ—è¡¨çš„è¯¦ç»†ä¿¡æ¯ï¼ˆå‚è€ƒYouTubeæ ¼å¼ï¼‰
                    for i, playlist in enumerate(downloaded_results, 1):
                        playlist_title = playlist.get('title', f'æ’­æ”¾åˆ—è¡¨{i}')
                        video_count = playlist.get('video_count', 0)
                        failed_count = playlist.get('failed_count', 0)

                        # æ˜¾ç¤ºæˆåŠŸå’Œå¤±è´¥çš„è§†é¢‘æ•°é‡
                        if failed_count > 0:
                            completion_text += f"  {i}. {playlist_title} ({video_count} é›†, âŒ {failed_count} å¤±è´¥)\n"
                        else:
                            completion_text += f"  {i}. {playlist_title} ({video_count} é›†)\n"

                    completion_text += f"""

ğŸ“Š ä¸‹è½½ç»Ÿè®¡:
æ€»è®¡: {total_videos} ä¸ª
âœ… æˆåŠŸ: {total_downloaded} ä¸ª
âŒ å¤±è´¥: {total_failed} ä¸ª
ğŸ’¾ æ–‡ä»¶æ€»å¤§å°: {total_size_str}
ğŸ“‚ ä¿å­˜ä½ç½®: {user_download_path}"""

                    # message_updateræ˜¯åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                    message_updater(completion_text)
                except Exception as e:
                    logger.warning(f"æ›´æ–°å®Œæˆæ¶ˆæ¯å¤±è´¥: {e}")

            # æ­¥éª¤8: è¿”å›ç»“æœ
            if total_downloaded > 0:
                logger.info(f"ğŸ‰ UPä¸»æ‰€æœ‰è§†é¢‘ä¸‹è½½å®Œæˆ: {total_downloaded}/{total_videos} ä¸ªæˆåŠŸ")

                # æ·»åŠ è¯¦ç»†çš„ä¸‹è½½æ€»ç»“æ—¥å¿—
                logger.info("=" * 60)
                logger.info("ğŸ“Š Bç«™UPä¸»ä¸‹è½½å®Œæˆæ€»ç»“")
                logger.info("=" * 60)
                logger.info(f"ğŸ¯ UPä¸»: {clean_uploader_name} (UID: {uid})")
                logger.info(f"ğŸ“ ä¸‹è½½ç›®å½•: {user_download_path}")
                logger.info(f"ğŸ“Š æ€»è§†é¢‘æ•°: {total_videos}")
                logger.info(f"âœ… æˆåŠŸä¸‹è½½: {total_downloaded}")
                logger.info(f"âŒ ä¸‹è½½å¤±è´¥: {total_failed}")
                logger.info(f"ğŸ“ˆ æˆåŠŸç‡: {success_rate:.1f}%")
                logger.info(f"ğŸ’¾ æ€»æ–‡ä»¶å¤§å°: {total_size_str}")

                # æ˜¾ç¤ºæ’­æ”¾åˆ—è¡¨è¯¦æƒ…
                if downloaded_results:
                    logger.info(f"\nğŸ“‹ æ’­æ”¾åˆ—è¡¨è¯¦æƒ…:")
                    for i, playlist in enumerate(downloaded_results, 1):
                        playlist_title = playlist.get('title', f'æ’­æ”¾åˆ—è¡¨{i}')
                        video_count = playlist.get('video_count', 0)
                        failed_count = playlist.get('failed_count', 0)
                        download_path = playlist.get('download_path', 'æœªçŸ¥')
                        logger.info(f"  {i}. {playlist_title}")
                        logger.info(f"     è§†é¢‘æ•°: {video_count}, å¤±è´¥: {failed_count}")
                        logger.info(f"     ä¿å­˜ä½ç½®: {download_path}")

                # æ˜¾ç¤ºç›®å½•ç»“æ„
                logger.info(f"\nğŸ“‚ æœ€ç»ˆç›®å½•ç»“æ„:")
                try:
                    def log_directory_structure(path, indent=""):
                        if os.path.isdir(path):
                            logger.info(f"{indent}ğŸ“ {os.path.basename(path)}/")
                            try:
                                for item in sorted(os.listdir(path)):
                                    item_path = os.path.join(path, item)
                                    if os.path.isdir(item_path):
                                        log_directory_structure(item_path, indent + "  ")
                                    else:
                                        size = os.path.getsize(item_path) / (1024 * 1024)  # MB
                                        logger.info(f"{indent}  ğŸ“„ {item} ({size:.2f}MB)")
                            except PermissionError:
                                logger.warning(f"{indent}  âš ï¸ æ— æ³•è®¿é—®ç›®å½•å†…å®¹")
                        else:
                            logger.info(f"{indent}ğŸ“„ {os.path.basename(path)}")

                    log_directory_structure(user_download_path)
                except Exception as e:
                    logger.warning(f"æ— æ³•æ˜¾ç¤ºç›®å½•ç»“æ„: {e}")

                logger.info("=" * 60)

                return {
                    'success': True,
                    'is_channel': True,
                    'platform': 'bilibili',
                    'video_type': 'user_all_videos',
                    'channel_title': clean_uploader_name,
                    'uploader_id': uploader_id,
                    'uid': uid,
                    'total_videos': total_videos,
                    'downloaded_videos': total_downloaded,
                    'failed_videos': total_failed,
                    'success_rate': success_rate,
                    'total_size_mb': total_size_mb,
                    'download_path': str(user_download_path),
                    'playlists_downloaded': [p['title'] for p in downloaded_results],
                    'playlist_stats': downloaded_results
                }
            else:
                return {'success': False, 'error': 'æ‰€æœ‰è§†é¢‘ä¸‹è½½éƒ½å¤±è´¥äº†'}

        except Exception as e:
            error_msg = f"UPä¸»åˆé›†ä¸‹è½½è¿‡ç¨‹ä¸­å‡ºé”™: {e}"
            logger.error(error_msg)
            return {'success': False, 'error': error_msg}

    async def _download_bilibili_list(
        self, uid: str, list_id: str, download_path: Path, message_updater=None
    ) -> Dict[str, Any]:
        """ä¸‹è½½Bilibiliæ’­æ”¾åˆ—è¡¨"""
        logger.info(f"ğŸ¬ å¼€å§‹ä¸‹è½½Bilibiliæ’­æ”¾åˆ—è¡¨: UID={uid}, ListID={list_id}")

        try:
            logger.info("ğŸ” æ­¥éª¤1: å‡†å¤‡è·å–æ’­æ”¾åˆ—è¡¨ä¿¡æ¯...")
            # è·å–æ’­æ”¾åˆ—è¡¨ä¿¡æ¯ - æ·»åŠ è¶…æ—¶æ§åˆ¶
            info_opts = {
                "quiet": True,
                "extract_flat": True,
                "ignoreerrors": True,
                "socket_timeout": 30,  # 30ç§’è¶…æ—¶
                "retries": 8,  # å¢åŠ é‡è¯•æ¬¡æ•°ä»¥æé«˜æ–­ç‚¹ç»­ä¼ æˆåŠŸç‡
                "fragment_retries": 8,
            }
            if self.proxy_host:
                info_opts["proxy"] = self.proxy_host
                logger.info(f"ğŸŒ ä½¿ç”¨ä»£ç†: {self.proxy_host}")

            logger.info("ğŸ” æ­¥éª¤2: å¼€å§‹æå–æ’­æ”¾åˆ—è¡¨ä¿¡æ¯ï¼ˆè®¾ç½®30ç§’è¶…æ—¶ï¼‰...")

            # ä½¿ç”¨å¼‚æ­¥æ‰§è¡Œå™¨æ¥æ·»åŠ è¶…æ—¶æ§åˆ¶
            loop = asyncio.get_running_loop()

            def extract_playlist_info():
                with yt_dlp.YoutubeDL(info_opts) as ydl:
                    logger.info("ğŸ“¡ æ­£åœ¨ä»Bilibiliè·å–æ’­æ”¾åˆ—è¡¨æ•°æ®...")
                    return ydl.extract_info(
                        f"https://www.bilibili.com/medialist/play/{uid}?business=space_series&business_id={list_id}",
                        download=False,
                    )

            # è®¾ç½®30ç§’è¶…æ—¶
            try:
                info = await asyncio.wait_for(
                    loop.run_in_executor(None, extract_playlist_info), timeout=60.0
                )
                logger.info(f"âœ… æ’­æ”¾åˆ—è¡¨ä¿¡æ¯è·å–å®Œæˆï¼Œæ•°æ®ç±»å‹: {type(info)}")
            except asyncio.TimeoutError:
                logger.error("âŒ è·å–æ’­æ”¾åˆ—è¡¨ä¿¡æ¯è¶…æ—¶ï¼ˆ30ç§’ï¼‰")
                return {
                    "success": False,
                    "error": "è·å–æ’­æ”¾åˆ—è¡¨ä¿¡æ¯è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•ã€‚",
                }

            if not info:
                logger.error("âŒ æ’­æ”¾åˆ—è¡¨ä¿¡æ¯ä¸ºç©º")
                return {"success": False, "error": "æ— æ³•è·å–æ’­æ”¾åˆ—è¡¨ä¿¡æ¯"}

            if "entries" not in info:
                logger.error("âŒ æ’­æ”¾åˆ—è¡¨ä¿¡æ¯ä¸­æ²¡æœ‰æ‰¾åˆ° 'entries' å­—æ®µ")
                return {"success": False, "error": "æ— æ³•è·å–æ’­æ”¾åˆ—è¡¨ä¿¡æ¯"}

            entries = info.get("entries", [])
            logger.info(f"ğŸ“Š æ’­æ”¾åˆ—è¡¨åŒ…å« {len(entries)} ä¸ªè§†é¢‘")

            if not entries:
                logger.warning("âš ï¸ æ’­æ”¾åˆ—è¡¨ä¸ºç©º")
                return {"success": False, "error": "æ’­æ”¾åˆ—è¡¨ä¸ºç©º"}

            logger.info("ğŸ” æ­¥éª¤3: åˆ›å»ºæ’­æ”¾åˆ—è¡¨ç›®å½•...")
            # Bilibiliæ’­æ”¾åˆ—è¡¨ç›®å½•åªä½¿ç”¨list_id
            playlist_path = download_path / list_id
            playlist_path.mkdir(parents=True, exist_ok=True)
            logger.info(f"ğŸ“ æ’­æ”¾åˆ—è¡¨ç›®å½•: {playlist_path}")

            logger.info("ğŸ” æ­¥éª¤4: é…ç½®ä¸‹è½½é€‰é¡¹...")
            # è®¾ç½®è¾“å‡ºæ¨¡æ¿ï¼ŒBç«™æ’­æ”¾åˆ—è¡¨ä¿æŒåŸæœ‰æ ¼å¼ï¼ˆåŒ…å«IDï¼‰
            outtmpl = str(
                playlist_path.absolute()
                / "%(playlist_index)02d - %(title)s [%(id)s].%(ext)s"
            )
            # æ·»åŠ æ˜æ˜¾çš„outtmplæ—¥å¿—
            logger.info(f"ğŸ”§ [BILIBILI_PLAYLIST] outtmpl ç»å¯¹è·¯å¾„: {outtmpl}")

            # é…ç½®ä¸‹è½½é€‰é¡¹ - ä¼˜åŒ–æ€§èƒ½
            ydl_opts = {
                "outtmpl": outtmpl,
                "format": "bestvideo[ext=mp4]+bestaudio[ext=m4a]/bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best",
                "merge_output_format": "mp4",
                "ignoreerrors": True,
                "retries": 8,  # å¢åŠ é‡è¯•æ¬¡æ•°ä»¥æé«˜æ–­ç‚¹ç»­ä¼ æˆåŠŸç‡
                "fragment_retries": 8,
                "skip_unavailable_fragments": True,
                "quiet": True,
                "no_warnings": True,
                "socket_timeout": 30,  # 30ç§’è¶…æ—¶
                "extract_flat": False,  # å®Œæ•´æå–
            }

            if self.proxy_host:
                ydl_opts["proxy"] = self.proxy_host

            if message_updater:
                ydl_opts["progress_hooks"] = [message_updater]

            # æ·»åŠ å¼¹å¹•ä¸‹è½½é€‰é¡¹ (æ„é€ Bç«™URL)
            bilibili_url = f"https://www.bilibili.com/medialist/play/{uid}?business=space_series&business_id={list_id}"
            ydl_opts = self._add_danmaku_options(ydl_opts, bilibili_url)

            # å¦‚æœå¼€å¯äº†Bç«™å°é¢ä¸‹è½½ï¼Œæ·»åŠ ç¼©ç•¥å›¾ä¸‹è½½é€‰é¡¹
            if hasattr(self, 'bot') and hasattr(self.bot, 'bilibili_thumbnail_download') and self.bot.bilibili_thumbnail_download:
                ydl_opts["writethumbnail"] = True
                # æ·»åŠ ç¼©ç•¥å›¾æ ¼å¼è½¬æ¢åå¤„ç†å™¨ï¼šWebP -> JPG
                if "postprocessors" not in ydl_opts:
                    ydl_opts["postprocessors"] = []
                ydl_opts["postprocessors"].append({
                    'key': 'FFmpegThumbnailsConvertor',
                    'format': 'jpg',
                    'when': 'before_dl'
                })
                logger.info("ğŸ–¼ï¸ Bç«™æ’­æ”¾åˆ—è¡¨å¼€å¯å°é¢ä¸‹è½½ï¼ˆè½¬æ¢ä¸ºJPGæ ¼å¼ï¼‰")

            logger.info("ğŸ” æ­¥éª¤5: å¼€å§‹ä¸‹è½½æ’­æ”¾åˆ—è¡¨ï¼ˆè®¾ç½®60ç§’è¶…æ—¶ï¼‰...")

            def download_playlist():
                logger.info(f"ğŸ”§ [BILIBILI_PLAYLIST_DOWNLOAD] æœ€ç»ˆydl_opts: {ydl_opts}")
                with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                    logger.info("ğŸš€ å¼€å§‹ä¸‹è½½Bilibiliæ’­æ”¾åˆ—è¡¨è§†é¢‘...")
                    return ydl.download(
                        [
                            f"https://www.bilibili.com/medialist/play/{uid}?business=space_series&business_id={list_id}"
                        ]
                    )

            # è®¾ç½®60ç§’è¶…æ—¶ç”¨äºä¸‹è½½
            try:
                await asyncio.wait_for(
                    loop.run_in_executor(None, download_playlist), timeout=120.0
                )
                logger.info("âœ… Bilibiliæ’­æ”¾åˆ—è¡¨ä¸‹è½½å®Œæˆ")

                # é‡å‘½åå¼¹å¹•æ–‡ä»¶ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰
                self._rename_danmaku_files(str(playlist_path))

            except asyncio.TimeoutError:
                logger.error("âŒ Bilibiliæ’­æ”¾åˆ—è¡¨ä¸‹è½½è¶…æ—¶ï¼ˆ60ç§’ï¼‰")
                return {
                    "success": False,
                    "error": "Bilibiliæ’­æ”¾åˆ—è¡¨ä¸‹è½½è¶…æ—¶ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥æˆ–ç¨åé‡è¯•ã€‚",
                }

            return {
                "success": True,
                "is_playlist": True,
                "playlist_title": list_id,  # ä½¿ç”¨list_idä½œä¸ºæ ‡é¢˜
                "download_path": str(playlist_path),
                "video_count": len(entries),
            }

        except Exception as e:
            logger.error(f"âŒ Bilibiliæ’­æ”¾åˆ—è¡¨ä¸‹è½½å¤±è´¥: {e}")
            import traceback

            logger.error(f"è¯¦ç»†é”™è¯¯ä¿¡æ¯: {traceback.format_exc()}")
            return {"success": False, "error": str(e)}

    async def _download_youtube_playlist_with_progress(
        self, playlist_id: str, download_path: Path, progress_callback=None, original_url: str = None
    ) -> Dict[str, Any]:
        """ä¸‹è½½YouTubeæ’­æ”¾åˆ—è¡¨ï¼ˆå¸¦è¯¦ç»†è¿›åº¦ï¼‰"""
        logger.info(f"ğŸ¬ å¼€å§‹ä¸‹è½½YouTubeæ’­æ”¾åˆ—è¡¨: {playlist_id}")
        logger.info(f"ğŸ“ ä¸‹è½½è·¯å¾„: {download_path}")

        try:
            # æ£€æŸ¥æ’­æ”¾åˆ—è¡¨æ˜¯å¦å·²ç»å®Œæ•´ä¸‹è½½
            logger.info("ğŸ” æ£€æŸ¥æ’­æ”¾åˆ—è¡¨æ˜¯å¦å·²å®Œæ•´ä¸‹è½½...")
            check_result = self._check_playlist_already_downloaded(
                playlist_id, download_path
            )

            if check_result.get("already_downloaded", False):
                logger.info("âœ… æ’­æ”¾åˆ—è¡¨å·²å®Œæ•´ä¸‹è½½ï¼Œç›´æ¥è¿”å›ç»“æœ")
                return {
                    "success": True,
                    "already_downloaded": True,
                    "playlist_title": check_result.get("playlist_title", ""),
                    "video_count": check_result.get("video_count", 0),
                    "download_path": check_result.get("download_path", ""),
                    "total_size_mb": check_result.get("total_size_mb", 0),
                    "resolution": check_result.get("resolution", "æœªçŸ¥"),
                    "downloaded_files": check_result.get("downloaded_files", []),
                    "completion_rate": check_result.get("completion_rate", 100),
                }
            else:
                logger.info(f"ğŸ“¥ æ’­æ”¾åˆ—è¡¨æœªå®Œæ•´ä¸‹è½½ï¼ŒåŸå› : {check_result.get('reason', 'æœªçŸ¥')}")
                if check_result.get("completion_rate", 0) > 0:
                    logger.info(
                        f"ğŸ“Š å½“å‰å®Œæˆåº¦: {check_result.get('completion_rate', 0):.1f}%"
                    )

            # è·å–æ’­æ”¾åˆ—è¡¨ä¿¡æ¯ - ä½¿ç”¨å¢å¼ºé…ç½®
                # è·å–æ’­æ”¾åˆ—è¡¨ä¿¡æ¯ - ä½¿ç”¨å¢å¼ºé…ç½®
                info_opts = {
                    "quiet": False,  # æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
                    "ignoreerrors": True,
                    "socket_timeout": 60,
                    "retries": 3,
                    "age_limit": 99,  # ç»•è¿‡å¹´é¾„é™åˆ¶
                    "geo_bypass": True,  # å°è¯•ç»•è¿‡åœ°ç†é™åˆ¶
                    "geo_bypass_country": "US",  # ä½¿ç”¨ç¾å›½ä½œä¸ºç»•è¿‡å›½å®¶
                    "extractor_args": {
                        "youtube": {
                            # ğŸ¯ çœŸæ­£ä¿®å¤ï¼šç»•è¿‡YouTube 2024å¹´åº•çš„PO Tokené™åˆ¶
                            "player_client": ["ios", "mweb"],  # ä½¿ç”¨iOSå’Œç§»åŠ¨ç½‘é¡µå®¢æˆ·ç«¯
                            "player_skip": ["configs", "webpage"],  # è·³è¿‡é…ç½®å’Œç½‘é¡µæ£€æŸ¥
                            "include_dash_manifest": True,  # åŒ…å«DASHæ¸…å•
                            "formats": "missing_pot",  # å…è®¸ç¼ºå°‘PO Tokençš„æ ¼å¼
                        }
                    },
                }
                if self.proxy_host:
                    info_opts["proxy"] = self.proxy_host
                    logger.info(f"ğŸŒ ä½¿ç”¨ä»£ç†: {self.proxy_host}")
                if self.youtube_cookies_path and os.path.exists(self.youtube_cookies_path):
                    info_opts["cookiefile"] = self.youtube_cookies_path
                    logger.info(
                        f"ğŸª ä½¿ç”¨YouTube cookies: {self.youtube_cookies_path}"
                    )

                def extract_playlist_info():
                    logger.info("ğŸ“¡ æ­£åœ¨ä»YouTubeè·å–æ’­æ”¾åˆ—è¡¨æ•°æ®...")
                    with yt_dlp.YoutubeDL(info_opts) as ydl:
                        result = ydl.extract_info(
                            f"https://www.youtube.com/playlist?list={playlist_id}",
                            download=False,
                        )
                        return result

                loop = asyncio.get_running_loop()
                info = await loop.run_in_executor(None, extract_playlist_info)

                if not info:
                    logger.error("âŒ æ’­æ”¾åˆ—è¡¨ä¿¡æ¯ä¸ºç©º")
                    return {"success": False, "error": "æ— æ³•è·å–æ’­æ”¾åˆ—è¡¨ä¿¡æ¯ã€‚"}

                entries = info.get("entries", [])
                if not entries:
                    logger.warning("âŒ æ’­æ”¾åˆ—è¡¨ä¸ºç©º")
                    return {"success": False, "error": "æ’­æ”¾åˆ—è¡¨ä¸ºç©ºã€‚"}

                logger.info(f"ğŸ“Š æ’­æ”¾åˆ—è¡¨åŒ…å« {len(entries)} ä¸ªè§†é¢‘")

                # è°ƒè¯•ï¼šæ£€æŸ¥æ’­æ”¾åˆ—è¡¨ä¿¡æ¯
                logger.info(f"ğŸ” æ’­æ”¾åˆ—è¡¨åŸå§‹æ ‡é¢˜: {info.get('title', 'N/A')}")
                logger.info(f"ğŸ” æ’­æ”¾åˆ—è¡¨ID: {playlist_id}")
                logger.info(f"ğŸ” æ’­æ”¾åˆ—è¡¨å…¶ä»–å­—æ®µ: uploader={info.get('uploader', 'N/A')}, uploader_id={info.get('uploader_id', 'N/A')}")

                # åˆ›å»ºæ’­æ”¾åˆ—è¡¨ç›®å½•
                # å°è¯•ä»ä¸åŒå­—æ®µè·å–æ’­æ”¾åˆ—è¡¨æ ‡é¢˜
                raw_title = info.get("title", f"Playlist_{playlist_id}")
                if raw_title == playlist_id or raw_title.startswith("Playlist_"):
                    # å¦‚æœæ ‡é¢˜å°±æ˜¯IDï¼Œå°è¯•ä»å…¶ä»–å­—æ®µè·å–
                    raw_title = info.get("uploader", info.get("channel", f"Playlist_{playlist_id}"))
                    logger.info(f"ğŸ”§ ä½¿ç”¨å¤‡ç”¨æ ‡é¢˜: {raw_title}")

                playlist_title = re.sub(r'[\\/:*?"<>|]', "_", raw_title).strip()
                # æ ¹æ®è®¾ç½®å†³å®šæ–‡ä»¶å¤¹åç§°æ ¼å¼
                if hasattr(self, 'bot') and hasattr(self.bot, 'youtube_id_tags') and self.bot.youtube_id_tags:
                    playlist_title_with_id = f"[{playlist_id}]"
                else:
                    playlist_title_with_id = playlist_title
                playlist_path = download_path / playlist_title_with_id
                playlist_path.mkdir(parents=True, exist_ok=True)
                logger.info(f"ğŸ“ æ’­æ”¾åˆ—è¡¨ç›®å½•: {playlist_path}")

                # é¢„å…ˆè®°å½•é¢„æœŸæ–‡ä»¶ä¿¡æ¯ï¼ˆåƒBç«™å¤šPä¸‹è½½ä¸€æ ·ï¼‰
                expected_files = []
                for i, entry in enumerate(entries, 1):
                    title = entry.get("title", f"Video_{i}")
                    safe_title = re.sub(r'[\\/:*?"<>|]', "_", title).strip()
                    video_id = entry.get('id', '')

                    # æ ¹æ®è®¾ç½®å†³å®šæ–‡ä»¶åæ ¼å¼ï¼Œä¸å®é™…ä¸‹è½½æ—¶çš„æ¨¡æ¿ä¿æŒä¸€è‡´
                    if hasattr(self, 'bot') and hasattr(self.bot, 'youtube_id_tags') and self.bot.youtube_id_tags:
                        expected_filename = f"{i:02d}. {safe_title}[{video_id}].mp4"
                    else:
                        expected_filename = f"{i:02d}. {safe_title}.mp4"

                    expected_files.append({
                        'title': title,
                        'filename': expected_filename,
                        'index': i,
                        'id': video_id,
                    })

            logger.info(f"ğŸ“‹ é¢„æœŸæ–‡ä»¶åˆ—è¡¨: {len(expected_files)} ä¸ªæ–‡ä»¶")

            # ä¸‹è½½æ’­æ”¾åˆ—è¡¨ï¼ˆå¸¦è¿›åº¦å›è°ƒï¼‰
            def download_playlist():
                logger.info("ğŸš€ å¼€å§‹ä¸‹è½½æ’­æ”¾åˆ—è¡¨...")

                # æ£€æŸ¥æ˜¯å¦ä¸ºéŸ³é¢‘æ¨¡å¼ï¼Œå†³å®šä½¿ç”¨å“ªä¸ªç›®å½•
                if hasattr(self, 'bot') and hasattr(self.bot, 'youtube_audio_mode') and self.bot.youtube_audio_mode:
                    # éŸ³é¢‘æ¨¡å¼ï¼šä½¿ç”¨æ’­æ”¾åˆ—è¡¨ç›®å½•ä¸‹çš„musicå­ç›®å½•
                    music_playlist_path = playlist_path / "music"
                    music_playlist_path.mkdir(exist_ok=True)  # ç¡®ä¿musicç›®å½•å­˜åœ¨
                    actual_path = music_playlist_path
                    logger.info("ğŸµ éŸ³é¢‘æ¨¡å¼ï¼šæ’­æ”¾åˆ—è¡¨å°†ä¿å­˜åˆ°musicå­ç›®å½•")
                else:
                    # é»˜è®¤è§†é¢‘æ¨¡å¼ï¼šä½¿ç”¨åŸæ’­æ”¾åˆ—è¡¨ç›®å½•
                    actual_path = playlist_path

                # ä½¿ç”¨ç»å¯¹è·¯å¾„æ„å»ºouttmplï¼Œæ ¹æ®è®¾ç½®å†³å®šæ–‡ä»¶åå‰ç¼€å’Œæ˜¯å¦æ·»åŠ è§†é¢‘ID
                # æ£€æŸ¥æ˜¯å¦å¼€å¯æ—¶é—´æˆ³å‘½å
                use_timestamp = hasattr(self, 'bot') and hasattr(self.bot, 'youtube_timestamp_naming') and self.bot.youtube_timestamp_naming
                use_id_tags = hasattr(self, 'bot') and hasattr(self.bot, 'youtube_id_tags') and self.bot.youtube_id_tags

                if use_timestamp:
                    # ä½¿ç”¨æ—¶é—´æˆ³ä½œä¸ºå‰ç¼€
                    if use_id_tags:
                        filename_template = "%(upload_date)s. %(title)s[%(id)s].%(ext)s"
                    else:
                        filename_template = "%(upload_date)s. %(title)s.%(ext)s"
                else:
                    # ä½¿ç”¨åºå·ä½œä¸ºå‰ç¼€ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼‰
                    if use_id_tags:
                        filename_template = "%(playlist_index)02d. %(title)s[%(id)s].%(ext)s"
                    else:
                        filename_template = "%(playlist_index)02d. %(title)s.%(ext)s"

                abs_outtmpl = str(actual_path.absolute() / filename_template)
                logger.info(
                    f"ğŸ”§ [YT_PLAYLIST_WITH_PROGRESS] outtmpl ç»å¯¹è·¯å¾„: {abs_outtmpl}"
                )
                # æ ¹æ®YouTubeéŸ³é¢‘æ¨¡å¼è®¾ç½®formatå’Œè¾“å‡ºæ ¼å¼
                if hasattr(self, 'bot') and hasattr(self.bot, 'youtube_audio_mode') and self.bot.youtube_audio_mode:
                    # YouTubeéŸ³é¢‘æ¨¡å¼ï¼šä¼˜å…ˆä¸‹è½½æœ€é«˜ç ç‡çš„MP3æ ¼å¼
                    format_spec = "bestaudio[ext=mp3]/bestaudio[acodec=mp3]/bestaudio"
                    merge_format = "mp3"
                    logger.info("ğŸµ å¯ç”¨YouTubeéŸ³é¢‘æ¨¡å¼ï¼Œæ’­æ”¾åˆ—è¡¨ä¼˜å…ˆä¸‹è½½æœ€é«˜ç ç‡MP3")
                else:
                    # ğŸ¯ çœŸæ­£ä¿®å¤ï¼šæ¢å¤v0.4-dev3çš„æˆåŠŸæ–¹å¼ - è®©yt-dlpè‡ªå·±é€‰æ‹©æœ€ä½³æ ¼å¼
                    format_spec = None  # ä¸è®¾ç½®formatï¼Œä½¿ç”¨yt-dlpé»˜è®¤çš„"best"
                    merge_format = "mp4"
                    logger.info("ğŸ¬ YouTubeé¢‘é“ä¸‹è½½ä½¿ç”¨yt-dlpåŸç”Ÿæœ€ä½³æ ¼å¼é€‰æ‹©ï¼ˆæ¢å¤v0.4-dev3æˆåŠŸæ–¹å¼ï¼‰")

                # ä½¿ç”¨å¢å¼ºé…ç½®ï¼Œé¿å…PARTæ–‡ä»¶
                logger.info(f"ğŸ”§ [PROGRESS_HOOKS] progress_callbackæ˜¯å¦ä¸ºNone: {progress_callback is None}")
                logger.info(f"ğŸ”§ [PROGRESS_HOOKS] progress_callbackç±»å‹: {type(progress_callback)}")
                base_opts = {
                    "outtmpl": abs_outtmpl,
                    "merge_output_format": merge_format,
                    "ignoreerrors": True,
                    "progress_hooks": [progress_callback] if progress_callback else [],
                }
                logger.info(f"ğŸ”§ [PROGRESS_HOOKS] base_optsä¸­çš„progress_hooks: {len(base_opts['progress_hooks'])} ä¸ªå›è°ƒ")

                # ğŸ¯ å…³é”®ä¿®å¤ï¼šæ— è®ºéŸ³é¢‘è¿˜æ˜¯è§†é¢‘æ¨¡å¼ï¼Œéƒ½è¦æ·»åŠ formatè®¾ç½®
                if format_spec:
                    base_opts["format"] = format_spec
                    logger.info(f"ğŸ¯ [FORMAT_FIX] å·²è®¾ç½®formatåˆ°base_opts: {format_spec}")

                ydl_opts = self._get_enhanced_ydl_opts(base_opts)
                logger.info("ğŸ›¡ï¸ ä½¿ç”¨å¢å¼ºé…ç½®ï¼Œé¿å…PARTæ–‡ä»¶äº§ç”Ÿ")

                # å¦‚æœæ˜¯éŸ³é¢‘æ¨¡å¼ï¼Œæ·»åŠ éŸ³é¢‘è½¬æ¢åå¤„ç†å™¨
                if hasattr(self, 'bot') and hasattr(self.bot, 'youtube_audio_mode') and self.bot.youtube_audio_mode:
                    ydl_opts["postprocessors"] = ydl_opts.get("postprocessors", []) + [
                        {
                            'key': 'FFmpegExtractAudio',
                            'preferredcodec': 'mp3',
                            'preferredquality': '320',  # æœ€é«˜è´¨é‡320kbps
                        }
                    ]
                    logger.info("ğŸµ æ’­æ”¾åˆ—è¡¨æ·»åŠ éŸ³é¢‘è½¬æ¢åå¤„ç†å™¨ï¼šè½¬æ¢ä¸º320kbps MP3")

                # å¦‚æœå¼€å¯äº†å°é¢ä¸‹è½½ï¼Œæ·»åŠ ç¼©ç•¥å›¾ä¸‹è½½é€‰é¡¹
                if hasattr(self, 'bot') and hasattr(self.bot, 'youtube_thumbnail_download') and self.bot.youtube_thumbnail_download:
                    ydl_opts["writethumbnail"] = True
                    # æ·»åŠ ç¼©ç•¥å›¾æ ¼å¼è½¬æ¢åå¤„ç†å™¨ï¼šWebP -> JPG
                    if "postprocessors" not in ydl_opts:
                        ydl_opts["postprocessors"] = []
                    ydl_opts["postprocessors"].append({
                        'key': 'FFmpegThumbnailsConvertor',
                        'format': 'jpg',
                        'when': 'before_dl'
                    })
                    logger.info("ğŸ–¼ï¸ æ’­æ”¾åˆ—è¡¨å¼€å¯YouTubeå°é¢ä¸‹è½½ï¼ˆè½¬æ¢ä¸ºJPGæ ¼å¼ï¼‰")

                # å¦‚æœå¼€å¯äº†å­—å¹•ä¸‹è½½ï¼Œæ·»åŠ å­—å¹•ä¸‹è½½é€‰é¡¹
                if hasattr(self, 'bot') and hasattr(self.bot, 'youtube_subtitle_download') and self.bot.youtube_subtitle_download:
                    ydl_opts["writeautomaticsub"] = True  # ä¸‹è½½è‡ªåŠ¨ç”Ÿæˆçš„å­—å¹•
                    ydl_opts["writesubtitles"] = True     # ä¸‹è½½æ‰‹åŠ¨å­—å¹•
                    ydl_opts["subtitleslangs"] = ["zh", "en"]  # å­—å¹•è¯­è¨€ï¼šä¸­æ–‡å’Œè‹±æ–‡
                    ydl_opts["convertsubtitles"] = "srt"  # è½¬æ¢ä¸ºSRTæ ¼å¼
                    ydl_opts["subtitlesformat"] = "best[ext=srt]/srt/best"  # ä¼˜å…ˆé€‰æ‹©SRTæ ¼å¼
                    logger.info("ğŸ“ æ’­æ”¾åˆ—è¡¨å¼€å¯YouTubeå­—å¹•ä¸‹è½½ï¼ˆä¸­æ–‡ã€è‹±æ–‡ï¼ŒSRTæ ¼å¼ï¼‰")

                logger.info(f"ğŸ”§ [YT_PLAYLIST_WITH_PROGRESS] æœ€ç»ˆydl_optså…³é”®é…ç½®: outtmpl={abs_outtmpl}")

                # ä½¿ç”¨åŸå§‹URLï¼ˆå¦‚æœæä¾›ï¼‰æˆ–æ„é€ æ’­æ”¾åˆ—è¡¨URL
                if original_url:
                    playlist_url = original_url
                    logger.info(f"ğŸ”— ä½¿ç”¨åŸå§‹URL: {playlist_url}")
                else:
                    playlist_url = f"https://www.youtube.com/playlist?list={playlist_id}"
                    logger.info(f"ğŸ“‹ ä½¿ç”¨æ„é€ çš„æ’­æ”¾åˆ—è¡¨URL: {playlist_url}")

                try:
                    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                        ydl.download([playlist_url])

                    # ä¸‹è½½å®Œæˆåæ£€æŸ¥å¹¶å¤„ç†PARTæ–‡ä»¶
                    logger.info("ğŸ” æ£€æŸ¥YouTubeæ’­æ”¾åˆ—è¡¨ä¸‹è½½å®ŒæˆçŠ¶æ€...")
                    resume_success = self._resume_failed_downloads(download_path, playlist_url, max_retries=5)

                    if not resume_success:
                        logger.warning("âš ï¸ éƒ¨åˆ†æ–‡ä»¶ä¸‹è½½æœªå®Œæˆï¼Œä½†å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°")
                    else:
                        logger.info("âœ… YouTubeæ’­æ”¾åˆ—è¡¨æ‰€æœ‰æ–‡ä»¶ä¸‹è½½å®Œæˆ")

                except Exception as e:
                    logger.error(f"âŒ YouTubeæ’­æ”¾åˆ—è¡¨ä¸‹è½½è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: {e}")
                    # å³ä½¿å‡ºé”™ä¹Ÿå°è¯•æ–­ç‚¹ç»­ä¼ PARTæ–‡ä»¶
                    logger.info("ğŸ”„ å°è¯•æ–­ç‚¹ç»­ä¼ æœªå®Œæˆçš„æ–‡ä»¶...")
                    self._resume_part_files(download_path, playlist_url)
                    raise

            await loop.run_in_executor(None, download_playlist)

            logger.info("ğŸ‰ æ’­æ”¾åˆ—è¡¨ä¸‹è½½å®Œæˆ!")

            # æŸ¥æ‰¾ä¸‹è½½çš„æ–‡ä»¶
            downloaded_files = []
            total_size_mb = 0
            all_resolutions = set()

            # ä½¿ç”¨é¢„æœŸæ–‡ä»¶åç²¾ç¡®æŸ¥æ‰¾ï¼ˆç°åœ¨åŠ¨æ€æ’­æ”¾åˆ—è¡¨ä¹Ÿæœ‰é¢„æœŸæ–‡ä»¶ä¿¡æ¯äº†ï¼‰
            logger.info("ğŸ” ä½¿ç”¨é¢„æœŸæ–‡ä»¶åæŸ¥æ‰¾ä¸‹è½½çš„æ–‡ä»¶")
            for expected_file in expected_files:
                    expected_filename = expected_file['filename']
                    expected_path = playlist_path / expected_filename

                    # æ£€æŸ¥é¢„æœŸæ–‡ä»¶æ˜¯å¦å­˜åœ¨
                    actual_path = expected_path
                    if expected_path.exists():
                        # æ–‡ä»¶å­˜åœ¨ï¼Œç›´æ¥ä½¿ç”¨
                        pass
                    elif (hasattr(self, 'bot') and hasattr(self.bot, 'youtube_audio_mode') and
                          self.bot.youtube_audio_mode):
                        # éŸ³é¢‘æ¨¡å¼ï¼šæ£€æŸ¥æ˜¯å¦å­˜åœ¨å¯¹åº”çš„MP3æ–‡ä»¶
                        mp3_path = expected_path.with_suffix('.mp3')
                        if mp3_path.exists():
                            actual_path = mp3_path
                            logger.info(f"ğŸµ æ’­æ”¾åˆ—è¡¨éŸ³é¢‘æ¨¡å¼ï¼šæ‰¾åˆ°è½¬æ¢åçš„MP3æ–‡ä»¶: {mp3_path.name}")
                        else:
                            logger.warning(f"âš ï¸ æ’­æ”¾åˆ—è¡¨éŸ³é¢‘æ¨¡å¼ï¼šæœªæ‰¾åˆ°æ–‡ä»¶: {expected_filename} æˆ– {mp3_path.name}")
                            continue
                    else:
                        logger.warning(f"âš ï¸ æœªæ‰¾åˆ°é¢„æœŸæ–‡ä»¶: {expected_filename}")
                        continue

                    # å¤„ç†æ‰¾åˆ°çš„æ–‡ä»¶
                    try:
                        file_size = actual_path.stat().st_size
                        if file_size > 0:
                            file_size_mb = file_size / (1024 * 1024)
                            total_size_mb += file_size_mb

                            # è·å–åª’ä½“ä¿¡æ¯
                            media_info = self.get_media_info(str(actual_path))
                            resolution = media_info.get('resolution', 'æœªçŸ¥')
                            if resolution != 'æœªçŸ¥':
                                all_resolutions.add(resolution)

                            downloaded_files.append({
                                "filename": actual_path.name,  # ä½¿ç”¨å®é™…æ–‡ä»¶å
                                "path": str(actual_path),      # ä½¿ç”¨å®é™…è·¯å¾„
                                "size_mb": file_size_mb,
                                "video_title": expected_file['title'],
                            })
                            logger.info(f"âœ… æ‰¾åˆ°é¢„æœŸæ–‡ä»¶: {actual_path.name} ({file_size_mb:.2f}MB)")
                        else:
                            logger.warning(f"âš ï¸ é¢„æœŸæ–‡ä»¶ä¸ºç©º: {actual_path.name}")
                    except Exception as e:
                        logger.warning(f"âš ï¸ æ— æ³•æ£€æŸ¥é¢„æœŸæ–‡ä»¶: {actual_path.name}, é”™è¯¯: {e}")

            # è®¡ç®—åˆ†è¾¨ç‡æ˜¾ç¤º
            resolution = ', '.join(sorted(all_resolutions)) if all_resolutions else 'æœªçŸ¥'

            logger.info(f"ğŸ“Š æ’­æ”¾åˆ—è¡¨æ‰¾åˆ°æ–‡ä»¶æ•°é‡: {len(downloaded_files)}/{len(expected_files)}")
            logger.info(f"ğŸ“Š æ€»å¤§å°: {total_size_mb:.2f}MB")

            return {
                "success": True,
                "playlist_title": playlist_title_with_id,  # ä½¿ç”¨å®é™…çš„ç›®å½•åä½œä¸ºæ ‡é¢˜
                "video_count": len(downloaded_files),
                "download_path": str(playlist_path),
                "total_size_mb": total_size_mb,
                "size_mb": total_size_mb,  # æ·»åŠ è¿™ä¸ªå­—æ®µä»¥å…¼å®¹main.py
                "resolution": resolution,
                "downloaded_files": downloaded_files,
            }

        except Exception as e:
            logger.error(f"âŒ YouTubeæ’­æ”¾åˆ—è¡¨ä¸‹è½½å¤±è´¥: {e}")
            import traceback

            logger.error(f"è¯¦ç»†é”™è¯¯ä¿¡æ¯: {traceback.format_exc()}")
            return {"success": False, "error": str(e)}



    def _make_progress_bar(self, percent: float) -> str:
        """ç”Ÿæˆè¿›åº¦æ¡"""
        bar_length = 20
        filled_length = int(bar_length * percent / 100)
        bar = "â–ˆ" * filled_length + "â–‘" * (bar_length - filled_length)
        return f"[{bar}] {percent:.1f}%"

    def _check_playlist_already_downloaded(
        self, playlist_id: str, download_path: Path
    ) -> Dict[str, Any]:
        """
        æ£€æŸ¥YouTubeæ’­æ”¾åˆ—è¡¨æ˜¯å¦å·²ç»å®Œæ•´ä¸‹è½½ï¼ˆä½¿ç”¨é¢„æœŸæ–‡ä»¶åæ–¹å¼ï¼‰

        Args:
            playlist_id: æ’­æ”¾åˆ—è¡¨ID
            download_path: ä¸‹è½½è·¯å¾„

        Returns:
            Dict: åŒ…å«æ£€æŸ¥ç»“æœçš„å­—å…¸
        """
        logger.info(f"ğŸ” æ£€æŸ¥æ’­æ”¾åˆ—è¡¨æ˜¯å¦å·²ä¸‹è½½: {playlist_id}")

        try:
            # è·å–æ’­æ”¾åˆ—è¡¨ä¿¡æ¯
            info_opts = {
                "quiet": True,
                "extract_flat": True,
                "ignoreerrors": True,
                "socket_timeout": 10,
                "retries": 2,
            }
            if self.proxy_host:
                info_opts["proxy"] = self.proxy_host
            if self.youtube_cookies_path and os.path.exists(self.youtube_cookies_path):
                info_opts["cookiefile"] = self.youtube_cookies_path

            with yt_dlp.YoutubeDL(info_opts) as ydl:
                info = ydl.extract_info(
                    f"https://www.youtube.com/playlist?list={playlist_id}",
                    download=False,
                )

            if not info:
                logger.warning("âŒ æ— æ³•è·å–æ’­æ”¾åˆ—è¡¨ä¿¡æ¯")
                return {"already_downloaded": False, "reason": "æ— æ³•è·å–æ’­æ”¾åˆ—è¡¨ä¿¡æ¯"}

            entries = info.get("entries", [])
            if not entries:
                logger.warning("âŒ æ’­æ”¾åˆ—è¡¨ä¸ºç©º")
                return {"already_downloaded": False, "reason": "æ’­æ”¾åˆ—è¡¨ä¸ºç©º"}

            # æ„å»ºé¢„æœŸæ–‡ä»¶åˆ—è¡¨ï¼ˆå’Œä¸‹è½½æ—¶ä¸€è‡´ï¼‰
            expected_files = []
            for i, entry in enumerate(entries, 1):
                title = entry.get("title", f"Video_{i}")
                safe_title = re.sub(r'[\\/:*?"<>|]', "_", title).strip()
                video_id = entry.get('id', '')

                # æ ¹æ®è®¾ç½®å†³å®šæ–‡ä»¶åæ ¼å¼ï¼Œä¸å®é™…ä¸‹è½½æ—¶çš„æ¨¡æ¿ä¿æŒä¸€è‡´
                if hasattr(self, 'bot') and hasattr(self.bot, 'youtube_id_tags') and self.bot.youtube_id_tags:
                    expected_filename = f"{i:02d}. {safe_title}[{video_id}].mp4"
                else:
                    expected_filename = f"{i:02d}. {safe_title}.mp4"

                expected_files.append({
                    'title': title,
                    'filename': expected_filename,
                    'index': i,
                    'id': video_id,
                })

            # åˆ›å»ºæ’­æ”¾åˆ—è¡¨ç›®å½•å
            playlist_title = re.sub(
                r'[\\/:*?"<>|]', "_", info.get("title", f"Playlist_{playlist_id}")
            ).strip()
            # æ ¹æ®è®¾ç½®å†³å®šæ–‡ä»¶å¤¹åç§°æ ¼å¼
            if hasattr(self, 'bot') and hasattr(self.bot, 'youtube_id_tags') and self.bot.youtube_id_tags:
                playlist_title_with_id = f"[{playlist_id}]"
            else:
                playlist_title_with_id = playlist_title
            playlist_path = download_path / playlist_title_with_id

            if not playlist_path.exists():
                logger.info(f"ğŸ“ æ’­æ”¾åˆ—è¡¨ç›®å½•ä¸å­˜åœ¨: {playlist_path}")
                return {"already_downloaded": False, "reason": "ç›®å½•ä¸å­˜åœ¨"}

            logger.info(f"ğŸ“ æ£€æŸ¥æ’­æ”¾åˆ—è¡¨ç›®å½•: {playlist_path}")

            # ä½¿ç”¨é¢„æœŸæ–‡ä»¶åæ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼ˆå’Œä¸‹è½½é€»è¾‘ä¸€è‡´ï¼‰
            missing_files = []
            existing_files = []
            total_size_mb = 0
            all_resolutions = set()

            def clean_filename_for_matching(filename):
                """æ¸…ç†æ–‡ä»¶åç”¨äºåŒ¹é…"""
                import re
                if not filename:
                    return ""

                # åˆ é™¤yt-dlpçš„å„ç§æ ¼å¼ä»£ç 
                cleaned = re.sub(r'\.[fm]\d+(\+\d+)*', '', filename)
                cleaned = re.sub(r'\.f\d+', '', cleaned)

                # åˆ é™¤YouTubeè§†é¢‘IDæ ‡è¯†ï¼ˆä»…åœ¨å¯ç”¨IDæ ‡ç­¾æ—¶ï¼‰
                if hasattr(self, 'bot') and hasattr(self.bot, 'youtube_id_tags') and self.bot.youtube_id_tags:
                    cleaned = re.sub(r'\[[a-zA-Z0-9_-]{10,12}\]', '', cleaned)

                cleaned = re.sub(r'\.(webm|m4a|mp3)$', '.mp4', cleaned)

                # ç¡®ä¿ä»¥ .mp4 ç»“å°¾
                if not cleaned.endswith('.mp4'):
                    cleaned = cleaned.rstrip('.') + '.mp4'

                return cleaned

            for expected_file in expected_files:
                expected_filename = expected_file['filename']
                expected_path = playlist_path / expected_filename
                title = expected_file['title']

                if expected_path.exists():
                    try:
                        file_size = expected_path.stat().st_size
                        if file_size > 0:
                            file_size_mb = file_size / (1024 * 1024)
                            total_size_mb += file_size_mb

                            # è·å–åª’ä½“ä¿¡æ¯
                            media_info = self.get_media_info(str(expected_path))
                            resolution = media_info.get('resolution', 'æœªçŸ¥')
                            if resolution != 'æœªçŸ¥':
                                all_resolutions.add(resolution)

                            existing_files.append({
                                "filename": expected_filename,
                                "path": str(expected_path),
                                "size_mb": file_size_mb,
                                "video_title": title,
                            })
                            logger.info(f"âœ… æ‰¾åˆ°æ–‡ä»¶: {expected_filename} ({file_size_mb:.2f}MB)")
                        else:
                            missing_files.append(f"{expected_file['index']}. {title}")
                            logger.warning(f"âš ï¸ æ–‡ä»¶ä¸ºç©º: {expected_filename}")
                    except Exception as e:
                        missing_files.append(f"{expected_file['index']}. {title}")
                        logger.warning(f"âš ï¸ æ— æ³•æ£€æŸ¥æ–‡ä»¶: {expected_filename}, é”™è¯¯: {e}")
                else:
                    # å°è¯•æ™ºèƒ½åŒ¹é…ï¼ˆå¤„ç†æ ¼å¼ä»£ç ç­‰ï¼‰
                    found = False
                    for video_ext in ["*.mp4", "*.mkv", "*.webm", "*.avi", "*.mov", "*.flv"]:
                        matching_files = list(playlist_path.glob(video_ext))
                        for file_path in matching_files:
                            actual_filename = file_path.name
                            cleaned_actual = clean_filename_for_matching(actual_filename)
                            cleaned_expected = clean_filename_for_matching(expected_filename)

                            if cleaned_actual == cleaned_expected:
                                try:
                                    file_size = file_path.stat().st_size
                                    if file_size > 0:
                                        file_size_mb = file_size / (1024 * 1024)
                                        total_size_mb += file_size_mb

                                        # è·å–åª’ä½“ä¿¡æ¯
                                        media_info = self.get_media_info(str(file_path))
                                        resolution = media_info.get('resolution', 'æœªçŸ¥')
                                        if resolution != 'æœªçŸ¥':
                                            all_resolutions.add(resolution)

                                        existing_files.append({
                                            "filename": actual_filename,
                                            "path": str(file_path),
                                            "size_mb": file_size_mb,
                                            "video_title": title,
                                        })
                                        logger.info(f"âœ… é€šè¿‡æ¨¡ç³ŠåŒ¹é…æ‰¾åˆ°æ–‡ä»¶: {actual_filename} ({file_size_mb:.2f}MB)")
                                        found = True
                                        break
                                except Exception as e:
                                    continue
                        if found:
                            break

                    if not found:
                        missing_files.append(f"{expected_file['index']}. {title}")
                        logger.warning(f"âš ï¸ æœªæ‰¾åˆ°æ–‡ä»¶: {expected_filename}")

            # è®¡ç®—å®Œæˆåº¦
            total_videos = len(expected_files)
            downloaded_videos = len(existing_files)
            completion_rate = (
                (downloaded_videos / total_videos) * 100 if total_videos > 0 else 0
            )

            logger.info(
                f"ğŸ“Š ä¸‹è½½å®Œæˆåº¦: {downloaded_videos}/{total_videos} ({completion_rate:.1f}%)"
            )

            # å¦‚æœå®Œæˆåº¦è¾¾åˆ°95%ä»¥ä¸Šï¼Œè®¤ä¸ºå·²ç»ä¸‹è½½å®Œæˆ
            if completion_rate >= 95:
                logger.info(f"âœ… æ’­æ”¾åˆ—è¡¨å·²å®Œæ•´ä¸‹è½½ ({completion_rate:.1f}%)")

                # è®¡ç®—åˆ†è¾¨ç‡ä¿¡æ¯
                resolution = ', '.join(sorted(all_resolutions)) if all_resolutions else 'æœªçŸ¥'
                if existing_files:
                    try:
                        import subprocess

                        first_file_path = existing_files[0]["path"]
                        result = subprocess.run(
                            [
                                "ffprobe",
                                "-v",
                                "quiet",
                                "-print_format",
                                "json",
                                "-show_streams",
                                first_file_path,
                            ],
                            capture_output=True,
                            text=True,
                        )
                        if result.returncode == 0:
                            import json

                            data = json.loads(result.stdout)
                            for stream in data.get("streams", []):
                                if stream.get("codec_type") == "video":
                                    width = stream.get("width", 0)
                                    height = stream.get("height", 0)
                                    if width and height:
                                        resolution = f"{width}x{height}"
                                        break
                    except Exception as e:
                        logger.warning(f"æ— æ³•è·å–è§†é¢‘åˆ†è¾¨ç‡: {e}")

                return {
                    "already_downloaded": True,
                    "playlist_title": playlist_title_with_id,  # ä½¿ç”¨å®é™…çš„ç›®å½•åä½œä¸ºæ ‡é¢˜
                    "video_count": downloaded_videos,
                    "total_videos": total_videos,
                    "completion_rate": completion_rate,
                    "download_path": str(playlist_path),
                    "total_size_mb": total_size_mb,
                    "resolution": resolution,
                    "downloaded_files": existing_files,
                    "missing_files": missing_files,
                }
            else:
                logger.info(f"ğŸ“¥ æ’­æ”¾åˆ—è¡¨æœªå®Œæ•´ä¸‹è½½ ({completion_rate:.1f}%)")
                return {
                    "already_downloaded": False,
                    "reason": f"å®Œæˆåº¦ä¸è¶³ ({completion_rate:.1f}%)",
                    "downloaded_videos": downloaded_videos,
                    "total_videos": total_videos,
                    "completion_rate": completion_rate,
                    "missing_files": missing_files,
                }

        except Exception as e:
            logger.error(f"âŒ æ£€æŸ¥æ’­æ”¾åˆ—è¡¨ä¸‹è½½çŠ¶æ€æ—¶å‡ºé”™: {e}")
            return {"already_downloaded": False, "reason": f"æ£€æŸ¥å¤±è´¥: {str(e)}"}

    def _convert_cookies_to_json(self, cookies_path: str) -> dict:
        """å°† Netscape æ ¼å¼çš„ cookies è½¬æ¢ä¸º gallery-dl æ”¯æŒçš„ JSON æ ¼å¼"""
        try:
            import http.cookiejar

            # åˆ›å»º cookie jar å¹¶åŠ è½½ cookies
            cookie_jar = http.cookiejar.MozillaCookieJar(cookies_path)
            cookie_jar.load()

            # è½¬æ¢ä¸ºå­—å…¸æ ¼å¼
            cookies_dict = {}
            for cookie in cookie_jar:
                cookies_dict[cookie.name] = cookie.value

            logger.info(f"âœ… æˆåŠŸè½¬æ¢ cookiesï¼Œå…± {len(cookies_dict)} ä¸ª")
            return cookies_dict

        except Exception as e:
            logger.error(f"âŒ cookies è½¬æ¢å¤±è´¥: {e}")
            return {}

    async def download_with_gallery_dl(
        self, url: str, download_path: Path, message_updater=None
    ) -> Dict[str, Any]:
        """ä½¿ç”¨ gallery-dl ä¸‹è½½å›¾ç‰‡"""
        if not GALLERY_DL_AVAILABLE:
            return {
                "success": False,
                "error": "gallery-dl æœªå®‰è£…ï¼Œæ— æ³•ä¸‹è½½å›¾ç‰‡ã€‚è¯·è¿è¡Œ: pip install gallery-dl"
            }

        try:
            # ç¡®ä¿ä¸‹è½½ç›®å½•å­˜åœ¨
            download_path.mkdir(parents=True, exist_ok=True)
            download_path_str = str(download_path)

            # ä½¿ç”¨æˆ‘ä»¬åˆ›å»ºçš„ gallery-dl.conf é…ç½®æ–‡ä»¶ - ä¸å®¹å™¨ä¸­å®Œå…¨ä¸€è‡´
            config_path = Path(self.download_path / "gallery-dl.conf")
            if config_path.exists():
                logger.info(f"ğŸ“„ ä½¿ç”¨ gallery-dl.conf é…ç½®æ–‡ä»¶: {config_path}")
                # åŠ è½½é…ç½®æ–‡ä»¶ - ä¸å®¹å™¨ä¸­å®Œå…¨ä¸€è‡´
                gallery_dl.config.load([str(config_path)])
            else:
                logger.warning(f"âš ï¸ gallery-dl.conf é…ç½®æ–‡ä»¶ä¸å­˜åœ¨: {config_path}")
                return {
                    "success": False,
                    "error": "gallery-dl.conf é…ç½®æ–‡ä»¶ä¸å­˜åœ¨"
                }

            # è·å– gallery-dl å®é™…ä½¿ç”¨çš„ä¸‹è½½ç›®å½•
            try:
                # ç›´æ¥ä»é…ç½®æ–‡ä»¶ä¸­è¯»å– base-directory
                import json
                if config_path.exists():
                    with open(config_path, 'r', encoding='utf-8') as f:
                        config_data = json.load(f)
                    actual_download_dir = config_data.get("base-directory", str(download_path))
                else:
                    actual_download_dir = str(download_path)
                logger.info(f"ğŸ¯ gallery-dl å®é™…ä¸‹è½½ç›®å½•: {actual_download_dir}")
            except Exception as e:
                logger.warning(f"âš ï¸ æ— æ³•ä»é…ç½®æ–‡ä»¶è¯»å–ä¸‹è½½ç›®å½•: {e}")
                actual_download_dir = str(download_path)
                logger.info(f"ğŸ¯ ä½¿ç”¨é»˜è®¤ä¸‹è½½ç›®å½•: {actual_download_dir}")

            # è®°å½•ä¸‹è½½å‰çš„æ–‡ä»¶
            actual_download_path = Path(actual_download_dir)
            before_files = set()
            if actual_download_path.exists():
                for file_path in actual_download_path.rglob("*"):
                    if file_path.is_file():
                        relative_path = str(file_path.relative_to(actual_download_path))
                        before_files.add(relative_path)

            logger.info(f"ğŸ“Š ä¸‹è½½å‰æ–‡ä»¶æ•°é‡: {len(before_files)}")
            if before_files:
                logger.info(f"ğŸ“Š ä¸‹è½½å‰æ–‡ä»¶ç¤ºä¾‹: {list(before_files)[:5]}")

            # å‘é€å¼€å§‹ä¸‹è½½æ¶ˆæ¯
            if message_updater:
                try:
                    if asyncio.iscoroutinefunction(message_updater):
                        await message_updater("ğŸ–¼ï¸ **å›¾ç‰‡ä¸‹è½½ä¸­**\nğŸ“ å½“å‰ä¸‹è½½ï¼šå‡†å¤‡ä¸­...\nğŸ–¼ï¸ å·²å®Œæˆï¼š0 å¼ ")
                    else:
                        message_updater("ğŸ–¼ï¸ **å›¾ç‰‡ä¸‹è½½ä¸­**\nğŸ“ å½“å‰ä¸‹è½½ï¼šå‡†å¤‡ä¸­...\nğŸ–¼ï¸ å·²å®Œæˆï¼š0 å¼ ")
                except Exception as e:
                    logger.warning(f"âš ï¸ å‘é€å¼€å§‹æ¶ˆæ¯å¤±è´¥: {e}")

            # åˆ›å»ºè¿›åº¦ç›‘æ§ä»»åŠ¡
            progress_task = None
            if message_updater:
                progress_task = asyncio.create_task(self._monitor_gallery_dl_progress(
                    actual_download_path, before_files, message_updater
                ))

            # ä½¿ç”¨æ­£ç¡®çš„ gallery-dl API - ä¸å®¹å™¨ä¸­å®Œå…¨ä¸€è‡´
            job = gallery_dl.job.DownloadJob(url, None)

            logger.info("ğŸ“¸ gallery-dl å¼€å§‹ä¸‹è½½...")

            # æ·»åŠ é‡è¯•æœºåˆ¶
            max_retries = 3
            retry_count = 0

            while retry_count < max_retries:
                try:
                    # åœ¨å¼‚æ­¥æ‰§è¡Œå™¨ä¸­è¿è¡ŒåŒæ­¥çš„ job.run()ï¼Œè®©è¿›åº¦ç›‘æ§èƒ½å¤ŸæŒç»­è¿è¡Œ
                    loop = asyncio.get_running_loop()
                    await loop.run_in_executor(None, job.run)

                    logger.info("ğŸ“¸ gallery-dl ä¸‹è½½ä»»åŠ¡å®Œæˆ")
                    break  # æˆåŠŸå®Œæˆï¼Œè·³å‡ºé‡è¯•å¾ªç¯

                except Exception as e:
                    retry_count += 1
                    error_str = str(e).lower()

                    if ("403" in error_str or "forbidden" in error_str) and retry_count < max_retries:
                        logger.warning(f"âš ï¸ é‡åˆ° 403 é”™è¯¯ï¼Œç¬¬ {retry_count} æ¬¡é‡è¯•...")
                        await asyncio.sleep(10)  # ç­‰å¾…10ç§’åé‡è¯•
                        continue
                    else:
                        # å…¶ä»–é”™è¯¯æˆ–é‡è¯•æ¬¡æ•°ç”¨å®Œï¼ŒæŠ›å‡ºå¼‚å¸¸
                        raise e

            # ç­‰å¾…ä¸€ä¸‹ç¡®ä¿æ–‡ä»¶å†™å…¥å®Œæˆ
            await asyncio.sleep(3)

            # å–æ¶ˆè¿›åº¦ç›‘æ§ä»»åŠ¡
            if progress_task:
                progress_task.cancel()
                try:
                    await progress_task
                except asyncio.CancelledError:
                    logger.info("ğŸ“Š è¿›åº¦ç›‘æ§ä»»åŠ¡å·²å–æ¶ˆ")
                    pass

            # æŸ¥æ‰¾æ–°ä¸‹è½½çš„æ–‡ä»¶ï¼ˆåœ¨ gallery-dl å®é™…ä¸‹è½½ç›®å½•ä¸­ï¼‰
            downloaded_files = []
            total_size_bytes = 0
            file_formats = set()

            logger.info(f"ğŸ” å¼€å§‹æŸ¥æ‰¾æ–°ä¸‹è½½çš„æ–‡ä»¶...")
            logger.info(f"ğŸ” æŸ¥æ‰¾ç›®å½•: {actual_download_dir}")
            logger.info(f"ğŸ” ä¸‹è½½å‰æ–‡ä»¶æ•°é‡: {len(before_files)}")

            if actual_download_path.exists():
                # è·å–å½“å‰æ‰€æœ‰æ–‡ä»¶
                current_files = set()
                for file_path in actual_download_path.rglob("*"):
                    if file_path.is_file():
                        relative_path = str(file_path.relative_to(actual_download_path))
                        current_files.add(relative_path)

                logger.info(f"ğŸ” å½“å‰æ–‡ä»¶æ•°é‡: {len(current_files)}")

                # è®¡ç®—æ–°æ–‡ä»¶
                new_files = current_files - before_files
                logger.info(f"ğŸ” æ–°æ–‡ä»¶æ•°é‡: {len(new_files)}")

                # è®°å½•ä¸€äº›æ–°æ–‡ä»¶ä½œä¸ºç¤ºä¾‹
                if new_files:
                    sample_files = list(new_files)[:5]  # å‰5ä¸ªæ–‡ä»¶
                    logger.info(f"ğŸ” æ–°æ–‡ä»¶ç¤ºä¾‹: {sample_files}")

                    # ç›´æ¥å¤„ç†æ–°æ–‡ä»¶ï¼Œä¸éœ€è¦é¢å¤–éå†
                    for relative_path in new_files:
                        file_path = actual_download_path / relative_path
                        if file_path.is_file():
                            # æ£€æŸ¥æ˜¯å¦ä¸ºå›¾ç‰‡æˆ–è§†é¢‘æ–‡ä»¶
                            if file_path.suffix.lower() in ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.mp4', '.mov', '.avi', '.mkv']:
                                downloaded_files.append(file_path)
                                try:
                                    file_size = file_path.stat().st_size
                                    total_size_bytes += file_size
                                    file_formats.add(file_path.suffix.lower())
                                    logger.info(f"âœ… æ‰¾åˆ°ä¸‹è½½æ–‡ä»¶: {relative_path} ({file_size} bytes)")
                                except OSError as e:
                                    logger.warning(f"æ— æ³•è·å–æ–‡ä»¶å¤§å°: {file_path} - {e}")
                else:
                    # å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ–°æ–‡ä»¶ï¼Œå°è¯•æŸ¥æ‰¾æœ€è¿‘ä¿®æ”¹çš„æ–‡ä»¶
                    logger.warning(f"âš ï¸ æ²¡æœ‰æ‰¾åˆ°æ–°æ–‡ä»¶ï¼Œå°è¯•æŸ¥æ‰¾æœ€è¿‘ä¿®æ”¹çš„æ–‡ä»¶...")
                    try:
                        recent_files = []
                        for file_path in actual_download_path.rglob("*"):
                            if file_path.is_file():
                                # æ£€æŸ¥æ–‡ä»¶ä¿®æ”¹æ—¶é—´æ˜¯å¦åœ¨æœ€è¿‘5åˆ†é’Ÿå†…
                                file_mtime = file_path.stat().st_mtime
                                if time.time() - file_mtime < 300:  # 5åˆ†é’Ÿ
                                    recent_files.append(file_path)

                        logger.info(f"ğŸ” æœ€è¿‘5åˆ†é’Ÿå†…ä¿®æ”¹çš„æ–‡ä»¶æ•°é‡: {len(recent_files)}")
                        if recent_files:
                            logger.info(f"ğŸ” æœ€è¿‘ä¿®æ”¹çš„æ–‡ä»¶ç¤ºä¾‹: {[f.name for f in recent_files[:3]]}")
                            # å°†è¿™äº›æœ€è¿‘ä¿®æ”¹çš„æ–‡ä»¶ä½œä¸ºä¸‹è½½çš„æ–‡ä»¶
                            for file_path in recent_files:
                                if file_path.suffix.lower() in ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.mp4', '.mov', '.avi', '.mkv']:
                                    downloaded_files.append(file_path)
                                    try:
                                        file_size = file_path.stat().st_size
                                        total_size_bytes += file_size
                                        file_formats.add(file_path.suffix.lower())
                                        logger.info(f"âœ… æ‰¾åˆ°æœ€è¿‘ä¿®æ”¹çš„æ–‡ä»¶: {file_path.name} ({file_size} bytes)")
                                    except OSError as e:
                                        logger.warning(f"æ— æ³•è·å–æ–‡ä»¶å¤§å°: {file_path} - {e}")
                    except Exception as e:
                        logger.error(f"âŒ æŸ¥æ‰¾æœ€è¿‘ä¿®æ”¹æ–‡ä»¶æ—¶å‡ºé”™: {e}")
            else:
                logger.warning(f"âš ï¸ ä¸‹è½½ç›®å½•ä¸å­˜åœ¨: {actual_download_dir}")

            logger.info(f"ğŸ” æœ€ç»ˆæ‰¾åˆ°çš„ä¸‹è½½æ–‡ä»¶æ•°é‡: {len(downloaded_files)}")

            if downloaded_files:
                # è®¡ç®—æ€»å¤§å°
                size_mb = total_size_bytes / (1024 * 1024)

                # æ ¼å¼åŒ–æ–‡ä»¶æ ¼å¼æ˜¾ç¤º
                format_str = ", ".join(sorted(file_formats)) if file_formats else "æœªçŸ¥æ ¼å¼"

                # ç”Ÿæˆè¯¦ç»†çš„ç»“æœä¿¡æ¯
                result = {
                    "success": True,
                    "message": f"âœ… å›¾ç‰‡ä¸‹è½½å®Œæˆï¼\n\nğŸ–¼ï¸ å›¾ç‰‡æ•°é‡ï¼š{len(downloaded_files)} å¼ \nğŸ“ ä¿å­˜ä½ç½®ï¼š{actual_download_dir}\nğŸ’¾ æ€»å¤§å°ï¼š{size_mb:.1f} MB\nğŸ“„ æ–‡ä»¶æ ¼å¼ï¼š{format_str}",
                    "files_count": len(downloaded_files),
                    "failed_count": 0,
                    "files": [str(f) for f in downloaded_files],
                    "size_mb": size_mb,
                    "filename": downloaded_files[0].name if downloaded_files else "æœªçŸ¥æ–‡ä»¶",
                    "download_path": actual_download_dir,
                    "full_path": str(downloaded_files[0]) if downloaded_files else "",
                    "resolution": "å›¾ç‰‡",
                    "abr": None,
                    "file_formats": list(file_formats)
                }

                logger.info(f"âœ… gallery-dl ä¸‹è½½æˆåŠŸ: {len(downloaded_files)} ä¸ªæ–‡ä»¶, æ€»å¤§å°: {size_mb:.1f} MB")
                return result
            else:
                logger.warning(f"âš ï¸ æœªæ‰¾åˆ°æ–°ä¸‹è½½çš„æ–‡ä»¶ï¼ŒæŸ¥æ‰¾ç›®å½•: {actual_download_dir}")
                logger.warning(f"âš ï¸ ä¸‹è½½å‰æ–‡ä»¶æ•°é‡: {len(before_files)}")
                return {
                    "success": False,
                    "error": "æœªæ‰¾åˆ°ä¸‹è½½çš„æ–‡ä»¶"
                }

        except Exception as e:
            logger.error(f"gallery-dl ä¸‹è½½å¤±è´¥: {e}")

            # ç‰¹æ®Šå¤„ç†ä¸åŒç±»å‹çš„é”™è¯¯
            error_str = str(e).lower()
            if "403" in error_str or "forbidden" in error_str:
                error_msg = (
                    f"âŒ è®¿é—®è¢«æ‹’ç» (403 Forbidden)\n\n"
                    f"å¯èƒ½çš„åŸå› ï¼š\n"
                    f"1. æœåŠ¡å™¨æ£€æµ‹åˆ°çˆ¬è™«è¡Œä¸º\n"
                    f"2. IPåœ°å€è¢«ä¸´æ—¶å°ç¦\n"
                    f"3. éœ€è¦ç‰¹å®šçš„è¯·æ±‚å¤´æˆ–cookies\n"
                    f"4. å†…å®¹éœ€è¦ç™»å½•æ‰èƒ½è®¿é—®\n\n"
                    f"å»ºè®®è§£å†³æ–¹æ¡ˆï¼š\n"
                    f"1. ç­‰å¾…å‡ åˆ†é’Ÿåé‡è¯•\n"
                    f"2. æ£€æŸ¥cookiesæ–‡ä»¶æ˜¯å¦æœ‰æ•ˆ\n"
                    f"3. å°è¯•ä½¿ç”¨ä»£ç†\n"
                    f"4. è”ç³»ç®¡ç†å‘˜è·å–å¸®åŠ©"
                )
            elif "nsfw" in error_str or "authorizationerror" in error_str:
                error_msg = (
                    f"âŒ NSFWå†…å®¹ä¸‹è½½å¤±è´¥\n\n"
                    f"è¯·ç¡®ä¿ï¼š\n"
                    f"1. å·²é…ç½®æœ‰æ•ˆçš„X cookiesæ–‡ä»¶è·¯å¾„\n"
                    f"2. Xè´¦æˆ·å…è®¸æŸ¥çœ‹NSFWå†…å®¹\n"
                    f"3. è´¦æˆ·å·²å®Œæˆå¹´é¾„éªŒè¯\n"
                    f"4. cookiesæ–‡ä»¶æ ¼å¼æ­£ç¡®ï¼ˆNetscapeæ ¼å¼ï¼‰\n"
                    f"5. cookiesæ–‡ä»¶åŒ…å«æœ‰æ•ˆçš„è®¤è¯ä¿¡æ¯"
                )
            elif "timeout" in error_str or "connection" in error_str:
                error_msg = (
                    f"âŒ ç½‘ç»œè¿æ¥è¶…æ—¶\n\n"
                    f"å¯èƒ½çš„åŸå› ï¼š\n"
                    f"1. ç½‘ç»œè¿æ¥ä¸ç¨³å®š\n"
                    f"2. æœåŠ¡å™¨å“åº”æ…¢\n"
                    f"3. é˜²ç«å¢™é˜»æ­¢è¿æ¥\n\n"
                    f"å»ºè®®è§£å†³æ–¹æ¡ˆï¼š\n"
                    f"1. æ£€æŸ¥ç½‘ç»œè¿æ¥\n"
                    f"2. ç¨åé‡è¯•\n"
                    f"3. å°è¯•ä½¿ç”¨ä»£ç†"
                )
            else:
                error_msg = f"âŒ gallery-dl ä¸‹è½½å¤±è´¥: {str(e)}"

            return {
                "success": False,
                "error": error_msg
            }

    async def _monitor_gallery_dl_progress(self, download_path: Path, before_files: set, message_updater):
        """ç›‘æ§ gallery-dl ä¸‹è½½è¿›åº¦"""
        try:
            last_count = 0
            last_update_time = time.time()
            update_interval = 3  # æ¯3ç§’æ›´æ–°ä¸€æ¬¡è¿›åº¦

            logger.info(f"ğŸ“Š å¼€å§‹ç›‘æ§ gallery-dl è¿›åº¦")
            logger.info(f"ğŸ“Š ç›‘æ§ç›®å½•: {download_path}")
            logger.info(f"ğŸ“Š ä¸‹è½½å‰æ–‡ä»¶æ•°é‡: {len(before_files)}")
            if before_files:
                logger.info(f"ğŸ“Š ä¸‹è½½å‰æ–‡ä»¶ç¤ºä¾‹: {list(before_files)[:3]}")

            while True:
                await asyncio.sleep(2)  # æ¯2ç§’æ£€æŸ¥ä¸€æ¬¡

                # è®¡ç®—å½“å‰æ–‡ä»¶æ•°é‡
                current_files = set()
                if download_path.exists():
                    for file_path in download_path.rglob("*"):
                        if file_path.is_file():
                            relative_path = str(file_path.relative_to(download_path))
                            current_files.add(relative_path)

                # è®¡ç®—æ–°æ–‡ä»¶æ•°é‡
                new_files = current_files - before_files
                current_count = len(new_files)

                logger.info(f"ğŸ“Š å½“å‰æ–‡ä»¶æ•°é‡: {len(current_files)}, æ–°æ–‡ä»¶æ•°é‡: {current_count}")
                if new_files:
                    logger.info(f"ğŸ“Š æ–°æ–‡ä»¶ç¤ºä¾‹: {list(new_files)[:3]}")

                # å¦‚æœæ–‡ä»¶æ•°é‡æœ‰å˜åŒ–æˆ–æ—¶é—´é—´éš”åˆ°äº†ï¼Œæ›´æ–°è¿›åº¦
                if current_count != last_count or time.time() - last_update_time > update_interval:
                    last_count = current_count
                    last_update_time = time.time()

                    # è·å–å½“å‰æ­£åœ¨ä¸‹è½½çš„æ–‡ä»¶è·¯å¾„
                    current_file_path = "å‡†å¤‡ä¸­..."
                    if new_files:
                        # è·å–æœ€æ–°çš„æ–‡ä»¶
                        latest_file = sorted(new_files)[-1]
                        # æ˜¾ç¤ºå®Œæ•´çš„ç›¸å¯¹è·¯å¾„
                        current_file_path = latest_file

                    progress_text = (
                        f"ğŸ–¼ï¸ **å›¾ç‰‡ä¸‹è½½ä¸­**\n"
                        f"ğŸ“ å½“å‰ä¸‹è½½ï¼š{current_file_path}\n"
                        f"ğŸ–¼ï¸ å·²å®Œæˆï¼š{current_count} å¼ "
                    )

                    try:
                        # æ£€æŸ¥message_updateræ˜¯å¦ä¸ºNone
                        if message_updater is None:
                            logger.warning(f"âš ï¸ message_updaterä¸ºNoneï¼Œè·³è¿‡è¿›åº¦æ›´æ–°")
                            continue

                        # æ£€æŸ¥message_updaterçš„ç±»å‹å¹¶å®‰å…¨è°ƒç”¨
                        if asyncio.iscoroutinefunction(message_updater):
                            await message_updater(progress_text)
                        else:
                            message_updater(progress_text)
                        logger.info(f"ğŸ“Š gallery-dl è¿›åº¦æ›´æ–°: {current_count} å¼ å›¾ç‰‡, å½“å‰æ–‡ä»¶: {current_file_path}")
                    except Exception as e:
                        logger.warning(f"âš ï¸ æ›´æ–°è¿›åº¦æ¶ˆæ¯å¤±è´¥: {e}")
                        # ä¸é€€å‡ºå¾ªç¯ï¼Œç»§ç»­ç›‘æ§
                        continue

        except asyncio.CancelledError:
            logger.info("ğŸ“Š è¿›åº¦ç›‘æ§ä»»åŠ¡å·²å–æ¶ˆ")
        except Exception as e:
            logger.error(f"âŒ è¿›åº¦ç›‘æ§ä»»åŠ¡é”™è¯¯: {e}")

    async def download_x_content(self, url: str, message: types.Message) -> dict:
        """ä¸‹è½½ X å†…å®¹ï¼ˆå›¾ç‰‡æˆ–è§†é¢‘ï¼‰"""
        logger.info(f"ğŸš€ å¼€å§‹ä¸‹è½½ X å†…å®¹: {url}")

        # æ£€æµ‹å†…å®¹ç±»å‹
        content_type = self._detect_x_content_type(url)
        logger.info(f"ğŸ“Š æ£€æµ‹åˆ°å†…å®¹ç±»å‹: {content_type}")

        if content_type == "video":
            # è§†é¢‘ä½¿ç”¨ yt-dlp ä¸‹è½½
            logger.info("ğŸ¬ ä½¿ç”¨ yt-dlp ä¸‹è½½ X è§†é¢‘")

            # åˆ›å»º message_updater å‡½æ•°
            async def message_updater(text_or_dict):
                try:
                    if isinstance(text_or_dict, dict):
                        await message.reply(str(text_or_dict))
                    else:
                        await message.reply(text_or_dict)
                except Exception as e:
                    logger.warning(f"âš ï¸ æ›´æ–°è¿›åº¦æ¶ˆæ¯å¤±è´¥: {e}")

            return await self._download_x_video_with_ytdlp(url, message_updater)
        else:
            # å›¾ç‰‡ä½¿ç”¨ gallery-dl ä¸‹è½½
            logger.info("ğŸ“¸ ä½¿ç”¨ gallery-dl ä¸‹è½½ X å›¾ç‰‡")
            return await self._download_x_image_with_gallerydl(url, message)

    async def _download_x_video_with_ytdlp(self, url: str, message_updater=None) -> dict:
        """ä½¿ç”¨ yt-dlp ä¸‹è½½ X è§†é¢‘"""
        return await self._download_with_ytdlp_unified(
            url=url,
            download_path=self.x_download_path,
            message_updater=message_updater,
            platform_name="X",
            content_type="video",
            format_spec="bestvideo[ext=mp4]+bestaudio[ext=m4a]/bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best",
            cookies_path=self.x_cookies_path
        )



    async def _download_x_playlist(self, url: str, download_path: Path, message_updater=None, playlist_info: dict = None) -> Dict[str, Any]:
        """ä¸‹è½½Xæ’­æ”¾åˆ—è¡¨ä¸­çš„æ‰€æœ‰è§†é¢‘"""
        import os
        import time
        from pathlib import Path
        import asyncio

        logger.info(f"ğŸ¬ å¼€å§‹ä¸‹è½½Xæ’­æ”¾åˆ—è¡¨: {url}")
        logger.info(f"ğŸ“Š æ’­æ”¾åˆ—è¡¨ä¿¡æ¯: {playlist_info}")

        if not playlist_info:
            return {'success': False, 'error': 'æ’­æ”¾åˆ—è¡¨ä¿¡æ¯ä¸ºç©º'}

        total_videos = playlist_info.get('total_videos', 0)
        if total_videos == 0:
            return {'success': False, 'error': 'æ’­æ”¾åˆ—è¡¨ä¸­æ²¡æœ‰è§†é¢‘'}

        # è®°å½•ä¸‹è½½å¼€å§‹æ—¶é—´
        download_start_time = time.time()
        logger.info(f"â° ä¸‹è½½å¼€å§‹æ—¶é—´: {download_start_time}")

        # åˆ›å»ºè¿›åº¦è·Ÿè¸ª
        progress_data = {
            'current': 0,
            'total': total_videos,
            'start_time': download_start_time,
            'downloaded_files': []
        }

        # è®°å½•ä¸‹è½½å¼€å§‹æ—¶é—´
        download_start_time = time.time()
        logger.info(f"â° ä¸‹è½½å¼€å§‹æ—¶é—´: {download_start_time}")

        def create_playlist_progress_callback(progress_data):
            def escape_num(text):
                # åªè½¬ä¹‰MarkdownV2ç‰¹æ®Šå­—ç¬¦ï¼Œä¸è½¬ä¹‰å°æ•°ç‚¹
                special_chars = ['_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!']
                for char in special_chars:
                    text = text.replace(char, f'\\{char}')
                return text

            def calculate_overall_progress():
                if not progress_data or not isinstance(progress_data, dict) or progress_data['total'] == 0:
                    return 0
                return (progress_data['current'] / progress_data['total']) * 100

            def progress_callback(d):
                try:
                    if not progress_data or not isinstance(progress_data, dict):
                        return
                    current = progress_data['current']
                    total = progress_data['total']
                    overall_percent = calculate_overall_progress()

                    if d.get('status') == 'finished':
                        progress_data['current'] += 1
                        current = progress_data['current']
                        overall_percent = calculate_overall_progress()

                        # è®°å½•ä¸‹è½½çš„æ–‡ä»¶å¹¶ç›‘æ§åˆå¹¶çŠ¶æ€
                        if 'filename' in d:
                            filename = d['filename']
                            if 'downloaded_files' not in progress_data:
                                progress_data['downloaded_files'] = []
                            progress_data['downloaded_files'].append(filename)

                            # ç›‘æ§æ–‡ä»¶åˆå¹¶çŠ¶æ€
                            if filename.endswith('.part'):
                                logger.warning(f"âš ï¸ æ–‡ä»¶åˆå¹¶å¯èƒ½å¤±è´¥: {filename}")
                            else:
                                logger.info(f"âœ… æ–‡ä»¶ä¸‹è½½å¹¶åˆå¹¶æˆåŠŸ: {filename}")

                    # åˆ›å»ºè¿›åº¦æ¶ˆæ¯
                    progress_bar = self._make_progress_bar(overall_percent)
                    elapsed_time = time.time() - (progress_data['start_time'] if progress_data and isinstance(progress_data, dict) else time.time())

                    status_text = f"ğŸ¬ Xæ’­æ”¾åˆ—è¡¨ä¸‹è½½è¿›åº¦\n"
                    status_text += f"ğŸ“Š æ€»ä½“è¿›åº¦: {progress_bar} {overall_percent:.1f}%\n"
                    status_text += f"ğŸ“¹ å½“å‰: {current}/{total} ä¸ªè§†é¢‘\n"
                    status_text += f"â±ï¸ å·²ç”¨æ—¶: {elapsed_time:.0f}ç§’\n"

                    if d.get('status') == 'downloading':
                        if '_percent_str' in d:
                            status_text += f"ğŸ“¥ å½“å‰è§†é¢‘: {d.get('_percent_str', '0%')}\n"
                        if '_speed_str' in d:
                            status_text += f"ğŸš€ é€Ÿåº¦: {d.get('_speed_str', 'N/A')}\n"

                    # è½¬ä¹‰Markdownç‰¹æ®Šå­—ç¬¦
                    escaped_text = escape_num(status_text)

                    # ä½¿ç”¨asyncio.run_coroutine_threadsafeæ¥æ›´æ–°è¿›åº¦
                    try:
                        if message_updater:
                            # æ£€æŸ¥message_updaterçš„ç±»å‹
                            if asyncio.iscoroutinefunction(message_updater):
                                # å®‰å…¨åœ°è·å–äº‹ä»¶å¾ªç¯
                                try:
                                    loop = asyncio.get_running_loop()
                                except RuntimeError:
                                    try:
                                        loop = asyncio.get_event_loop()
                                    except RuntimeError:
                                        loop = asyncio.new_event_loop()
                                        asyncio.set_event_loop(loop)

                                # è°ƒç”¨å¼‚æ­¥å‡½æ•°å¹¶è·å–åç¨‹å¯¹è±¡
                                coro = message_updater(escaped_text)
                                asyncio.run_coroutine_threadsafe(coro, loop)
                            else:
                                # å¦‚æœæ˜¯åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                                message_updater(escaped_text)
                    except Exception as e:
                        if "Message is not modified" not in str(e):
                            logger.warning(f"âš ï¸ æ›´æ–°æ’­æ”¾åˆ—è¡¨è¿›åº¦å¤±è´¥: {e}")
                        # å¦‚æœmessage_updaterå¤±è´¥ï¼Œè®°å½•æ—¥å¿—
                        logger.info(f"è¿›åº¦æ›´æ–°: {escaped_text}")

                except Exception as e:
                    logger.warning(f"âš ï¸ æ›´æ–°æ’­æ”¾åˆ—è¡¨è¿›åº¦å¤±è´¥: {e}")

            return progress_callback

        try:
            # ä½¿ç”¨å¢å¼ºçš„yt-dlpé…ç½®ä¸‹è½½æ•´ä¸ªæ’­æ”¾åˆ—è¡¨
            # æ ¹æ®è®¾ç½®å†³å®šæ˜¯å¦åœ¨æ–‡ä»¶åæ·»åŠ è§†é¢‘ID
            if hasattr(self, 'bot') and hasattr(self.bot, 'youtube_id_tags') and self.bot.youtube_id_tags:
                outtmpl = str(download_path / '%(title)s[%(id)s].%(ext)s')
            else:
                outtmpl = str(download_path / '%(title)s.%(ext)s')

            base_opts = {
                'outtmpl': outtmpl,
                'format': 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best',
                'progress_hooks': [create_playlist_progress_callback(progress_data)],
            }

            # è·å–å¢å¼ºé…ç½®ï¼Œé¿å…PARTæ–‡ä»¶
            ydl_opts = self._get_enhanced_ydl_opts(base_opts)
            logger.info("ğŸ›¡ï¸ ä½¿ç”¨å¢å¼ºé…ç½®ï¼Œé¿å…PARTæ–‡ä»¶äº§ç”Ÿ")

            # ç¡®ä¿ä¸ºXé“¾æ¥æ·»åŠ æ­£ç¡®çš„cookiesï¼ˆè¦†ç›–å¢å¼ºé…ç½®ä¸­çš„é€šç”¨cookiesï¼‰
            if (
                self.is_x_url(url)
                and self.x_cookies_path
                and os.path.exists(self.x_cookies_path)
            ):
                ydl_opts["cookiefile"] = self.x_cookies_path
                logger.info(f"ğŸª ä¸ºXæ’­æ”¾åˆ—è¡¨æ·»åŠ cookies: {self.x_cookies_path}")
            elif self.is_x_url(url):
                logger.warning("âš ï¸ æ£€æµ‹åˆ°Xæ’­æ”¾åˆ—è¡¨ä½†æœªè®¾ç½®cookiesæ–‡ä»¶")
                logger.warning("âš ï¸ NSFWå†…å®¹éœ€è¦ç™»å½•æ‰èƒ½ä¸‹è½½")
                if self.x_cookies_path:
                    logger.warning(f"âš ï¸ X cookiesæ–‡ä»¶ä¸å­˜åœ¨: {self.x_cookies_path}")
                else:
                    logger.warning("âš ï¸ æœªè®¾ç½®X_COOKIESç¯å¢ƒå˜é‡")
                logger.warning("ğŸ’¡ è¯·è®¾ç½®X_COOKIESç¯å¢ƒå˜é‡æŒ‡å‘cookiesæ–‡ä»¶è·¯å¾„")

            # ä¸‹è½½æ’­æ”¾åˆ—è¡¨
            loop = asyncio.get_running_loop()
            try:
                await loop.run_in_executor(None, lambda: yt_dlp.YoutubeDL(ydl_opts).download([url]))

                # ä¸‹è½½å®Œæˆåæ£€æŸ¥å¹¶å¤„ç†PARTæ–‡ä»¶
                logger.info("ğŸ” æ£€æŸ¥ä¸‹è½½å®ŒæˆçŠ¶æ€...")
                resume_success = self._resume_failed_downloads(download_path, url, max_retries=5)

                if not resume_success:
                    logger.warning("âš ï¸ éƒ¨åˆ†æ–‡ä»¶ä¸‹è½½æœªå®Œæˆï¼Œä½†å·²è¾¾åˆ°æœ€å¤§é‡è¯•æ¬¡æ•°")
                else:
                    logger.info("âœ… æ‰€æœ‰æ–‡ä»¶ä¸‹è½½å®Œæˆ")

            except Exception as e:
                logger.error(f"âŒ ä¸‹è½½è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯: {e}")
                # å³ä½¿å‡ºé”™ä¹Ÿå°è¯•æ–­ç‚¹ç»­ä¼ PARTæ–‡ä»¶
                logger.info("ğŸ”„ å°è¯•æ–­ç‚¹ç»­ä¼ æœªå®Œæˆçš„æ–‡ä»¶...")
                self._resume_part_files(download_path, url)

            await asyncio.sleep(1)

            # ä½¿ç”¨progress_dataä¸­è®°å½•çš„æ–‡ä»¶åˆ—è¡¨æ¥æ£€æµ‹ä¸‹è½½çš„æ–‡ä»¶
            video_files = []
            downloaded_files = progress_data.get('downloaded_files', []) if progress_data and isinstance(progress_data, dict) else []
            logger.info(f"ğŸ“Š progress_dataä¸­è®°å½•çš„æ–‡ä»¶: {downloaded_files}")

            # é¦–å…ˆå°è¯•ä½¿ç”¨progress_dataä¸­è®°å½•çš„æ–‡ä»¶
            if downloaded_files:
                for filename in downloaded_files:
                    file_path = download_path / filename
                    if file_path.exists():
                        video_files.append((file_path, os.path.getmtime(file_path)))
                        logger.info(f"âœ… æ‰¾åˆ°æœ¬æ¬¡ä¸‹è½½æ–‡ä»¶: {filename}")
                    else:
                        logger.warning(f"âš ï¸ æ–‡ä»¶ä¸å­˜åœ¨: {filename}")

            # å¦‚æœprogress_dataä¸­æ²¡æœ‰è®°å½•ï¼Œåˆ™ä½¿ç”¨æ—¶é—´æ£€æµ‹
            if not video_files:
                logger.info("ğŸ”„ ä½¿ç”¨æ—¶é—´æ£€æµ‹æ–¹æ³•æŸ¥æ‰¾ä¸‹è½½æ–‡ä»¶")
                for file in download_path.glob("*.mp4"):
                    try:
                        mtime = os.path.getmtime(file)
                        # å¦‚æœæ–‡ä»¶ä¿®æ”¹æ—¶é—´åœ¨ä¸‹è½½å¼€å§‹æ—¶é—´ä¹‹åï¼Œè®¤ä¸ºæ˜¯æœ¬æ¬¡ä¸‹è½½çš„æ–‡ä»¶
                        if mtime >= download_start_time:
                            video_files.append((file, mtime))
                            logger.info(f"âœ… æ‰¾åˆ°æœ¬æ¬¡ä¸‹è½½æ–‡ä»¶: {file.name}, ä¿®æ”¹æ—¶é—´: {mtime}")
                    except OSError:
                        continue

            video_files.sort(key=lambda x: x[0].name)

            # æ£€æµ‹PARTæ–‡ä»¶
            part_files = self._detect_part_files(download_path)
            success_count = len(video_files)
            part_count = len(part_files)

            # åœ¨æ—¥å¿—ä¸­æ˜¾ç¤ºè¯¦ç»†ç»Ÿè®¡
            logger.info(f"ğŸ“Š ä¸‹è½½å®Œæˆç»Ÿè®¡ï¼š")
            logger.info(f"âœ… æˆåŠŸæ–‡ä»¶ï¼š{success_count} ä¸ª")
            if part_count > 0:
                logger.warning(f"âš ï¸ æœªå®Œæˆæ–‡ä»¶ï¼š{part_count} ä¸ª")
                self._log_part_files_details(part_files)
            else:
                logger.info("âœ… æœªå‘ç°PARTæ–‡ä»¶ï¼Œæ‰€æœ‰ä¸‹è½½éƒ½å·²å®Œæˆ")

            if video_files:
                total_size_mb = 0
                file_info_list = []
                all_resolutions = set()

                for file_path, mtime in video_files:
                    size_mb = os.path.getsize(file_path) / (1024 * 1024)
                    total_size_mb += size_mb
                    media_info = self.get_media_info(str(file_path))
                    resolution = media_info.get('resolution', 'æœªçŸ¥')
                    if resolution != 'æœªçŸ¥':
                        all_resolutions.add(resolution)
                    file_info_list.append({
                        'filename': os.path.basename(file_path),
                        'size_mb': size_mb,
                        'resolution': resolution,
                        'abr': media_info.get('bit_rate')
                    })

                filename_list = [info['filename'] for info in file_info_list]
                filename_display = '\n'.join([f"  {i+1:02d}. {name}" for i, name in enumerate(filename_list)])
                resolution_display = ', '.join(sorted(all_resolutions)) if all_resolutions else 'æœªçŸ¥'

                return {
                    'success': True,
                    'is_playlist': True,
                    'file_count': len(video_files),
                    'total_size_mb': total_size_mb,
                    'files': file_info_list,
                    'platform': 'X',
                    'download_path': str(download_path),
                    'filename': filename_display,
                    'size_mb': total_size_mb,
                    'resolution': resolution_display,
                    'episode_count': len(video_files),
                    # æ·»åŠ PARTæ–‡ä»¶ç»Ÿè®¡ä¿¡æ¯
                    'success_count': success_count,
                    'part_count': part_count,
                    'part_files': [str(pf) for pf in part_files] if part_files else []
                }
            else:
                return {'success': False, 'error': 'Xæ’­æ”¾åˆ—è¡¨ä¸‹è½½å®Œæˆä½†æœªæ‰¾åˆ°æœ¬æ¬¡ä¸‹è½½çš„æ–‡ä»¶'}

        except Exception as e:
            logger.error(f"âŒ Xæ’­æ”¾åˆ—è¡¨ä¸‹è½½å¤±è´¥: {e}")
            return {"success": False, "error": str(e)}
        finally:
            # è®°å½•ä¸‹è½½å®Œæˆæ—¶é—´
            download_end_time = time.time()
            total_time = download_end_time - download_start_time
            logger.info(f"â° ä¸‹è½½å®Œæˆæ—¶é—´: {download_end_time}, æ€»ç”¨æ—¶: {total_time:.1f}ç§’")

    async def _download_x_image_with_gallerydl(self, url: str, message: types.Message) -> dict:
        """ä½¿ç”¨ gallery-dl ä¸‹è½½ X å›¾ç‰‡ï¼Œé‡åˆ°NSFWé”™è¯¯æ—¶fallbackåˆ°yt-dlp"""
        try:
            # åˆ›å»º message_updater å‡½æ•°
            async def message_updater(text_or_dict):
                try:
                    if isinstance(text_or_dict, dict):
                        await message.reply(str(text_or_dict))
                    else:
                        await message.reply(text_or_dict)
                except Exception as e:
                    logger.warning(f"âš ï¸ æ›´æ–°è¿›åº¦æ¶ˆæ¯å¤±è´¥: {e}")

            # ä½¿ç”¨ç°æœ‰çš„ download_with_gallery_dl å‡½æ•°ï¼Œä¼ é€’ message_updater
            download_path = self.x_download_path
            result = await self.download_with_gallery_dl(url, download_path, message_updater)

            if result.get("success"):
                return {
                    "success": True,
                    "platform": "X",
                    "content_type": "image",
                    "download_path": result.get("download_path", ""),
                    "full_path": result.get("full_path", ""),
                    "filename": result.get("filename", ""),
                    "size_mb": result.get("size_mb", 0),
                    "title": f"Xå›¾ç‰‡ ({result.get('files_count', 0)}å¼ )",
                    "resolution": "å›¾ç‰‡",  # æ·»åŠ  resolution å­—æ®µï¼Œç¡®ä¿è¯†åˆ«ä¸ºå›¾ç‰‡
                    "files_count": result.get("files_count", 0),
                    "file_formats": result.get("file_formats", []),
                }
            else:
                # æ£€æŸ¥æ˜¯å¦ä¸ºNSFWé”™è¯¯ï¼Œå¦‚æœæ˜¯åˆ™è¿”å›é”™è¯¯ä¿¡æ¯
                error_msg = result.get("error", "")
                if "NSFW" in error_msg or "AuthorizationError" in error_msg:
                    logger.info("ğŸ”„ æ£€æµ‹åˆ°NSFWé”™è¯¯ï¼Œgallery-dlæ— æ³•ä¸‹è½½æ­¤å†…å®¹")
                    return {
                        "success": False,
                        "error": "æ­¤å†…å®¹åŒ…å«NSFWå†…å®¹ï¼Œæ— æ³•ä¸‹è½½",
                        "platform": "X",
                        "content_type": "image"
                    }
                else:
                    return result

        except Exception as e:
            logger.error(f"âŒ gallery-dl ä¸‹è½½ X å›¾ç‰‡å¤±è´¥: {e}")
            return {
                "success": False,
                "error": f"gallery-dl ä¸‹è½½å¤±è´¥: {str(e)}",
                "platform": "X",
                "content_type": "image"
            }



    async def _download_xiaohongshu_image_with_downloader(self, url: str, message_updater=None) -> dict:
        """ä½¿ç”¨ xiaohongshu_downloader.py ä¸‹è½½å°çº¢ä¹¦å›¾ç‰‡"""
        try:
            # å¯¼å…¥å°çº¢ä¹¦ä¸‹è½½å™¨
            from xiaohongshu_downloader import XiaohongshuDownloader
            
            # åˆ›å»ºä¸‹è½½å™¨å®ä¾‹
            downloader = XiaohongshuDownloader()
            
            # å°çº¢ä¹¦å›¾ç‰‡ä¸‹è½½ç›®å½•
            download_dir = str(self.xiaohongshu_download_path)
            os.makedirs(download_dir, exist_ok=True)
            
            logger.info(f"ğŸ–¼ï¸ ä½¿ç”¨ xiaohongshu_downloader ä¸‹è½½å°çº¢ä¹¦å›¾ç‰‡: {url}")
            
            # åˆ›å»ºè¿›åº¦å›è°ƒå‡½æ•°
            async def progress_callback(text):
                if message_updater:
                    try:
                        logger.info(f"ğŸ“± å°çº¢ä¹¦è¿›åº¦å›è°ƒæ”¶åˆ°æ¶ˆæ¯: {text}")
                        
                        # æ£€æŸ¥æ¶ˆæ¯ç±»å‹ï¼ŒåŒºåˆ†å¼€å§‹ä¸‹è½½ã€è¿›åº¦æ›´æ–°å’Œå®Œæˆæ¶ˆæ¯
                        if "ğŸš€ å¼€å§‹ä¸‹è½½" in text:
                            logger.info("ğŸš€ æ£€æµ‹åˆ°å¼€å§‹ä¸‹è½½æ¶ˆæ¯")
                        elif "âš¡ é€Ÿåº¦: `å®Œæˆ`" in text:
                            logger.info("âœ… æ£€æµ‹åˆ°ä¸‹è½½å®Œæˆæ¶ˆæ¯")
                        elif "ğŸ“Š è¿›åº¦:" in text:
                            logger.info("ğŸ“Š æ£€æµ‹åˆ°è¿›åº¦æ›´æ–°æ¶ˆæ¯")
                        
                        # ç§»é™¤è·³è¿‡å®Œæˆæ¶ˆæ¯çš„é€»è¾‘ï¼Œè®©xiaohongshu_downloaderçš„å®Œæˆæ¶ˆæ¯æ­£å¸¸æ˜¾ç¤º
                        
                        # æ£€æŸ¥æ˜¯å¦ä¸ºå¼‚æ­¥å‡½æ•°
                        if asyncio.iscoroutinefunction(message_updater):
                            # å¼‚æ­¥å‡½æ•°ï¼Œç›´æ¥awaitè°ƒç”¨
                            await message_updater(text)
                        else:
                            # åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                            message_updater(text)
                    except Exception as e:
                        logger.warning(f"âš ï¸ è¿›åº¦å›è°ƒå¤±è´¥: {e}")
                        import traceback
                        logger.warning(f"âš ï¸ å¼‚å¸¸å †æ ˆ: {traceback.format_exc()}")
            
            # è°ƒç”¨ä¸‹è½½å™¨
            result = downloader.download_note(url, download_dir, progress_callback)
            
            if result.get("success"):
                logger.info(f"âœ… å°çº¢ä¹¦å›¾ç‰‡ä¸‹è½½æˆåŠŸ: {result}")
                # ä»filesä¸­æå–æ–‡ä»¶æ ¼å¼
                files = result.get("files", [])
                file_formats = set()
                for file_info in files:
                    file_path = file_info.get('path', '')
                    if file_path:
                        ext = os.path.splitext(file_path)[1].lower().lstrip('.')
                        if ext:
                            file_formats.add(ext.upper())
                file_formats = list(file_formats)
                
                return {
                    "success": True,
                    "title": result.get("title", "å°çº¢ä¹¦å›¾ç‰‡"),
                    "author": result.get("author", "æœªçŸ¥ä½œè€…"),
                    "files_count": len(result.get("files", [])),
                    "total_size_mb": result.get("total_size", 0) / (1024 * 1024),
                    "download_path": result.get("save_dir", download_dir),
                    "files": result.get("files", []),
                    "file_formats": file_formats,
                    "platform": "Xiaohongshu",
                    "content_type": "image"
                }
            else:
                logger.error(f"âŒ å°çº¢ä¹¦å›¾ç‰‡ä¸‹è½½å¤±è´¥: {result.get('error')}")
                return {
                    "success": False,
                    "error": result.get("error", "æœªçŸ¥é”™è¯¯"),
                    "platform": "Xiaohongshu",
                    "content_type": "image"
                }
                
        except Exception as e:
            logger.error(f"âŒ ä¸‹è½½å°çº¢ä¹¦å›¾ç‰‡å¤±è´¥: {e}")
            return {
                "success": False,
                "error": f"ä¸‹è½½å°çº¢ä¹¦å›¾ç‰‡å¤±è´¥: {str(e)}",
                "platform": "Xiaohongshu",
                "content_type": "image"
            }

    async def _download_xiaohongshu_with_playwright(self, url: str, message: types.Message, message_updater=None) -> dict:
        """ä½¿ç”¨ Playwright ä¸‹è½½å°çº¢ä¹¦è§†é¢‘"""
        # è‡ªåŠ¨æå–å°çº¢ä¹¦é“¾æ¥
        real_url = extract_xiaohongshu_url(url)
        if real_url:
            url = real_url
        else:
            logger.warning('æœªæ£€æµ‹åˆ°å°çº¢ä¹¦é“¾æ¥ï¼ŒåŸæ ·ä½¿ç”¨å‚æ•°')
        if not PLAYWRIGHT_AVAILABLE:
            return {
                "success": False,
                "error": "Playwright æœªå®‰è£…ï¼Œæ— æ³•ä¸‹è½½å°çº¢ä¹¦è§†é¢‘",
                "platform": "Xiaohongshu",
                "content_type": "video"
            }

        try:
            from playwright.async_api import async_playwright
            import httpx
            from dataclasses import dataclass
            from typing import Optional
            from enum import Enum
            import re
            import time

            # æ•°æ®ç±»å®šä¹‰
            @dataclass
            class VideoInfo:
                video_id: str
                platform: str
                share_url: str
                download_url: Optional[str] = None
                title: Optional[str] = None
                author: Optional[str] = None
                create_time: Optional[str] = None
                quality: Optional[str] = None
                thumbnail_url: Optional[str] = None

            # ä½¿ç”¨ç±»çº§åˆ«çš„ Platform æšä¸¾

            # æ£€æµ‹å¹³å°
            def detect_platform(url: str) -> VideoDownloader.Platform:
                if any(domain in url.lower() for domain in ['douyin.com', 'iesdouyin.com']):
                    return VideoDownloader.Platform.DOUYIN
                elif any(domain in url.lower() for domain in ['kuaishou.com']):
                    return VideoDownloader.Platform.KUAISHOU
                elif any(domain in url.lower() for domain in ['xiaohongshu.com', 'xhslink.com']):
                    return VideoDownloader.Platform.XIAOHONGSHU
                else:
                    return VideoDownloader.Platform.UNKNOWN

            platform = VideoDownloader.Platform.XIAOHONGSHU

            # å‘é€å¼€å§‹ä¸‹è½½æ¶ˆæ¯ï¼ˆå¦‚æœbotå¯ç”¨ï¼‰
            start_message = None
            if hasattr(self, 'bot') and self.bot:
                try:
                    start_message = await self.bot.send_message(
                        message.chat.id,
                        f"ğŸ¬ å¼€å§‹ä¸‹è½½{platform.value}è§†é¢‘..."
                    )
                except Exception as e:
                    logger.warning(f"âš ï¸ å‘é€å¼€å§‹æ¶ˆæ¯å¤±è´¥: {e}")
            else:
                logger.info(f"ğŸ¬ å¼€å§‹ä¸‹è½½{platform.value}è§†é¢‘...")

            # å°çº¢ä¹¦ä¸‹è½½ç›®å½•
            download_dir = str(self.xiaohongshu_download_path)

            os.makedirs(download_dir, exist_ok=True)

            # ä½¿ç”¨ Playwright æå–è§†é¢‘ä¿¡æ¯
            async with async_playwright() as p:
                # å°çº¢ä¹¦ä¸éœ€è¦ cookies

                # å°çº¢ä¹¦æµè§ˆå™¨é…ç½® - å‚è€ƒdouyin.py
                browser = await p.chromium.launch(headless=True)
                context = await browser.new_context(
                    user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
                    viewport={'width': 1920, 'height': 1080},
                    device_scale_factor=1,
                    locale='zh-CN',
                    timezone_id='Asia/Shanghai',
                    is_mobile=False,
                    has_touch=False,
                    color_scheme='light',
                    extra_http_headers={
                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,video/mp4,*/*;q=0.8',
                        'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
                        'Connection': 'keep-alive',
                        'Upgrade-Insecure-Requests': '1',
                    }
                )

                # å°çº¢ä¹¦ä¸éœ€è¦ cookies

                page = await context.new_page()

                # è®¾ç½®å¹³å°ç‰¹å®šçš„è¯·æ±‚å¤´
                await self._set_platform_headers(page, platform)

                # ç›‘å¬ç½‘ç»œè¯·æ±‚ï¼Œæ•è·å°çº¢ä¹¦è§†é¢‘URL
                video_url_holder = {'url': None}
                def handle_request(request):
                    req_url = request.url
                    if any(ext in req_url.lower() for ext in ['.mp4', '.m3u8']):
                        if 'xhscdn.com' in req_url or 'xiaohongshu.com' in req_url:
                            # åªä¿å­˜ç¬¬ä¸€ä¸ªæ•è·åˆ°çš„è§†é¢‘URLï¼Œé¿å…è¢«åç»­è¯·æ±‚è¦†ç›–
                            if not video_url_holder['url']:
                                video_url_holder['url'] = req_url
                                logger.info(f"[cat-catch] å—…æ¢åˆ°å°çº¢ä¹¦è§†é¢‘æµ: {req_url}")
                page.on("request", handle_request)

                # è®¿é—®é¡µé¢ - å‚è€ƒdouyin.pyçš„å®ç°
                logger.info("[extract] goto å‰")
                await page.goto(url, wait_until="domcontentloaded", timeout=30000)
                logger.info("[extract] goto åï¼Œå¼€å§‹æé€Ÿå—…æ¢")

                # æé€Ÿå—…æ¢ï¼šåªç›‘å¬networkï¼Œä¸åšä»»ä½•äº¤äº’ - å‚è€ƒdouyin.py
                for _ in range(5):  # 1.5ç§’å†…ç›‘å¬
                    if video_url_holder['url']:
                        logger.info(f"[cat-catch][fast] æé€Ÿå—…æ¢åˆ°å°çº¢ä¹¦è§†é¢‘æµ: {video_url_holder['url']}")
                        # ç«‹å³è·å–æ ‡é¢˜å’Œä½œè€…ï¼Œå‚è€ƒdouyin.py
                        title = await self._get_video_title(page, platform)
                        author = await self._get_video_author(page, platform)
                        # ç›´æ¥è¿”å›ç»“æœï¼Œä¸ç»§ç»­åç»­é€»è¾‘
                        video_info = VideoInfo(
                            video_id=str(int(time.time())),
                            platform=platform.value,
                            share_url=url,
                            download_url=video_url_holder['url'],
                            title=title,
                            author=author)
                        logger.info("[cat-catch][fast] æé€Ÿå—…æ¢æµç¨‹å®Œæˆ")
                        # å…³é—­æµè§ˆå™¨
                        await page.close()
                        await context.close()
                        await browser.close()

                        # ä¸‹è½½è§†é¢‘
                        return await self._download_video_file(video_info, download_dir, message_updater, start_message)
                    await asyncio.sleep(0.3)
                # å…œåº•ï¼šæœªæ•è·åˆ°æµï¼Œç›´æ¥è¿›å…¥æ­£åˆ™/å…¶å®ƒé€»è¾‘ï¼ˆä¸å†åšè‡ªåŠ¨äº¤äº’ï¼‰

                # æ£€æŸ¥æ˜¯å¦æ•è·åˆ°è§†é¢‘URL
                if not video_url_holder['url']:
                    logger.warning(f"âš ï¸ ç½‘ç»œå—…æ¢æœªæ•è·åˆ°å°çº¢ä¹¦è§†é¢‘æµ")
                else:
                    logger.info(f"âœ… ç½‘ç»œå—…æ¢æˆåŠŸæ•è·åˆ°å°çº¢ä¹¦è§†é¢‘æµ: {video_url_holder['url']}")

                # å¦‚æœç½‘ç»œå—…æ¢å¤±è´¥ï¼Œå°è¯•ä»é¡µé¢æå–
                if not video_url_holder['url']:
                    html = await page.content()
                    logger.info(f"ğŸ” å¼€å§‹ä»HTMLæå–å°çº¢ä¹¦è§†é¢‘ç›´é“¾...")

                    # å°çº¢ä¹¦HTMLæ­£åˆ™æå– - å‚è€ƒdouyin.pyçš„ç®€åŒ–æ¨¡å¼
                    patterns = [
                        r'(https://sns-[^"\']+\.xhscdn\.com/stream/[^"\']+\.mp4)',
                        r'(https://ci[^"\']+\.xhscdn\.com/[^"\']+\.mp4)',
                        r'(https://[^"\']+\.xhscdn\.com/[^"\']+\.mp4)',
                        r'"videoUrl":"(https://[^"\\]+)"',
                        r'"video_url":"(https://[^"\\]+)"',
                        r'"url":"(https://[^"\\]+\.mp4)"'
                    ]

                    # ç›´æ¥ä½¿ç”¨HTMLæ­£åˆ™æå– - å‚è€ƒdouyin.pyçš„ç®€å•æ–¹æ³•
                    for i, pattern in enumerate(patterns):
                        m = re.search(pattern, html)
                        if m:
                            url = m.group(1).replace('\\u002F', '/').replace('\\u0026', '&')
                            # éªŒè¯URLæ˜¯å¦æœ‰æ•ˆï¼Œå¹¶ä¸”ç½‘ç»œå—…æ¢æ²¡æœ‰æ•è·åˆ°URLæ—¶æ‰ä½¿ç”¨
                            if self._is_valid_xiaohongshu_url(url) and not video_url_holder['url']:
                                video_url_holder['url'] = url
                                logger.info(f"âœ… ä½¿ç”¨æ¨¡å¼{i+1}æå–åˆ°å°çº¢ä¹¦è§†é¢‘URL: {url}")
                                break
                            elif self._is_valid_xiaohongshu_url(url) and video_url_holder['url']:
                                logger.info(f"âš ï¸ ç½‘ç»œå—…æ¢å·²æ•è·åˆ°URLï¼Œè·³è¿‡HTMLæå–çš„URL: {url}")
                                break

                # å¦‚æœHTMLæå–æˆåŠŸï¼Œè·å–æ ‡é¢˜å’Œä½œè€…
                title = None
                author = None
                if video_url_holder['url']:
                    try:
                        title = await self._get_video_title(page, platform)
                        author = await self._get_video_author(page, platform)
                        logger.info(f"ğŸ“ è·å–åˆ°æ ‡é¢˜: {title}")
                        logger.info(f"ğŸ‘¤ è·å–åˆ°ä½œè€…: {author}")
                    except Exception as e:
                        logger.warning(f"âš ï¸ è·å–æ ‡é¢˜å’Œä½œè€…å¤±è´¥: {e}")

                # å…³é—­æµè§ˆå™¨
                await page.close()
                await context.close()
                await browser.close()

                if not video_url_holder['url']:
                    # å¦‚æœä»ç„¶æ²¡æœ‰è·å–åˆ°è§†é¢‘URLï¼Œä¿å­˜è°ƒè¯•ä¿¡æ¯
                    debug_html_path = f"/tmp/xiaohongshu_debug_{int(time.time())}.html"
                    try:
                        with open(debug_html_path, 'w', encoding='utf-8') as f:
                            f.write(html)
                        logger.error(f"âŒ æ— æ³•æå–å°çº¢ä¹¦è§†é¢‘ç›´é“¾ï¼Œå·²ä¿å­˜è°ƒè¯•HTMLåˆ°: {debug_html_path}")
                    except Exception as e:
                        logger.error(f"âŒ æ— æ³•æå–å°çº¢ä¹¦è§†é¢‘ç›´é“¾ï¼Œä¿å­˜è°ƒè¯•æ–‡ä»¶å¤±è´¥: {e}")

                    raise Exception(f"æ— æ³•æå–å°çº¢ä¹¦è§†é¢‘ç›´é“¾ï¼Œè¯·æ£€æŸ¥é“¾æ¥æœ‰æ•ˆæ€§")

                # åˆ›å»ºVideoInfoå¯¹è±¡
                video_info = VideoInfo(
                    video_id=str(int(time.time())),
                    platform=platform.value,
                    share_url=url,
                    download_url=video_url_holder['url'],
                    title=title,
                    author=author)

                # ä½¿ç”¨ç»Ÿä¸€çš„ä¸‹è½½æ–¹æ³•
                result = await self._download_video_file(video_info, download_dir, message_updater, start_message)

                if not result.get("success"):
                    raise Exception(result.get("error", "ä¸‹è½½å¤±è´¥"))

                # åˆ é™¤å¼€å§‹æ¶ˆæ¯ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if start_message and hasattr(self, 'bot') and self.bot:
                    try:
                        await start_message.delete()
                    except Exception as e:
                        logger.warning(f"âš ï¸ åˆ é™¤å¼€å§‹æ¶ˆæ¯å¤±è´¥: {e}")

                # æ–‡ä»¶ä¿¡æ¯ç°åœ¨åœ¨ _download_video_file æ–¹æ³•ä¸­å¤„ç†
                logger.info(f"âœ… {platform.value}è§†é¢‘ä¸‹è½½æˆåŠŸ")

                # è¿”å›ä¸‹è½½ç»“æœ
                return result

        except Exception as e:
            error_msg = str(e)
            logger.error(f"âŒ Playwright ä¸‹è½½å°çº¢ä¹¦è§†é¢‘å¤±è´¥: {error_msg}")

            # åˆ é™¤å¼€å§‹æ¶ˆæ¯ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if 'start_message' in locals() and start_message and hasattr(self, 'bot') and self.bot:
                try:
                    await self.bot.delete_message(message.chat.id, start_message.message_id)
                except Exception as del_e:
                    logger.warning(f"âš ï¸ åˆ é™¤å¼€å§‹æ¶ˆæ¯å¤±è´¥: {del_e}")

            return {
                "success": False,
                "error": f"Playwright ä¸‹è½½å¤±è´¥: {error_msg}",
                "platform": "Xiaohongshu",
                "content_type": "video"
            }

    async def _extract_douyin_url_from_html(self, html: str) -> Optional[str]:
        """ä»æŠ–éŸ³HTMLæºç ä¸­æå–è§†é¢‘ç›´é“¾ - ä½¿ç”¨ç®€å•æœ‰æ•ˆçš„é€»è¾‘"""
        try:
            logger.info(f"[extract] HTMLé•¿åº¦: {len(html)} å­—ç¬¦")

            # æŸ¥æ‰¾åŒ…å«è§†é¢‘æ•°æ®çš„scriptæ ‡ç­¾
            script_matches = re.findall(r'<script[^>]*>(.*?)</script>', html, re.DOTALL)

            for script_content in script_matches:
                if 'aweme_id' in script_content and 'status_code' in script_content:
                    # å°è¯•æå–JSONéƒ¨åˆ†
                    json_matches = re.findall(r'({.*?"errors":\s*null\s*})', script_content, re.DOTALL)
                    for json_str in json_matches:
                        try:
                            # æ¸…ç†JSON
                            brace_count = 0
                            json_end = -1
                            for i, char in enumerate(json_str):
                                if char == '{':
                                    brace_count += 1
                                elif char == '}':
                                    brace_count -= 1
                                    if brace_count == 0:
                                        json_end = i + 1
                                        break

                            if json_end > 0:
                                clean_json = json_str[:json_end]
                                data = json.loads(clean_json)

                                # ä¸“é—¨æŸ¥æ‰¾videoå­—æ®µä¸­çš„æ— æ°´å°è§†é¢‘URL
                                def find_video_url(obj):
                                    if isinstance(obj, dict):
                                        for key, value in obj.items():
                                            # ä¸“é—¨æŸ¥æ‰¾videoå­—æ®µ
                                            if key == "video" and isinstance(value, dict):
                                                logger.info(f"[extract] æ‰¾åˆ°videoå­—æ®µ: {list(value.keys())}")

                                                # ä¼˜å…ˆæŸ¥æ‰¾play_urlå­—æ®µï¼ˆæ— æ°´å°ï¼‰
                                                if "play_url" in value:
                                                    play_url = value["play_url"]
                                                    logger.info(f"[extract] play_urlå­—æ®µå†…å®¹: {play_url}")
                                                    logger.info(f"[extract] play_urlç±»å‹: {type(play_url)}")
                                                    # å¤„ç†play_urlå­—å…¸æ ¼å¼
                                                    if isinstance(play_url, dict) and "url_list" in play_url:
                                                        url_list = play_url["url_list"]
                                                        if isinstance(url_list, list) and url_list:
                                                            video_url = url_list[0]
                                                            if video_url.startswith("http"):
                                                                logger.info(f"[extract] ä»play_url.url_listæ‰¾åˆ°æ— æ°´å°è§†é¢‘URL: {video_url}")
                                                                return video_url
                                                    # å¤„ç†play_urlå­—ç¬¦ä¸²æ ¼å¼
                                                    elif isinstance(play_url, str) and play_url.startswith("http"):
                                                        if any(ext in play_url.lower() for ext in [".mp4", ".m3u8", ".ts", "douyinvod.com", "snssdk.com"]):
                                                            logger.info(f"[extract] æ‰¾åˆ°æ— æ°´å°è§†é¢‘URL: {play_url}")
                                                            return play_url

                                                # å…œåº•ï¼šå¦‚æœæ²¡æœ‰play_urlï¼Œå†æŸ¥æ‰¾play_addrå­—æ®µï¼ˆæœ‰æ°´å°ï¼‰
                                                if "play_addr" in value:
                                                    play_addr = value["play_addr"]
                                                    logger.info(f"[extract] play_addrå­—æ®µå†…å®¹: {play_addr}")
                                                    logger.info(f"[extract] play_addrç±»å‹: {type(play_addr)}")
                                                    # å¤„ç†play_addrå­—å…¸æ ¼å¼
                                                    if isinstance(play_addr, dict) and "url_list" in play_addr:
                                                        url_list = play_addr["url_list"]
                                                        if isinstance(url_list, list) and url_list:
                                                            video_url = url_list[0]
                                                            if video_url.startswith("http"):
                                                                logger.info(f"[extract] ä»play_addr.url_listæ‰¾åˆ°æœ‰æ°´å°è§†é¢‘URL: {video_url}")
                                                                return video_url
                                                    # æŸ¥æ‰¾playAddr
                                                    if isinstance(play_addr, list) and play_addr:
                                                        video_url = play_addr[0]
                                                        if video_url.startswith("http") and any(ext in video_url.lower() for ext in [".mp4", ".m3u8", ".ts", "douyinvod.com", "snssdk.com"]):
                                                            logger.info(f"[extract] æ‰¾åˆ°æœ‰æ°´å°è§†é¢‘URL: {video_url}")
                                                            return video_url
                                                    elif isinstance(play_addr, str) and play_addr.startswith("http"):
                                                        if any(ext in play_addr.lower() for ext in [".mp4", ".m3u8", ".ts", "douyinvod.com", "snssdk.com"]):
                                                            logger.info(f"[extract] æ‰¾åˆ°æœ‰æ°´å°è§†é¢‘URL: {play_addr}")
                                                            return play_addr
                                            elif isinstance(value, (dict, list)):
                                                result = find_video_url(value)
                                                if result:
                                                    return result
                                    elif isinstance(obj, list):
                                        for item in obj:
                                            result = find_video_url(item)
                                            if result:
                                                return result
                                    return None

                                video_url = find_video_url(data)
                                if video_url:
                                    return video_url

                        except json.JSONDecodeError:
                            continue

            return None

        except Exception as e:
            logger.warning(f"æŠ–éŸ³HTMLæ­£åˆ™æå–å¤±è´¥: {str(e)}")
        return None

    async def _get_douyin_no_watermark_url(self, video_id: str) -> str:
        """é€šè¿‡æŠ–éŸ³å®˜æ–¹æ¥å£è·å–æ— æ°´å°è§†é¢‘ç›´é“¾"""
        try:
            # æŠ–éŸ³å®˜æ–¹APIåˆ—è¡¨
            apis = [
                f'https://aweme.snssdk.com/aweme/v1/play/?video_id={video_id}&ratio=1080p&line=1',
                f'https://aweme.snssdk.com/aweme/v1/play/?video_id={video_id}&ratio=720p&line=0',
                f'https://aweme.snssdk.com/aweme/v1/play/?video_id={video_id}&ratio=540p&line=2',
                f'https://aweme.snssdk.com/aweme/v1/play/?video_id={video_id}&ratio=1080p&line=0',
                f'https://aweme.snssdk.com/aweme/v1/play/?video_id={video_id}&ratio=720p&line=1',
            ]

            headers = {
                'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1',
                'Accept': '*/*',
                'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
                'Referer': 'https://www.douyin.com/',
                'Connection': 'keep-alive',
                'Range': 'bytes=0-1',  # åªè¯·æ±‚å¼€å¤´1ä¸ªå­—èŠ‚ï¼ŒéªŒè¯å¯è®¿é—®æ€§
            }

            async def validate_url(api_url: str) -> Optional[str]:
                """éªŒè¯å•ä¸ªAPI URLçš„å¯ç”¨æ€§ï¼Œæ£€æŸ¥content-length"""
                try:
                    async with httpx.AsyncClient(follow_redirects=True, timeout=5.0) as client:
                        # å…ˆç”¨ HEAD è¯·æ±‚å¿«é€ŸéªŒè¯
                        try:
                            head_resp = await client.head(
                                api_url,
                                headers=headers,
                                timeout=3.0
                            )
                            if head_resp.status_code in [200, 206]:
                                # æ£€æŸ¥content-lengthï¼Œå¦‚æœä¸º0åˆ™è®¤ä¸ºAPIå¤±æ•ˆ
                                content_length = int(head_resp.headers.get("content-length", 0))
                                if content_length > 0:
                                    logger.info(f"[douyin_api] HEADè¯·æ±‚æˆåŠŸ: {api_url} (å¤§å°: {content_length})")
                                    return api_url
                                else:
                                    logger.warning(f"[douyin_api] HEADè¯·æ±‚æˆåŠŸä½†content-lengthä¸º0: {api_url}")
                                    return None
                        except Exception:
                            pass  # HEAD å¤±è´¥å°±ç”¨ GET è¯•è¯•

                        # HEAD å¤±è´¥çš„è¯ç”¨ GET è¯·æ±‚é‡è¯•
                        resp = await client.get(
                            api_url,
                            headers=headers,
                            timeout=3.0
                        )
                        if resp.status_code in [200, 206]:
                            content_length = int(resp.headers.get("content-length", 0))
                            if content_length > 0:
                                logger.info(f"[douyin_api] GETè¯·æ±‚æˆåŠŸ: {api_url} (å¤§å°: {content_length})")
                                return api_url
                            else:
                                logger.warning(f"[douyin_api] GETè¯·æ±‚æˆåŠŸä½†content-lengthä¸º0: {api_url}")
                                return None

                except Exception as e:
                    logger.warning(f"[douyin_api] éªŒè¯å¤±è´¥: {api_url} - {str(e)}")
                return None

            # æœ€å¤šé‡è¯•2æ¬¡
            for attempt in range(2):
                try:
                    logger.info(f"[douyin_api] ç¬¬{attempt + 1}æ¬¡å°è¯•éªŒè¯API")
                    # å¹¶å‘éªŒè¯æ‰€æœ‰API
                    tasks = [validate_url(api) for api in apis]
                    results = await asyncio.gather(*tasks)

                    # è¿”å›ç¬¬ä¸€ä¸ªå¯ç”¨çš„URL
                    for url in results:
                        if url:
                            logger.info(f"[douyin_api] æ‰¾åˆ°å¯ç”¨API: {url}")
                            return url

                    logger.warning(f"[douyin_api] ç¬¬{attempt + 1}æ¬¡å°è¯•æ‰€æœ‰APIéƒ½è¿”å›0å­—èŠ‚")
                    if attempt < 1:  # å¦‚æœä¸æ˜¯æœ€åä¸€æ¬¡é‡è¯•
                        await asyncio.sleep(1)  # ç­‰å¾…1ç§’åé‡è¯•

                except Exception as e:
                    logger.error(f"[douyin_api] ç¬¬{attempt + 1}æ¬¡å°è¯•å‘ç”Ÿé”™è¯¯: {str(e)}")
                    if attempt < 1:
                        await asyncio.sleep(1)

            logger.warning("[douyin_api] æ‰€æœ‰APIéƒ½è¿”å›0å­—èŠ‚ï¼ŒAPIå¯èƒ½å·²å¤±æ•ˆ")
            return None

        except Exception as e:
            logger.error(f"[douyin_api] è·å–æ— æ°´å°ç›´é“¾å¼‚å¸¸: {str(e)}")
            return None

    async def _get_video_title(self, page, platform: 'VideoDownloader.Platform') -> str:
        """è·å–è§†é¢‘æ ‡é¢˜ - é’ˆå¯¹ä¸åŒå¹³å°ä¼˜åŒ–"""
        try:
            # å¿«æ‰‹ç‰¹æ®Šå¤„ç†
            if platform == VideoDownloader.Platform.KUAISHOU:
                return await self._get_kuaishou_video_title(page)

            # å…¶ä»–å¹³å°ä½¿ç”¨é€šç”¨æ–¹æ³•
            page_title = await page.title()
            if page_title and page_title.strip():
                logger.info(f"ğŸ“ é€šè¿‡<title>æ ‡ç­¾è·å–æ ‡é¢˜æˆåŠŸ")
                logger.info(f"ğŸ“ åŸå§‹<title> repr: {repr(page_title)}")
                clean_title = page_title.strip()
                return re.sub(r'[<>:"/\\|?*]', '_', clean_title)[:100]
        except Exception as e:
            logger.warning(f"è·å–æ ‡é¢˜å¤±è´¥: {str(e)}")
        return None

    async def _get_kuaishou_video_title(self, page) -> str:
        """ä¸“é—¨è·å–å¿«æ‰‹è§†é¢‘æ ‡é¢˜"""
        try:
            # æ–¹æ³•1: å°è¯•ä»é¡µé¢çš„JSONæ•°æ®ä¸­æå–æ ‡é¢˜
            html = await page.content()

            # æŸ¥æ‰¾åŒ…å«è§†é¢‘ä¿¡æ¯çš„scriptæ ‡ç­¾
            script_matches = re.findall(r'<script[^>]*>(.*?)</script>', html, re.DOTALL)
            for script_content in script_matches:
                if 'caption' in script_content or 'title' in script_content:
                    # å°è¯•æå–JSONä¸­çš„æ ‡é¢˜å­—æ®µ
                    title_patterns = [
                        r'"caption":"([^"]+)"',
                        r'"title":"([^"]+)"',
                        r'"content":"([^"]+)"',
                        r'"text":"([^"]+)"',
                        r'"description":"([^"]+)"'
                    ]

                    for pattern in title_patterns:
                        matches = re.findall(pattern, script_content)
                        for match in matches:
                            # æ¸…ç†å’ŒéªŒè¯æ ‡é¢˜
                            title = match.replace('\\u002F', '/').replace('\\u0026', '&').replace('\\n', ' ').replace('\\', '')
                            title = title.strip()
                            # è¿‡æ»¤æ‰æ˜æ˜¾ä¸æ˜¯æ ‡é¢˜çš„å†…å®¹
                            if (len(title) > 5 and len(title) < 200 and
                                not title.startswith('http') and
                                not all(c.isdigit() or c in '.-_' for c in title) and
                                'å¿«æ‰‹' not in title and 'kuaishou' not in title.lower()):
                                logger.info(f"ğŸ“ ä»JSONæå–åˆ°å¿«æ‰‹æ ‡é¢˜: {title}")
                                return re.sub(r'[<>:"/\\|?*]', '_', title)[:100]

            # æ–¹æ³•2: å°è¯•ä»é¡µé¢å…ƒç´ ä¸­æå–æ ‡é¢˜
            title_selectors = [
                '.video-info-title',
                '.content-text',
                '.video-title',
                '.caption',
                '[data-testid="video-title"]',
                '.description',
                'h1', 'h2', 'h3'
            ]

            for selector in title_selectors:
                try:
                    elements = await page.query_selector_all(selector)
                    for element in elements:
                        text = await element.text_content()
                        if text and len(text.strip()) > 5 and len(text.strip()) < 200:
                            title = text.strip()
                            if (not title.startswith('http') and
                                not all(c.isdigit() or c in '.-_' for c in title)):
                                logger.info(f"ğŸ“ ä»å…ƒç´ {selector}æå–åˆ°å¿«æ‰‹æ ‡é¢˜: {title}")
                                return re.sub(r'[<>:"/\\|?*]', '_', title)[:100]
                except:
                    continue

            # æ–¹æ³•3: ä»é¡µé¢titleä¸­æå–ï¼Œå»é™¤å¿«æ‰‹ç›¸å…³åç¼€
            page_title = await page.title()
            if page_title and page_title.strip():
                title = page_title.strip()
                # å»é™¤å¿«æ‰‹ç›¸å…³çš„åç¼€
                title = re.sub(r'[-_\s]*å¿«æ‰‹[-_\s]*', '', title)
                title = re.sub(r'[-_\s]*kuaishou[-_\s]*', '', title, flags=re.IGNORECASE)
                title = re.sub(r'[-_\s]*çŸ­è§†é¢‘[-_\s]*', '', title)
                title = title.strip()
                if len(title) > 3:
                    logger.info(f"ğŸ“ ä»é¡µé¢titleæå–å¿«æ‰‹æ ‡é¢˜: {title}")
                    return re.sub(r'[<>:"/\\|?*]', '_', title)[:100]

            logger.warning("ğŸ“ æœªèƒ½æå–åˆ°å¿«æ‰‹è§†é¢‘æ ‡é¢˜")
            return None

        except Exception as e:
            logger.warning(f"è·å–å¿«æ‰‹æ ‡é¢˜å¤±è´¥: {str(e)}")
            return None

    async def _get_video_author(self, page, platform: 'VideoDownloader.Platform') -> str:
        """è·å–è§†é¢‘ä½œè€…"""
        try:
            # å¿«æ‰‹ç‰¹æ®Šå¤„ç†
            if platform == VideoDownloader.Platform.KUAISHOU:
                return await self._get_kuaishou_video_author(page)

            # å…¶ä»–å¹³å°ä½¿ç”¨é€šç”¨æ–¹æ³•
            selectors = {
                VideoDownloader.Platform.DOUYIN: '[data-e2e="user-name"]',
                VideoDownloader.Platform.XIAOHONGSHU: '.user-name, .author, .nickname, [data-e2e="user-name"], .user-info .name',
            }

            selector = selectors.get(platform, '.author, .username')
            author_element = await page.query_selector(selector)

            if author_element:
                return await author_element.text_content()
        except Exception as e:
            logger.warning(f"è·å–ä½œè€…å¤±è´¥: {str(e)}")
        return None

    async def _get_kuaishou_video_author(self, page) -> str:
        """ä¸“é—¨è·å–å¿«æ‰‹è§†é¢‘ä½œè€…"""
        try:
            # æ–¹æ³•1: ä»é¡µé¢çš„JSONæ•°æ®ä¸­æå–ä½œè€…
            html = await page.content()

            # æŸ¥æ‰¾åŒ…å«ç”¨æˆ·ä¿¡æ¯çš„scriptæ ‡ç­¾
            script_matches = re.findall(r'<script[^>]*>(.*?)</script>', html, re.DOTALL)
            for script_content in script_matches:
                if 'user' in script_content or 'author' in script_content:
                    # å°è¯•æå–JSONä¸­çš„ä½œè€…å­—æ®µ
                    author_patterns = [
                        r'"userName":"([^"]+)"',
                        r'"user_name":"([^"]+)"',
                        r'"nickname":"([^"]+)"',
                        r'"name":"([^"]+)"',
                        r'"author":"([^"]+)"',
                        r'"performer":"([^"]+)"'
                    ]

                    for pattern in author_patterns:
                        matches = re.findall(pattern, script_content)
                        for match in matches:
                            # æ¸…ç†å’ŒéªŒè¯ä½œè€…å
                            author = match.replace('\\u002F', '/').replace('\\u0026', '&').replace('\\', '')
                            author = author.strip()
                            # è¿‡æ»¤æ‰æ˜æ˜¾ä¸æ˜¯ä½œè€…åçš„å†…å®¹
                            if (len(author) > 1 and len(author) < 50 and
                                not author.startswith('http') and
                                not all(c.isdigit() or c in '.-_' for c in author) and
                                author not in ['null', 'undefined', 'true', 'false']):
                                logger.info(f"ğŸ‘¤ ä»JSONæå–åˆ°å¿«æ‰‹ä½œè€…: {author}")
                                return re.sub(r'[<>:"/\\|?*]', '_', author)[:30]

            # æ–¹æ³•2: ä»é¡µé¢å…ƒç´ ä¸­æå–ä½œè€…
            author_selectors = [
                '.user-name',
                '.author-name',
                '.nickname',
                '.username',
                '.user-info .name',
                '.profile-name',
                '[data-testid="user-name"]',
                '.creator-name'
            ]

            for selector in author_selectors:
                try:
                    elements = await page.query_selector_all(selector)
                    for element in elements:
                        text = await element.text_content()
                        if text and len(text.strip()) > 1 and len(text.strip()) < 50:
                            author = text.strip()
                            if (not author.startswith('http') and
                                not all(c.isdigit() or c in '.-_' for c in author)):
                                logger.info(f"ğŸ‘¤ ä»å…ƒç´ {selector}æå–åˆ°å¿«æ‰‹ä½œè€…: {author}")
                                return re.sub(r'[<>:"/\\|?*]', '_', author)[:30]
                except:
                    continue

            logger.warning("ğŸ‘¤ æœªèƒ½æå–åˆ°å¿«æ‰‹è§†é¢‘ä½œè€…")
            return None

        except Exception as e:
            logger.warning(f"è·å–å¿«æ‰‹ä½œè€…å¤±è´¥: {str(e)}")
            return None

    def _is_valid_xiaohongshu_url(self, url: str) -> bool:
        """éªŒè¯å°çº¢ä¹¦è§†é¢‘URLæ˜¯å¦æœ‰æ•ˆ"""
        if not url:
            return False

        url_lower = url.lower()

        # æ£€æŸ¥æ˜¯å¦æ˜¯è§†é¢‘æ–‡ä»¶
        if not any(ext in url_lower for ext in ['.mp4', '.m3u8', '.ts', '.flv', '.webm']):
            return False

        # æ£€æŸ¥æ˜¯å¦æ˜¯æ¥è‡ªå°çº¢ä¹¦çš„CDN
        if not any(cdn in url_lower for cdn in ['xhscdn.com', 'xiaohongshu.com']):
            return False

        # æ’é™¤ä¸€äº›æ— æ•ˆçš„URL
        if any(x in url_lower for x in ['static', 'avatar', 'icon', 'logo', 'banner']):
            return False

        return True

    async def _set_platform_headers(self, page, platform: 'VideoDownloader.Platform'):
        """è®¾ç½®å¹³å°ç‰¹å®šçš„è¯·æ±‚å¤´"""
        headers = {
            self.Platform.DOUYIN: {'Referer': 'https://www.douyin.com/'},
            self.Platform.KUAISHOU: {'Referer': 'https://www.kuaishou.com/'},
            self.Platform.XIAOHONGSHU: {'Referer': 'https://www.xiaohongshu.com/'},
        }

        if platform in headers:
            await page.set_extra_http_headers(headers[platform])
            logger.info(f"ğŸ¬ å·²è®¾ç½® {platform.value} å¹³å°è¯·æ±‚å¤´")

    async def _download_douyin_with_playwright(self, url: str, message: types.Message, message_updater=None) -> dict:
        """ä½¿ç”¨Playwrightä¸‹è½½æŠ–éŸ³è§†é¢‘ - å®Œå…¨å¤åˆ¶douyin.pyçš„extracté€»è¾‘"""
        if not PLAYWRIGHT_AVAILABLE:
            return {
                "success": False,
                "error": "Playwright æœªå®‰è£…ï¼Œæ— æ³•ä¸‹è½½æŠ–éŸ³è§†é¢‘",
                "platform": "Douyin",
                "content_type": "video"
            }

        try:
            from playwright.async_api import async_playwright
            import httpx
            from dataclasses import dataclass
            from typing import Optional
            import re
            import time

            @dataclass
            class VideoInfo:
                video_id: str
                platform: str
                share_url: str
                download_url: Optional[str] = None
                title: Optional[str] = None
                author: Optional[str] = None
                create_time: Optional[str] = None
                quality: Optional[str] = None
                thumbnail_url: Optional[str] = None

            class Platform(str, Enum):
                DOUYIN = "douyin"
                XIAOHONGSHU = "xiaohongshu"
                UNKNOWN = "unknown"

            logger.info(f"ğŸ¬ å¼€å§‹ä¸‹è½½æŠ–éŸ³è§†é¢‘: {url}")

            total_start = time.time()
            platform = Platform.DOUYIN

            async with async_playwright() as p:
                # æŒ‰ç…§douyin.pyå¯åŠ¨æµè§ˆå™¨ï¼ˆæ— ç‰¹æ®Šå‚æ•°ï¼‰
                browser = await p.chromium.launch(headless=True)

                # æŒ‰ç…§douyin.pyçš„contexté…ç½®ï¼ˆæŠ–éŸ³ç”¨æ‰‹æœºç‰ˆï¼‰
                context = await browser.new_context(
                    user_agent='Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1',
                    viewport={'width': 375, 'height': 667},
                    device_scale_factor=2,
                    locale='zh-CN',
                    timezone_id='Asia/Shanghai',
                    is_mobile=True,
                    has_touch=True,
                    color_scheme='light',
                    extra_http_headers={
                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,video/mp4,*/*;q=0.8',
                        'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
                        'Connection': 'keep-alive',
                        'Upgrade-Insecure-Requests': '1',
                    }
                )

                page = await context.new_page()

                # å°è¯•åŠ è½½cookiesï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if self.douyin_cookies_path and os.path.exists(self.douyin_cookies_path):
                    try:
                        cookies_dict = self._parse_douyin_cookies_file(self.douyin_cookies_path)
                        cookies = []
                        for name, value in cookies_dict.items():
                            cookies.append({
                                'name': name,
                                'value': value,
                                'domain': '.douyin.com',
                                'path': '/'
                            })
                        await context.add_cookies(cookies)
                        logger.info(f"[extract] æˆåŠŸåŠ è½½{len(cookies)}ä¸ªcookies")
                    except Exception as e:
                        logger.warning(f"[extract] cookiesåŠ è½½å¤±è´¥: {e}")

                # å‡†å¤‡video_idç›‘å¬
                video_id_holder = {'id': None}

                # å¤‡ç”¨ï¼šç›‘å¬ç½‘ç»œè¯·æ±‚ä¸­çš„video_id
                def handle_video_id(request):
                    request_url = request.url
                    if 'video_id=' in request_url:
                        m = re.search(r'video_id=([a-zA-Z0-9]+)', request_url)
                        if m:
                            video_id_holder['id'] = m.group(1)
                            logger.info(f"[extract] ç½‘ç»œè¯·æ±‚ä¸­æ•è·åˆ° video_id: {m.group(1)}")
                page.on("request", handle_video_id)

                try:
                    # æŒ‰ç…§douyin.pyè®¾ç½®headers
                    await self._set_platform_headers(page, platform)

                    # å¤„ç†çŸ­é“¾æ¥é‡å®šå‘ï¼ˆå…³é”®ä¿®å¤ï¼‰
                    if 'v.douyin.com' in url:
                        logger.info(f"[extract] æ£€æµ‹åˆ°çŸ­é“¾æ¥ï¼Œå…ˆè·å–é‡å®šå‘: {url}")
                        response = await page.goto(url, wait_until="domcontentloaded", timeout=30000)
                        real_url = page.url
                        logger.info(f"[extract] çŸ­é“¾æ¥é‡å®šå‘åˆ°: {real_url}")

                        # æå–video_idå¹¶æ„é€ æ ‡å‡†douyin.comé“¾æ¥
                        import re
                        video_id_match = re.search(r'/video/(\d+)', real_url)
                        if video_id_match:
                            video_id = video_id_match.group(1)
                            standard_url = f"https://www.douyin.com/video/{video_id}"
                            logger.info(f"[extract] è½¬æ¢ä¸ºæ ‡å‡†é“¾æ¥: {standard_url}")
                            await page.goto(standard_url, wait_until="domcontentloaded", timeout=30000)
                            logger.info(f"[extract] è®¿é—®æ ‡å‡†é“¾æ¥å®Œæˆ")
                        else:
                            # å¦‚æœæå–ä¸åˆ°video_idï¼Œç›´æ¥ç”¨é‡å®šå‘çš„URL
                            if real_url != url:
                                await page.goto(real_url, wait_until="domcontentloaded", timeout=30000)
                                logger.info(f"[extract] é‡æ–°è®¿é—®çœŸå®URLå®Œæˆ")
                    else:
                        logger.info("[extract] goto å‰")
                        await page.goto(url, wait_until="domcontentloaded", timeout=30000)
                        logger.info("[extract] goto åï¼Œç­‰å¾… video_id")

                    # è°ƒè¯•ï¼šæ£€æŸ¥é¡µé¢æ˜¯å¦æ­£ç¡®åŠ è½½
                    page_title = await page.title()
                    current_url = page.url
                    logger.info(f"[debug] é¡µé¢æ ‡é¢˜: {repr(page_title)}")
                    logger.info(f"[debug] å½“å‰URL: {current_url}")

                    # ç›´æ¥ä»URLæå–video_idï¼ˆæœ€å…³é”®çš„ä¿®å¤ï¼‰
                    video_id_match = re.search(r'/video/(\d+)', current_url)
                    if video_id_match:
                        video_id_holder['id'] = video_id_match.group(1)
                        logger.info(f"[extract] ä»å½“å‰URLç›´æ¥æå–åˆ° video_id: {video_id_holder['id']}")
                    else:
                        # å¦‚æœå½“å‰URLæå–å¤±è´¥ï¼Œä»åŸå§‹URLæå–
                        video_id_match = re.search(r'/video/(\d+)', url)
                        if video_id_match:
                            video_id_holder['id'] = video_id_match.group(1)
                            logger.info(f"[extract] ä»åŸå§‹URLæå–åˆ° video_id: {video_id_holder['id']}")

                    # æŒ‰ç…§douyin.pyï¼šæŠ–éŸ³å…ˆç­‰2ç§’
                    await asyncio.sleep(2)

                    # æŒ‰ç…§douyin.pyï¼šç­‰å¾…video_idå‡ºç°ï¼Œæœ€å¤šç­‰3ç§’
                    wait_start = time.time()
                    max_wait = 3  # æœ€å¤šç­‰3ç§’
                    while time.time() - wait_start < max_wait:
                        if video_id_holder['id']:
                            break
                        await asyncio.sleep(0.1)
                    logger.info(f"[extract] video_id ç­‰å¾…ç”¨æ—¶: {time.time() - wait_start:.2f}s")

                    # å¦‚æœè¿˜æ²¡æœ‰video_idï¼Œæœ€åä¸€æ¬¡å°è¯•ä»URLæå–
                    if not video_id_holder['id']:
                        logger.info("[extract] ç½‘ç»œç›‘å¬æœªæ•è·åˆ°video_idï¼Œå°è¯•ä»URLç›´æ¥æå–")
                        # å°è¯•ä»å„ç§å¯èƒ½çš„URLæ ¼å¼ä¸­æå–
                        for test_url in [current_url, url]:
                            video_id_match = re.search(r'/video/(\d+)', test_url)
                            if video_id_match:
                                video_id_holder['id'] = video_id_match.group(1)
                                logger.info(f"[extract] ä»URLç›´æ¥æå–åˆ° video_id: {video_id_holder['id']} (æ¥æº: {test_url})")
                                break

                    video_url = None
                    # ç›´æ¥ä½¿ç”¨HTMLæå–æ–¹å¼ï¼ˆæŠ–éŸ³å®˜æ–¹APIå·²å¤±æ•ˆï¼‰
                    logger.info("[extract] è¿›å…¥HTMLæå–æµç¨‹")
                    html = await page.content()

                    # æ ¹æ®å¹³å°é€‰æ‹©ä¸åŒçš„æå–æ–¹æ³•
                    if platform == Platform.DOUYIN:
                        video_url = await self._extract_douyin_url_from_html(html)
                    else:
                        # é€šç”¨æå–æ–¹æ³•
                        video_url = await self._extract_douyin_url_from_html(html)

                    logger.info(f"[extract] æ­£åˆ™æå–ç»“æœ: {video_url}")

                    if video_url:
                        # å¦‚æœæ˜¯å¸¦æ°´å°çš„URLï¼Œå°è¯•è½¬æ¢ä¸ºæ— æ°´å°URL
                        if 'playwm' in video_url:
                            logger.info("[extract] æ£€æµ‹åˆ°å¸¦æ°´å°URLï¼Œå°è¯•è½¬æ¢ä¸ºæ— æ°´å°URL")
                            no_watermark_url = video_url.replace('playwm', 'play')
                            logger.info(f"[extract] è½¬æ¢åçš„æ— æ°´å°URL: {no_watermark_url}")
                            video_url = no_watermark_url
                        # éªŒè¯URLæœ‰æ•ˆæ€§
                        is_valid = False
                        if platform == Platform.DOUYIN:
                            def is_valid_video_url(u):
                                u = u.lower()
                                # æŠ–éŸ³è§†é¢‘URLé€šå¸¸ä¸åŒ…å«æ–‡ä»¶æ‰©å±•åï¼Œè€Œæ˜¯é€šè¿‡å‚æ•°æŒ‡å®š
                                # æ£€æŸ¥æ˜¯å¦æ˜¯æŠ–éŸ³çš„CDNåŸŸå
                                if any(domain in u for domain in ['aweme.snssdk.com', 'douyinvod.com', 'snssdk.com']):
                                    return True
                                # æ£€æŸ¥æ˜¯å¦åŒ…å«è§†é¢‘ç›¸å…³å‚æ•°
                                if any(param in u for param in ['video_id', 'play', 'aweme']):
                                    return True
                                # æ’é™¤ä¸€äº›æ— æ•ˆçš„URL
                                if any(x in u for x in ['client.mp4', 'static', 'eden-cn', 'download/douyin_pc_client', 'douyin_pc_client.mp4']):
                                    return False
                                return True
                            is_valid = is_valid_video_url(video_url)
                        else:
                            # é€šç”¨éªŒè¯
                            is_valid = any(ext in video_url.lower() for ext in ['.mp4', '.m3u8', '.ts', '.flv', '.webm'])

                        if is_valid:
                            logger.info(f"[extract] æ­£åˆ™æµç¨‹å‘½ä¸­: {video_url}")
                            title = await self._get_video_title(page, platform)
                            author = await self._get_video_author(page, platform)
                            video_info = VideoInfo(
                                video_id=str(int(time.time())),
                                platform=platform,
                                share_url=url,
                                download_url=video_url,
                                title=title,
                                author=author,
                                thumbnail_url=None
                            )
                            logger.info("[extract] æ­£åˆ™æµç¨‹å®Œæˆ")

                            # ä¸‹è½½è§†é¢‘
                            download_result = await self._download_video_file(
                                video_info,
                                str(self.douyin_download_path),
                                message_updater,
                                None
                            )

                            await page.close()
                            await context.close()
                            await browser.close()
                            return download_result
                        else:
                            logger.warning(f"[extract] æå–çš„URLæ— æ•ˆ: {video_url}")
                            video_url = None

                    if not video_url:
                        logger.info("[extract] æ‰€æœ‰æµç¨‹å‡æœªæ•è·åˆ°è§†é¢‘æ•°æ®ï¼ŒæŠ›å‡º TimeoutError")
                        raise TimeoutError("æœªèƒ½æ•è·åˆ°è§†é¢‘æ•°æ®")

                finally:
                    logger.info("[extract] å…³é—­ page/context å‰")
                    await page.close()
                    await context.close()
                    logger.info("[extract] å…³é—­ page/context å")

                await browser.close()

        except Exception as e:
            logger.error(f"æŠ–éŸ³ä¸‹è½½å¼‚å¸¸: {str(e)}")
            return {
                "success": False,
                "error": f"ä¸‹è½½å¤±è´¥: {str(e)}",
                "platform": "Douyin",
                "content_type": "video"
            }

    async def _download_kuaishou_with_playwright(self, url: str, message, message_updater=None) -> dict:
        """ä½¿ç”¨Playwrightä¸‹è½½å¿«æ‰‹è§†é¢‘ - å‚è€ƒæŠ–éŸ³å®ç°"""
        if not PLAYWRIGHT_AVAILABLE:
            return {
                "success": False,
                "error": "Playwright æœªå®‰è£…ï¼Œæ— æ³•ä¸‹è½½å¿«æ‰‹è§†é¢‘",
                "platform": "Kuaishou",
                "content_type": "video"
            }

        try:
            from playwright.async_api import async_playwright
            import httpx
            from dataclasses import dataclass
            from typing import Optional
            from enum import Enum
            import time
            import re

            @dataclass
            class VideoInfo:
                video_id: str
                title: str
                author: str
                download_url: str
                platform: str = "kuaishou"
                create_time: Optional[str] = None
                quality: Optional[str] = None
                thumbnail_url: Optional[str] = None

            class Platform(str, Enum):
                KUAISHOU = "kuaishou"
                DOUYIN = "douyin"
                XIAOHONGSHU = "xiaohongshu"
                UNKNOWN = "unknown"

            # é¦–å…ˆæ¸…ç†URLï¼Œæå–çº¯é“¾æ¥
            clean_url = self._extract_clean_url_from_text(url)
            if not clean_url:
                return {
                    "success": False,
                    "error": "æ— æ³•ä»æ–‡æœ¬ä¸­æå–æœ‰æ•ˆçš„å¿«æ‰‹é“¾æ¥",
                    "platform": "Kuaishou",
                    "content_type": "video"
                }

            logger.info(f"âš¡ å¼€å§‹ä¸‹è½½å¿«æ‰‹è§†é¢‘: {clean_url}")
            if clean_url != url:
                logger.info(f"ğŸ”§ URLå·²æ¸…ç†: {url} -> {clean_url}")

            url = clean_url  # ä½¿ç”¨æ¸…ç†åçš„URL

            total_start = time.time()
            platform = Platform.KUAISHOU

            async with async_playwright() as p:
                # å¯åŠ¨æµè§ˆå™¨ï¼ˆå‚è€ƒæŠ–éŸ³é…ç½®ï¼‰
                browser = await p.chromium.launch(headless=True)

                # å¿«æ‰‹ä½¿ç”¨æ‰‹æœºç‰ˆé…ç½®
                context = await browser.new_context(
                    user_agent='Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1',
                    viewport={'width': 375, 'height': 667},
                    device_scale_factor=2,
                    locale='zh-CN',
                    timezone_id='Asia/Shanghai',
                    permissions=['geolocation'],
                    geolocation={'latitude': 39.9042, 'longitude': 116.4074},
                    extra_http_headers={
                        'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                        'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
                        'Accept-Encoding': 'gzip, deflate, br',
                        'DNT': '1',
                        'Connection': 'keep-alive',
                        'Upgrade-Insecure-Requests': '1',
                    }
                )

                page = await context.new_page()

                # å°è¯•åŠ è½½cookiesï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                if self.kuaishou_cookies_path and os.path.exists(self.kuaishou_cookies_path):
                    try:
                        cookies_dict = self._parse_kuaishou_cookies_file(self.kuaishou_cookies_path)
                        cookies = []
                        for name, value in cookies_dict.items():
                            cookies.append({
                                'name': name,
                                'value': value,
                                'domain': '.kuaishou.com',
                                'path': '/'
                            })
                        await context.add_cookies(cookies)
                        logger.info(f"[extract] æˆåŠŸåŠ è½½{len(cookies)}ä¸ªå¿«æ‰‹cookies")
                    except Exception as e:
                        logger.warning(f"[extract] åŠ è½½å¿«æ‰‹cookieså¤±è´¥: {e}")

                # ç›‘å¬ç½‘ç»œè¯·æ±‚ï¼Œæ•è·è§†é¢‘IDå’Œè§†é¢‘URL
                video_id_holder = {'id': None}
                video_url_holder = {'url': None}

                def handle_video_id(request):
                    req_url = request.url
                    # å¿«æ‰‹è§†é¢‘IDæ¨¡å¼
                    m = re.search(r'photoId[=:]([a-zA-Z0-9_-]+)', req_url)
                    if m and not video_id_holder['id']:
                        video_id_holder['id'] = m.group(1)
                        logger.info(f"[extract] ç½‘ç»œè¯·æ±‚ä¸­æ•è·åˆ°å¿«æ‰‹ photo_id: {m.group(1)}")

                    # ç›‘å¬è§†é¢‘æ–‡ä»¶è¯·æ±‚ - æ”¹è¿›è¿‡æ»¤é€»è¾‘
                    if not video_url_holder['url']:
                        # æ’é™¤æ—¥å¿—ã€ç»Ÿè®¡ã€APIç­‰éè§†é¢‘è¯·æ±‚
                        exclude_patterns = [
                            'log', 'collect', 'radar', 'stat', 'track', 'analytics',
                            'api', 'rest', 'sdk', 'report', 'beacon', 'ping'
                        ]

                        # æ£€æŸ¥æ˜¯å¦ä¸ºè§†é¢‘æ–‡ä»¶è¯·æ±‚
                        is_video_request = False
                        if '.mp4' in req_url and any(domain in req_url for domain in ['kwaicdn.com', 'ksapisrv.com', 'kuaishou.com']):
                            # ç¡®ä¿ä¸æ˜¯æ—¥å¿—æˆ–APIè¯·æ±‚
                            if not any(pattern in req_url.lower() for pattern in exclude_patterns):
                                is_video_request = True

                        # æˆ–è€…æ£€æŸ¥æ˜¯å¦ä¸ºå¿«æ‰‹CDNçš„è§†é¢‘æµ
                        elif any(domain in req_url for domain in ['kwaicdn.com']) and any(ext in req_url for ext in ['.mp4', '.m3u8', '.ts']):
                            if not any(pattern in req_url.lower() for pattern in exclude_patterns):
                                is_video_request = True

                        if is_video_request:
                            video_url_holder['url'] = req_url
                            logger.info(f"[extract] ç½‘ç»œè¯·æ±‚ä¸­æ•è·åˆ°å¿«æ‰‹è§†é¢‘URL: {req_url}")
                        elif any(pattern in req_url.lower() for pattern in exclude_patterns):
                            logger.debug(f"[extract] è·³è¿‡éè§†é¢‘è¯·æ±‚: {req_url}")

                page.on("request", handle_video_id)

                try:
                    # è®¾ç½®å¿«æ‰‹å¹³å°headers
                    await self._set_platform_headers(page, platform)

                    # è®¿é—®é¡µé¢
                    logger.info(f"[extract] å¼€å§‹è®¿é—®å¿«æ‰‹é¡µé¢: {url}")
                    await page.goto(url, wait_until="domcontentloaded", timeout=30000)
                    logger.info(f"[extract] é¡µé¢è®¿é—®å®Œæˆ")

                    # ç­‰å¾…é¡µé¢åŠ è½½æ›´é•¿æ—¶é—´ï¼Œè®©JavaScriptæ‰§è¡Œ
                    logger.info(f"[extract] ç­‰å¾…é¡µé¢JavaScriptæ‰§è¡Œ...")
                    await asyncio.sleep(5)

                    # å°è¯•ç­‰å¾…è§†é¢‘å…ƒç´ å‡ºç°
                    try:
                        await page.wait_for_selector('video, [data-testid*="video"], .video-player', timeout=10000)
                        logger.info(f"[extract] æ£€æµ‹åˆ°è§†é¢‘å…ƒç´ ")
                    except:
                        logger.warning(f"[extract] æœªæ£€æµ‹åˆ°è§†é¢‘å…ƒç´ ï¼Œç»§ç»­å¤„ç†")

                    # å°è¯•ä¸€äº›é¡µé¢äº¤äº’æ¥è§¦å‘è§†é¢‘åŠ è½½
                    try:
                        # æ»šåŠ¨é¡µé¢
                        await page.evaluate('window.scrollTo(0, document.body.scrollHeight)')
                        await asyncio.sleep(1)
                        await page.evaluate('window.scrollTo(0, 0)')
                        await asyncio.sleep(1)

                        # å°è¯•ç‚¹å‡»æ’­æ”¾æŒ‰é’®ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                        play_selectors = [
                            '.play-button', '.video-play', '[data-testid="play"]',
                            '.player-play', 'button[aria-label*="play"]', '.play-icon'
                        ]
                        for selector in play_selectors:
                            try:
                                play_button = await page.query_selector(selector)
                                if play_button:
                                    await play_button.click()
                                    logger.info(f"[extract] ç‚¹å‡»äº†æ’­æ”¾æŒ‰é’®: {selector}")
                                    await asyncio.sleep(2)
                                    break
                            except:
                                continue

                        # å°è¯•é¼ æ ‡æ‚¬åœåœ¨è§†é¢‘åŒºåŸŸ
                        try:
                            video_area = await page.query_selector('video, .video-container, .player-container')
                            if video_area:
                                await video_area.hover()
                                await asyncio.sleep(1)
                        except:
                            pass

                    except Exception as e:
                        logger.warning(f"[extract] é¡µé¢äº¤äº’å¤±è´¥: {e}")

                    # å†ç­‰å¾…ä¸€æ®µæ—¶é—´ç¡®ä¿å†…å®¹åŠ è½½å®Œæˆ
                    await asyncio.sleep(3)

                    # å°è¯•ä»URLä¸­æå–photo_id
                    if not video_id_holder['id']:
                        photo_id_match = re.search(r'/short-video/([a-zA-Z0-9_-]+)', url)
                        if photo_id_match:
                            video_id_holder['id'] = photo_id_match.group(1)
                            logger.info(f"[extract] ä»URLæå–åˆ°å¿«æ‰‹ photo_id: {video_id_holder['id']}")

                    # ä¼˜å…ˆä½¿ç”¨ç½‘ç»œç›‘å¬æ•è·çš„è§†é¢‘URL
                    video_url = video_url_holder['url']

                    if not video_url:
                        # å¦‚æœç½‘ç»œç›‘å¬æ²¡æœ‰æ•è·åˆ°ï¼Œä»HTMLä¸­æå–è§†é¢‘ç›´é“¾
                        logger.info(f"[extract] ç½‘ç»œç›‘å¬æœªæ•è·åˆ°è§†é¢‘URLï¼Œå°è¯•ä»HTMLæå–")
                        html = await page.content()
                        video_url = await self._extract_kuaishou_url_from_html(html)
                        logger.info(f"[extract] å¿«æ‰‹HTMLæå–ç»“æœ: {video_url}")
                    else:
                        logger.info(f"[extract] ä½¿ç”¨ç½‘ç»œç›‘å¬æ•è·çš„è§†é¢‘URL: {video_url}")

                    if video_url:
                        # è·å–æ ‡é¢˜å’Œä½œè€…
                        title = await self._get_video_title(page, platform)
                        author = await self._get_video_author(page, platform)

                        # åˆ›å»ºè§†é¢‘ä¿¡æ¯å¯¹è±¡
                        video_info = VideoInfo(
                            video_id=video_id_holder['id'] or str(int(time.time())),
                            title=title or f"å¿«æ‰‹è§†é¢‘_{int(time.time())}",
                            author=author or "æœªçŸ¥ä½œè€…",
                            download_url=video_url,
                            platform="kuaishou"
                        )

                        logger.info(f"[extract] å¿«æ‰‹è§†é¢‘ä¿¡æ¯: æ ‡é¢˜={video_info.title}, ä½œè€…={video_info.author}")
                        logger.info("[extract] æ­£åˆ™æµç¨‹å®Œæˆ")

                        # ä¸‹è½½è§†é¢‘
                        download_result = await self._download_video_file(
                            video_info,
                            str(self.kuaishou_download_path),
                            message_updater,
                            None
                        )

                        await page.close()
                        await context.close()
                        return download_result
                    else:
                        logger.error("[extract] æœªèƒ½æå–åˆ°å¿«æ‰‹è§†é¢‘ç›´é“¾")
                        await page.close()
                        await context.close()
                        return {
                            "success": False,
                            "error": "æœªèƒ½æå–åˆ°å¿«æ‰‹è§†é¢‘ç›´é“¾",
                            "platform": "Kuaishou",
                            "content_type": "video"
                        }

                except Exception as e:
                    logger.error(f"[extract] å¿«æ‰‹é¡µé¢å¤„ç†å¼‚å¸¸: {str(e)}")
                    try:
                        await page.close()
                        await context.close()
                    except:
                        pass
                    logger.info("[extract] å…³é—­ page/context å")

                await browser.close()

        except Exception as e:
            logger.error(f"å¿«æ‰‹ä¸‹è½½å¼‚å¸¸: {str(e)}")
            return {
                "success": False,
                "error": f"ä¸‹è½½å¤±è´¥: {str(e)}",
                "platform": "Kuaishou",
                "content_type": "video"
            }

    async def _extract_kuaishou_url_from_html(self, html: str) -> Optional[str]:
        """ä»å¿«æ‰‹HTMLæºç ä¸­æå–è§†é¢‘ç›´é“¾"""
        try:
            logger.info(f"[extract] å¿«æ‰‹HTMLé•¿åº¦: {len(html)} å­—ç¬¦")

            # å…ˆä¿å­˜HTMLåˆ°æ–‡ä»¶ç”¨äºè°ƒè¯•
            try:
                debug_path = '/tmp/kuaishou_debug.html'
                with open(debug_path, 'w', encoding='utf-8') as f:
                    f.write(html)
                logger.info(f"[extract] å·²ä¿å­˜HTMLåˆ° {debug_path} ç”¨äºè°ƒè¯•")

                # è¾“å‡ºHTMLçš„å‰500ä¸ªå­—ç¬¦ç”¨äºå¿«é€Ÿåˆ†æ
                logger.info(f"[extract] HTMLå¼€å¤´å†…å®¹: {html[:500]}")

                # æ£€æŸ¥HTMLä¸­æ˜¯å¦åŒ…å«å…³é”®è¯
                keywords = ['video', 'mp4', 'src', 'url', 'play', 'kwai']
                for keyword in keywords:
                    count = html.lower().count(keyword)
                    if count > 0:
                        logger.info(f"[extract] HTMLä¸­åŒ…å« '{keyword}': {count} æ¬¡")

            except Exception as e:
                logger.warning(f"[extract] ä¿å­˜HTMLè°ƒè¯•æ–‡ä»¶å¤±è´¥: {e}")

            # å¿«æ‰‹è§†é¢‘URLçš„æ­£åˆ™æ¨¡å¼ - æ‰©å±•æ›´å¤šæ¨¡å¼
            patterns = [
                # å¿«æ‰‹è§†é¢‘ç›´é“¾æ¨¡å¼
                r'"srcNoMark":"(https://[^"]+\.mp4[^"]*)"',
                r'"playUrl":"(https://[^"]+\.mp4[^"]*)"',
                r'"videoUrl":"(https://[^"]+\.mp4[^"]*)"',
                r'"src":"(https://[^"]+\.mp4[^"]*)"',
                r'"url":"(https://[^"]+\.mp4[^"]*)"',
                # å¿«æ‰‹CDNæ¨¡å¼
                r'(https://[^"\']+\.kwaicdn\.com/[^"\']+\.mp4[^"\']*)',
                r'(https://[^"\']+\.kuaishou\.com/[^"\']+\.mp4[^"\']*)',
                r'(https://[^"\']+\.ksapisrv\.com/[^"\']+\.mp4[^"\']*)',
                # JSONä¸­çš„è§†é¢‘URL
                r'"photoUrl":"(https://[^"]+\.mp4[^"]*)"',
                r'"manifest":"(https://[^"]+\.mp4[^"]*)"',
                # é€šç”¨è§†é¢‘URLæ¨¡å¼
                r'(https://[^"\'>\s]+\.mp4[^"\'>\s]*)',
                # æŸ¥æ‰¾åŒ…å«videoçš„JSONå­—æ®µ
                r'"[^"]*[Vv]ideo[^"]*":"(https://[^"]+)"',
                r'"[^"]*[Pp]lay[^"]*":"(https://[^"]+\.mp4[^"]*)"',
            ]

            for i, pattern in enumerate(patterns):
                matches = re.findall(pattern, html)
                if matches:
                    for match in matches:
                        # æ¸…ç†URL
                        video_url = match.replace('\\u002F', '/').replace('\\u0026', '&').replace('\\/', '/').replace('\\', '')
                        # éªŒè¯URLæ ¼å¼
                        if (video_url.startswith('http') and
                            ('.mp4' in video_url or 'kwaicdn.com' in video_url or 'kuaishou.com' in video_url) and
                            len(video_url) > 20):  # åŸºæœ¬é•¿åº¦æ£€æŸ¥
                            logger.info(f"[extract] å¿«æ‰‹æ¨¡å¼{i+1}æ‰¾åˆ°è§†é¢‘URL: {video_url}")
                            return video_url

            # å¦‚æœæ­£åˆ™éƒ½å¤±è´¥ï¼Œå°è¯•æŸ¥æ‰¾scriptæ ‡ç­¾ä¸­çš„JSONæ•°æ®
            logger.info("[extract] æ­£åˆ™æ¨¡å¼å¤±è´¥ï¼Œå°è¯•è§£æscriptæ ‡ç­¾ä¸­çš„JSON")
            script_matches = re.findall(r'<script[^>]*>(.*?)</script>', html, re.DOTALL)
            for script_content in script_matches:
                if 'mp4' in script_content or 'video' in script_content.lower():
                    # å°è¯•ä»scriptä¸­æå–è§†é¢‘URL
                    video_patterns = [
                        r'"(https://[^"]+\.mp4[^"]*)"',
                        r"'(https://[^']+\.mp4[^']*)'",
                        r'(https://[^\s"\']+\.mp4[^\s"\']*)',
                    ]
                    for pattern in video_patterns:
                        matches = re.findall(pattern, script_content)
                        for match in matches:
                            video_url = match.replace('\\u002F', '/').replace('\\u0026', '&').replace('\\/', '/').replace('\\', '')
                            if (video_url.startswith('http') and
                                ('.mp4' in video_url or 'kwaicdn.com' in video_url) and
                                len(video_url) > 20):
                                logger.info(f"[extract] ä»scriptæ ‡ç­¾æ‰¾åˆ°è§†é¢‘URL: {video_url}")
                                return video_url

            logger.warning("[extract] æ‰€æœ‰å¿«æ‰‹æ­£åˆ™æ¨¡å¼éƒ½æœªåŒ¹é…åˆ°è§†é¢‘URL")

            # è¾“å‡ºä¸€äº›HTMLç‰‡æ®µç”¨äºè°ƒè¯•
            if 'mp4' in html:
                mp4_contexts = []
                for match in re.finditer(r'.{0,50}mp4.{0,50}', html, re.IGNORECASE):
                    mp4_contexts.append(match.group())
                logger.info(f"[extract] HTMLä¸­åŒ…å«mp4çš„ä¸Šä¸‹æ–‡: {mp4_contexts[:3]}")  # åªæ˜¾ç¤ºå‰3ä¸ª

            return None

        except Exception as e:
            logger.warning(f"å¿«æ‰‹HTMLæ­£åˆ™æå–å¤±è´¥: {str(e)}")
        return None

    async def _download_video_file(self, video_info, download_dir, message_updater=None, start_message=None):
        """ä¸‹è½½è§†é¢‘æ–‡ä»¶"""
        try:
            # ç”Ÿæˆæ–‡ä»¶å
            if video_info.title:
                # æ¸…ç†æ ‡é¢˜ï¼Œå»é™¤ç‰¹æ®Šå­—ç¬¦å’Œå¹³å°åç¼€
                clean_title = self._sanitize_filename(video_info.title)
                # å°çº¢ä¹¦ã€æŠ–éŸ³å’Œå¿«æ‰‹çš„ç‰¹æ®Šå‘½åé€»è¾‘
                if video_info.platform in ["xiaohongshu", "douyin", "kuaishou"]:
                    # å»æ‰å¼€å¤´çš„#å’Œç©ºæ ¼
                    clean_title = clean_title.lstrip('#').strip()
                    # ç”¨#åˆ†å‰²ï¼Œå–ç¬¬ä¸€ä¸ªåˆ†å‰²åçš„å†…å®¹ï¼ˆå³ç¬¬2ä¸ª#å‰çš„å†…å®¹ï¼‰
                    clean_title = clean_title.split('#')[0].strip()
                    # å¦‚æœå¤„ç†åæ ‡é¢˜ä¸ºç©ºï¼Œä½¿ç”¨å¹³å°+æ—¶é—´æˆ³
                    if not clean_title:
                        clean_title = f"{video_info.platform}_{int(time.time())}"
                else:
                    # å…¶ä»–å¹³å°ä¿æŒåŸæœ‰é€»è¾‘
                    clean_title = re.split(r'#', clean_title)[0].strip()
                # å»é™¤å¹³å°åç¼€
                clean_title = re.sub(r'[-_ ]*(æŠ–éŸ³|å¿«æ‰‹|å°çº¢ä¹¦|YouTube|youtube)$', '', clean_title, flags=re.IGNORECASE).strip()
                filename = f"{clean_title}.mp4"
            else:
                # å¦‚æœè·å–æ ‡é¢˜å¤±è´¥ï¼Œä½¿ç”¨æ—¶é—´æˆ³
                filename = f"{video_info.platform}_{int(time.time())}.mp4"

            file_path = os.path.join(download_dir, filename)

            # å°çº¢ä¹¦ä½¿ç”¨ç®€å•ä¸‹è½½é€»è¾‘ï¼ŒæŠ–éŸ³ä¿æŒç°æœ‰é€»è¾‘
            if video_info.platform == 'xiaohongshu':
                # å°çº¢ä¹¦ï¼šç®€å•ä¸‹è½½é€»è¾‘ï¼Œå‚è€ƒdouyin.py
                async with httpx.AsyncClient(follow_redirects=True, timeout=60) as client:
                    headers = {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36',
                        'Referer': 'https://www.xiaohongshu.com/'
                    }

                    logger.info(f"ğŸ¬ å¼€å§‹ä¸‹è½½å°çº¢ä¹¦è§†é¢‘: {video_info.download_url}")

                    # å…ˆæ£€æŸ¥å“åº”çŠ¶æ€å’Œå¤´ä¿¡æ¯
                    try:
                        async with client.stream("GET", video_info.download_url, headers=headers) as resp:
                            logger.info(f"ğŸ“Š HTTPçŠ¶æ€ç : {resp.status_code}")
                            logger.info(f"ğŸ“Š å“åº”å¤´: {dict(resp.headers)}")

                            total = int(resp.headers.get("content-length", 0))
                            logger.info(f"ğŸ“Š æ–‡ä»¶å¤§å°: {total} bytes")

                            if resp.status_code != 200:
                                logger.error(f"âŒ HTTPçŠ¶æ€ç é”™è¯¯: {resp.status_code}")
                                # è¯»å–é”™è¯¯å“åº”å†…å®¹
                                error_content = await resp.aread()
                                logger.error(f"âŒ é”™è¯¯å“åº”å†…å®¹: {error_content[:500]}")
                                raise Exception(f"HTTPçŠ¶æ€ç é”™è¯¯: {resp.status_code}")

                            with open(file_path, "wb") as f:
                                downloaded = 0
                                chunk_size = 1024 * 256

                                async for chunk in resp.aiter_bytes(chunk_size=chunk_size):
                                    f.write(chunk)
                                    downloaded += len(chunk)

                                    # æ›´æ–°è¿›åº¦ - ä½¿ç”¨ä¸ YouTube ç›¸åŒçš„æ ¼å¼
                                    if total > 0:
                                        progress = downloaded / total * 100
                                    else:
                                        # å¦‚æœæ²¡æœ‰content-lengthï¼Œä½¿ç”¨ä¸‹è½½çš„å­—èŠ‚æ•°ä½œä¸ºè¿›åº¦æŒ‡ç¤º
                                        progress = min(downloaded / (1024 * 1024), 99)  # å‡è®¾è‡³å°‘1MB

                                    # è®¡ç®—é€Ÿåº¦ï¼ˆæ¯ç§’æ›´æ–°ä¸€æ¬¡ï¼‰
                                    current_time = time.time()
                                    if not hasattr(self, '_last_update_time'):
                                        self._last_update_time = current_time
                                        self._last_downloaded = 0

                                    if current_time - self._last_update_time >= 1.0:
                                        speed = (downloaded - self._last_downloaded) / (current_time - self._last_update_time)
                                        self._last_update_time = current_time
                                        self._last_downloaded = downloaded
                                    else:
                                        speed = 0

                                    # è®¡ç®—ETA
                                    if speed > 0 and total > 0:
                                        remaining_bytes = total - downloaded
                                        eta_seconds = remaining_bytes / speed
                                    else:
                                        eta_seconds = 0

                                    # æ„å»ºè¿›åº¦æ•°æ®ï¼Œæ ¼å¼ä¸ yt-dlp ä¸€è‡´
                                    progress_data = {
                                        'status': 'downloading',
                                        'downloaded_bytes': downloaded,
                                        'total_bytes': total,
                                        'speed': speed,
                                        'eta': eta_seconds,
                                        'filename': filename
                                    }

                                    # ä½¿ç”¨ message_updater æ›´æ–°è¿›åº¦
                                    if message_updater:
                                        try:
                                            import asyncio
                                            if asyncio.iscoroutinefunction(message_updater):
                                                # å¦‚æœæ˜¯åç¨‹å‡½æ•°ï¼Œéœ€è¦åœ¨äº‹ä»¶å¾ªç¯ä¸­è¿è¡Œ
                                                try:
                                                    loop = asyncio.get_running_loop()
                                                except RuntimeError:
                                                    try:
                                                        loop = asyncio.get_event_loop()
                                                    except RuntimeError:
                                                        loop = asyncio.new_event_loop()
                                                        asyncio.set_event_loop(loop)
                                                asyncio.run_coroutine_threadsafe(message_updater(progress_data), loop)
                                            else:
                                                # åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                                                message_updater(progress_data)
                                        except Exception as e:
                                            logger.warning(f"âš ï¸ æ›´æ–°è¿›åº¦å¤±è´¥: {e}")

                                # ä¸‹è½½å®Œæˆåçš„æœ€ç»ˆæ›´æ–°
                                logger.info(f"âœ… å°çº¢ä¹¦è§†é¢‘ä¸‹è½½å®Œæˆ: {downloaded} bytes @{video_info.download_url}")
                                if message_updater:
                                    try:
                                        final_progress_data = {
                                            'status': 'finished',
                                            'downloaded_bytes': downloaded,
                                            'total_bytes': total,
                                            'filename': filename
                                        }
                                        message_updater(final_progress_data)
                                    except Exception as e:
                                        logger.warning(f"âš ï¸ æ›´æ–°å®ŒæˆçŠ¶æ€å¤±è´¥: {e}")
                    except Exception as e:
                        logger.error(f"âŒ å°çº¢ä¹¦ä¸‹è½½å¼‚å¸¸: {e}")
                        raise
            else:
                # æŠ–éŸ³ç­‰å…¶ä»–å¹³å°ï¼šå¤„ç†APIé‡å®šå‘
                # å‡†å¤‡cookiesï¼ˆå¦‚æœæœ‰ï¼‰
                cookies_dict = {}
                if video_info.platform == 'douyin' and self.douyin_cookies_path and os.path.exists(self.douyin_cookies_path):
                    try:
                        cookies_dict = self._parse_douyin_cookies_file(self.douyin_cookies_path)
                        logger.info(f"ğŸ“Š åŠ è½½äº†{len(cookies_dict)}ä¸ªcookiesç”¨äºä¸‹è½½")
                    except Exception as e:
                        logger.warning(f"âš ï¸ åŠ è½½cookieså¤±è´¥: {e}")

                async with httpx.AsyncClient(follow_redirects=True, timeout=60, cookies=cookies_dict) as client:
                    # ä½¿ç”¨æ‰‹æœºç‰ˆUser-Agentï¼ˆæŒ‰ç…§åŸå§‹douyin.pyï¼‰
                    headers = {
                        'User-Agent': 'Mozilla/5.0 (iPhone; CPU iPhone OS 16_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/16.0 Mobile/15E148 Safari/604.1',
                        'Accept': '*/*',
                        'Accept-Language': 'zh-CN,zh;q=0.9,en;q=0.8',
                        'Referer': 'https://www.douyin.com/' if video_info.platform == 'douyin' else 'https://www.xiaohongshu.com/',
                        'Connection': 'keep-alive',
                    }

                    # å¯¹äºæŠ–éŸ³APIé“¾æ¥ï¼Œç›´æ¥ä½¿ç”¨streamä¸‹è½½ï¼ˆæŒ‰ç…§åŸå§‹douyin.pyçš„æ–¹å¼ï¼‰
                    logger.info(f"ğŸ¬ å¼€å§‹ä¸‹è½½æŠ–éŸ³è§†é¢‘: {video_info.download_url}")

                    with open(file_path, "wb") as f:
                        async with client.stream("GET", video_info.download_url, headers=headers) as resp:
                            total = int(resp.headers.get("content-length", 0))
                            downloaded = 0
                            chunk_size = 1024 * 256
                            last_update_time = time.time()
                            last_downloaded = 0

                            logger.info(f"ğŸ“Š Streamå“åº”çŠ¶æ€ç : {resp.status_code}")
                            logger.info(f"ğŸ“Š Streamæ–‡ä»¶å¤§å°: {total} bytes")
                            logger.info(f"ğŸ“Š å®é™…è¯·æ±‚URL: {resp.url}")
                            logger.info(f"ğŸ“Š å“åº”å¤´: {dict(resp.headers)}")

                            if resp.status_code != 200:
                                raise Exception(f"HTTPçŠ¶æ€ç é”™è¯¯: {resp.status_code}")

                            async for chunk in resp.aiter_bytes(chunk_size=chunk_size):
                                if not chunk:
                                    break
                                f.write(chunk)
                                downloaded += len(chunk)
                                current_time = time.time()

                                # æ›´æ–°è¿›åº¦ - ä½¿ç”¨ä¸ YouTube ç›¸åŒçš„æ ¼å¼
                                if total > 0:
                                    progress = downloaded / total * 100
                                else:
                                    # å¦‚æœæ²¡æœ‰content-lengthï¼Œä½¿ç”¨ä¸‹è½½çš„å­—èŠ‚æ•°ä½œä¸ºè¿›åº¦æŒ‡ç¤º
                                    progress = min(downloaded / (1024 * 1024), 99)  # å‡è®¾è‡³å°‘1MB

                                # è®¡ç®—é€Ÿåº¦ï¼ˆæ¯ç§’æ›´æ–°ä¸€æ¬¡ï¼‰
                                if current_time - last_update_time >= 1.0:
                                    speed = (downloaded - last_downloaded) / (current_time - last_update_time)
                                    last_update_time = current_time
                                    last_downloaded = downloaded

                                    # è®¡ç®—ETA
                                    if speed > 0 and total > 0:
                                        remaining_bytes = total - downloaded
                                        eta_seconds = remaining_bytes / speed
                                    else:
                                        eta_seconds = 0

                                    # æ„å»ºè¿›åº¦æ•°æ®ï¼Œæ ¼å¼ä¸ yt-dlp ä¸€è‡´
                                    progress_data = {
                                        'status': 'downloading',
                                        'downloaded_bytes': downloaded,
                                        'total_bytes': total,
                                        'speed': speed,
                                        'eta': eta_seconds,
                                        'filename': filename
                                    }

                                    # ä½¿ç”¨ message_updater æ›´æ–°è¿›åº¦
                                    if message_updater:
                                        try:
                                            import asyncio
                                            if asyncio.iscoroutinefunction(message_updater):
                                                # å¦‚æœæ˜¯åç¨‹å‡½æ•°ï¼Œéœ€è¦åœ¨äº‹ä»¶å¾ªç¯ä¸­è¿è¡Œ
                                                try:
                                                    loop = asyncio.get_running_loop()
                                                except RuntimeError:
                                                    try:
                                                        loop = asyncio.get_event_loop()
                                                    except RuntimeError:
                                                        loop = asyncio.new_event_loop()
                                                        asyncio.set_event_loop(loop)
                                                asyncio.run_coroutine_threadsafe(message_updater(progress_data), loop)
                                            else:
                                                # åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                                                message_updater(progress_data)
                                        except Exception as e:
                                            logger.warning(f"âš ï¸ æ›´æ–°è¿›åº¦å¤±è´¥: {e}")
                                    else:
                                        # å¦‚æœæ²¡æœ‰ message_updaterï¼Œä½¿ç”¨åŸæ¥çš„ç®€å•æ›´æ–°
                                        if start_message and hasattr(self, 'bot') and self.bot:
                                            try:
                                                await start_message.edit_text(
                                                    f"ğŸ“¥ ä¸‹è½½ä¸­... {progress:.1f}% ({downloaded/(1024*1024):.1f}MB)"
                                                )
                                            except Exception as e:
                                                logger.warning(f"âš ï¸ æ›´æ–°è¿›åº¦æ¶ˆæ¯å¤±è´¥: {e}")
                                        else:
                                            logger.info(f"ğŸ“¥ ä¸‹è½½ä¸­... {progress:.1f}% ({downloaded/(1024*1024):.1f}MB)")

                            # ä¸‹è½½å®Œæˆåçš„æœ€ç»ˆæ›´æ–°
                            logger.info(f"âœ… ä¸‹è½½å®Œæˆ: {downloaded} bytes")
                            if message_updater:
                                try:
                                    final_progress_data = {
                                        'status': 'finished',
                                        'downloaded_bytes': downloaded,
                                        'total_bytes': total,
                                        'filename': filename
                                    }
                                    import asyncio
                                    if asyncio.iscoroutinefunction(message_updater):
                                        # å¦‚æœæ˜¯åç¨‹å‡½æ•°ï¼Œéœ€è¦åœ¨äº‹ä»¶å¾ªç¯ä¸­è¿è¡Œ
                                        try:
                                            loop = asyncio.get_running_loop()
                                        except RuntimeError:
                                            try:
                                                loop = asyncio.get_event_loop()
                                            except RuntimeError:
                                                loop = asyncio.new_event_loop()
                                                asyncio.set_event_loop(loop)
                                        asyncio.run_coroutine_threadsafe(message_updater(final_progress_data), loop)
                                    else:
                                        # åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                                        message_updater(final_progress_data)
                                except Exception as e:
                                    logger.warning(f"âš ï¸ æ›´æ–°å®ŒæˆçŠ¶æ€å¤±è´¥: {e}")

            # åˆ é™¤å¼€å§‹æ¶ˆæ¯ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if start_message and hasattr(self, 'bot') and self.bot:
                try:
                    await start_message.delete()
                except Exception as e:
                    logger.warning(f"âš ï¸ åˆ é™¤å¼€å§‹æ¶ˆæ¯å¤±è´¥: {e}")

            # è·å–æ–‡ä»¶ä¿¡æ¯
            file_size = os.path.getsize(file_path)
            size_mb = file_size / (1024 * 1024)

            # ä½¿ç”¨ ffprobe è·å–è§†é¢‘åˆ†è¾¨ç‡ä¿¡æ¯
            resolution = "æœªçŸ¥"
            try:
                media_info = self.get_media_info(file_path)
                if media_info.get("resolution"):
                    resolution = media_info["resolution"]
                    logger.info(f"ğŸ“º è·å–åˆ°è§†é¢‘åˆ†è¾¨ç‡: {resolution}")
            except Exception as e:
                logger.warning(f"âš ï¸ è·å–è§†é¢‘åˆ†è¾¨ç‡å¤±è´¥: {e}")

            logger.info(f"âœ… {video_info.platform}è§†é¢‘ä¸‹è½½æˆåŠŸ: {filename} ({size_mb:.1f} MB, åˆ†è¾¨ç‡: {resolution})")

            return {
                "success": True,
                "file_path": file_path,
                "filename": filename,
                "title": video_info.title,
                "author": video_info.author,
                "platform": video_info.platform,
                "content_type": "video",
                "size_mb": size_mb,
                "resolution": resolution,
                "download_path": download_dir,
                "full_path": file_path,
                "file_count": 1,
                "files": [file_path]
            }

        except Exception as e:
            logger.error(f"âŒ ä¸‹è½½è§†é¢‘æ–‡ä»¶å¤±è´¥: {e}")
            # ç¡®ä¿åœ¨å¼‚å¸¸æƒ…å†µä¸‹ä¹Ÿèƒ½è¿”å›æœ‰æ•ˆçš„ç»“æœ
            return {
                "success": False,
                "error": f"ä¸‹è½½è§†é¢‘æ–‡ä»¶å¤±è´¥: {e}",
                "platform": video_info.platform,
                "content_type": "video",
                "downloaded_bytes": 0,
                "total_bytes": 0,
                "filename": video_info.title or f"{video_info.platform}_{int(time.time())}.mp4"
            }



    def _build_bilibili_rename_script(self):
        """
        æ„å»ºBç«™å¤šPè§†é¢‘æ™ºèƒ½é‡å‘½åè„šæœ¬

        åŸºäºæ‚¨çš„ä¼˜ç§€å»ºè®®ï¼šä½¿ç”¨yt-dlpçš„--execåŠŸèƒ½åœ¨ä¸‹è½½å®Œæˆåç«‹å³é‡å‘½å
        é¿å…äº†ä¸‹è½½å®Œæˆåçš„æ‰¹é‡é‡å‘½åæ“ä½œï¼Œæ›´é«˜æ•ˆæ›´å‡†ç¡®

        Returns:
            str: é‡å‘½åè„šæœ¬å‘½ä»¤
        """
        import shlex

        # æ„å»ºé‡å‘½åè„šæœ¬
        # 1. è·å–å½“å‰æ–‡ä»¶çš„URLï¼ˆä»æ–‡ä»¶åæ¨å¯¼ï¼‰
        # 2. ä½¿ç”¨yt-dlp --get-titleè·å–å®Œæ•´æ ‡é¢˜
        # 3. ä½¿ç”¨grepæå–pxxéƒ¨åˆ†
        # 4. é‡å‘½åæ–‡ä»¶

        script = '''
        # è·å–æ–‡ä»¶ä¿¡æ¯
        file_path="{}"
        file_dir=$(dirname "$file_path")
        file_name=$(basename "$file_path")
        file_ext="${file_name##*.}"
        video_id="${file_name%.*}"

        # æ„å»ºURLï¼ˆå‡è®¾æ˜¯Bç«™è§†é¢‘ï¼‰
        if [[ $video_id == *"_p"* ]]; then
            # å¤šPè§†é¢‘æ ¼å¼ï¼šBV1Jgf6YvE8e_p1
            bv_id="${video_id%_p*}"
            part_num="${video_id#*_p}"
            video_url="https://www.bilibili.com/video/${bv_id}?p=${part_num}"
        else
            # å•Pè§†é¢‘æ ¼å¼ï¼šBV1Jgf6YvE8e
            video_url="https://www.bilibili.com/video/${video_id}"
        fi

        # è·å–å®Œæ•´æ ‡é¢˜å¹¶æå–pxxéƒ¨åˆ†
        full_title=$(yt-dlp --get-title --skip-download "$video_url" 2>/dev/null)
        if [[ $? -eq 0 && -n "$full_title" ]]; then
            # æå–pxxåŠåç»­å†…å®¹
            new_name=$(echo "$full_title" | grep -o "p[0-9]\\{1,3\\}.*" | head -1)
            if [[ -n "$new_name" ]]; then
                # æ¸…ç†æ–‡ä»¶åä¸­çš„ç‰¹æ®Šå­—ç¬¦
                new_name=$(echo "$new_name" | sed 's/[\\/:*?"<>|ã€ã€‘ï½œ]/\\_/g' | sed 's/\\s\\+/ /g')
                new_file_path="$file_dir/${new_name}.${file_ext}"

                # æ‰§è¡Œé‡å‘½å
                if [[ "$file_path" != "$new_file_path" ]]; then
                    mv "$file_path" "$new_file_path"
                    echo "âœ… æ™ºèƒ½é‡å‘½å: $(basename "$file_path") -> ${new_name}.${file_ext}"
                else
                    echo "ğŸ“ æ–‡ä»¶åå·²æ­£ç¡®: ${new_name}.${file_ext}"
                fi
            else
                echo "âš ï¸ æœªæ‰¾åˆ°pxxæ¨¡å¼ï¼Œä¿æŒåŸæ–‡ä»¶å: $file_name"
            fi
        else
            echo "âš ï¸ æ— æ³•è·å–æ ‡é¢˜ï¼Œä¿æŒåŸæ–‡ä»¶å: $file_name"
        fi
        '''

        return script.strip()

    def _is_temp_format_file(self, filename):
        """
        æ£€æŸ¥æ˜¯å¦æ˜¯ä¸´æ—¶æ ¼å¼æ–‡ä»¶ï¼ˆåŒ…å«yt-dlpæ ¼å¼ä»£ç ï¼‰

        Args:
            filename: æ–‡ä»¶è·¯å¾„

        Returns:
            bool: å¦‚æœæ˜¯ä¸´æ—¶æ ¼å¼æ–‡ä»¶è¿”å›True
        """
        import re
        from pathlib import Path

        file_name = Path(filename).name

        # æ£€æŸ¥æ˜¯å¦åŒ…å«yt-dlpçš„æ ¼å¼ä»£ç 
        # ä¾‹å¦‚ï¼š.f100026, .f137+140, .m4a, .webm ç­‰
        temp_patterns = [
            r'\.f\d+',           # .f100026
            r'\.f\d+\+\d+',      # .f137+140
            r'\.m4a$',           # .m4a
            r'\.webm$',          # .webm
        ]

        for pattern in temp_patterns:
            if re.search(pattern, file_name):
                return True

        return False

    def _get_final_filename_from_mapping(self, filename, title_mapping):
        """
        ä»æ ‡é¢˜æ˜ å°„è¡¨ä¸­è·å–æœ€ç»ˆæ–‡ä»¶å

        Args:
            filename: å½“å‰ä¸‹è½½çš„æ–‡ä»¶å
            title_mapping: è§†é¢‘IDåˆ°æœ€ç»ˆæ–‡ä»¶åçš„æ˜ å°„è¡¨

        Returns:
            str: æœ€ç»ˆæ–‡ä»¶åï¼Œå¦‚æœæ‰¾ä¸åˆ°åˆ™è¿”å›None
        """
        import re
        from pathlib import Path

        try:
            file_path = Path(filename)

            # ä»æ–‡ä»¶åä¸­æå–è§†é¢‘ID
            # ä¾‹å¦‚ï¼šBV1aDMezREUj_p1.f100026.mp4 -> BV1aDMezREUj_p1
            raw_video_id = file_path.stem
            video_id = re.sub(r'\.f\d+.*$', '', raw_video_id)

            # ä»æ˜ å°„è¡¨ä¸­æŸ¥æ‰¾æœ€ç»ˆæ–‡ä»¶å
            final_filename = title_mapping.get(video_id)
            if final_filename:
                logger.debug(f"ğŸ“‹ æ˜ å°„æŸ¥æ‰¾: {video_id} -> {final_filename}")
                return final_filename
            else:
                logger.debug(f"âš ï¸ æœªæ‰¾åˆ°æ˜ å°„: {video_id}")
                return None

        except Exception as e:
            logger.debug(f"æ˜ å°„æŸ¥æ‰¾å¤±è´¥: {e}")
            return None

    def _optimize_filename_display_for_telegram(self, filename_display, file_count, total_size_mb, resolution_display, download_path):
        """
        åŠ¨æ€ä¼˜åŒ–æ–‡ä»¶åæ˜¾ç¤ºï¼Œæœ€å¤§åŒ–åˆ©ç”¨TGæ¶ˆæ¯ç©ºé—´

        Args:
            filename_display: åŸå§‹æ–‡ä»¶åæ˜¾ç¤ºå­—ç¬¦ä¸²
            file_count: æ–‡ä»¶æ•°é‡
            total_size_mb: æ€»æ–‡ä»¶å¤§å°
            resolution_display: åˆ†è¾¨ç‡æ˜¾ç¤º
            download_path: ä¸‹è½½è·¯å¾„

        Returns:
            str: ä¼˜åŒ–åçš„æ–‡ä»¶åæ˜¾ç¤ºå­—ç¬¦ä¸²
        """
        # TGæ¶ˆæ¯æœ€å¤§é•¿åº¦é™åˆ¶
        MAX_MESSAGE_LENGTH = 4096

        # æ„å»ºæ¶ˆæ¯çš„å…¶ä»–éƒ¨åˆ†ï¼ˆä¸åŒ…æ‹¬æ–‡ä»¶ååˆ—è¡¨ï¼‰
        other_parts = (
            f"ğŸ¬ è§†é¢‘ä¸‹è½½å®Œæˆ\n\n"
            f"ğŸ“ æ–‡ä»¶å:\n"
            f"FILENAME_PLACEHOLDER\n\n"
            f"ğŸ’¾ æ–‡ä»¶å¤§å°: {total_size_mb:.2f} MB\n"
            f"ğŸ“Š é›†æ•°: {file_count} é›†\n"
            f"ğŸ–¼ï¸ åˆ†è¾¨ç‡: {resolution_display}\n"
            f"ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}"
        )

        # è®¡ç®—é™¤æ–‡ä»¶ååˆ—è¡¨å¤–çš„æ¶ˆæ¯é•¿åº¦
        other_parts_length = len(other_parts) - len("FILENAME_PLACEHOLDER")

        # å¯ç”¨äºæ–‡ä»¶ååˆ—è¡¨çš„æœ€å¤§é•¿åº¦
        available_length = MAX_MESSAGE_LENGTH - other_parts_length - 100  # ç•™100å­—ç¬¦ç¼“å†²

        lines = filename_display.split('\n')

        # å¦‚æœåŸå§‹æ–‡ä»¶ååˆ—è¡¨ä¸è¶…è¿‡å¯ç”¨é•¿åº¦ï¼Œç›´æ¥è¿”å›
        if len(filename_display) <= available_length:
            return filename_display

        # éœ€è¦æˆªæ–­ï¼Œæ‰¾åˆ°èƒ½æ˜¾ç¤ºçš„æœ€å¤§æ–‡ä»¶æ•°é‡
        result_lines = []
        current_length = 0

        # çœç•¥æç¤ºçš„æ¨¡æ¿
        omit_template = "  ... (çœç•¥ {} ä¸ªæ–‡ä»¶ï¼Œå—é™äºTGæ¶ˆæ¯é™åˆ¶ï¼Œå®Œæ•´æ–‡ä»¶åˆ—è¡¨è¯·åˆ°ä¸‹è½½ç›®å½•æŸ¥çœ‹) ..."

        for i, line in enumerate(lines):
            # è®¡ç®—åŠ ä¸Šè¿™ä¸€è¡Œå’Œå¯èƒ½çš„çœç•¥æç¤ºåçš„æ€»é•¿åº¦
            remaining_files = len(lines) - i - 1
            if remaining_files > 0:
                omit_text = omit_template.format(remaining_files)
                projected_length = current_length + len(line) + 1 + len(omit_text)  # +1 for newline
            else:
                projected_length = current_length + len(line)

            # å¦‚æœåŠ ä¸Šè¿™ä¸€è¡Œä¼šè¶…è¿‡é™åˆ¶
            if projected_length > available_length:
                # å¦‚æœè¿˜æœ‰å‰©ä½™æ–‡ä»¶ï¼Œæ·»åŠ çœç•¥æç¤º
                if remaining_files > 0:
                    omit_text = omit_template.format(remaining_files)
                    result_lines.append(omit_text)
                break
            else:
                # å¯ä»¥æ·»åŠ è¿™ä¸€è¡Œ
                result_lines.append(line)
                current_length = projected_length

        return '\n'.join(result_lines)

    def _rename_bilibili_file_from_full_title(self, filename):
        """
        ä»å®Œæ•´æ ‡é¢˜æ–‡ä»¶åé‡å‘½åä¸ºç®€æ´çš„pxxæ ¼å¼

        ä¾‹å¦‚ï¼š
        è¾“å…¥: å°šç¡…è°·Cursorä½¿ç”¨æ•™ç¨‹ï¼Œ2å°æ—¶ç©è½¬cursor p01 01-Cursoræ•™ç¨‹ç®€ä»‹.mp4
        è¾“å‡º: p01 01-Cursoræ•™ç¨‹ç®€ä»‹.mp4

        Args:
            filename: ä¸‹è½½å®Œæˆçš„æ–‡ä»¶è·¯å¾„ï¼ˆåŒ…å«å®Œæ•´æ ‡é¢˜ï¼‰
        """
        import re
        from pathlib import Path

        try:
            file_path = Path(filename)
            if not file_path.exists():
                logger.warning(f"âš ï¸ æ–‡ä»¶ä¸å­˜åœ¨: {filename}")
                return

            file_name = file_path.name
            file_ext = file_path.suffix
            title_without_ext = file_path.stem

            logger.info(f"ğŸ” å¤„ç†å®Œæ•´æ ‡é¢˜æ–‡ä»¶: {file_name}")

            # ä½¿ç”¨æ™ºèƒ½å¤„ç†é€»è¾‘æå–pxxéƒ¨åˆ†
            processed_title = self._process_bilibili_multipart_title(title_without_ext)

            if processed_title != title_without_ext:
                # æ ‡é¢˜è¢«å¤„ç†äº†ï¼Œè¯´æ˜æ‰¾åˆ°äº†pxxéƒ¨åˆ†
                safe_title = self._sanitize_filename(processed_title)
                new_file_path = file_path.parent / f"{safe_title}{file_ext}"

                logger.info(f"ğŸ¯ ç®€æ´æ–‡ä»¶å: {safe_title}{file_ext}")

                # æ‰§è¡Œé‡å‘½å
                if file_path != new_file_path:
                    try:
                        file_path.rename(new_file_path)
                        logger.info(f"âœ… æ™ºèƒ½é‡å‘½åæˆåŠŸ: {file_name} -> {safe_title}{file_ext}")
                    except Exception as e:
                        logger.warning(f"âš ï¸ é‡å‘½åå¤±è´¥: {e}")
                else:
                    logger.info(f"ğŸ“ æ–‡ä»¶åå·²æ˜¯ç®€æ´æ ¼å¼: {safe_title}{file_ext}")
            else:
                logger.info(f"ğŸ“ æœªæ‰¾åˆ°pxxæ¨¡å¼ï¼Œä¿æŒåŸæ–‡ä»¶å: {file_name}")

        except Exception as e:
            logger.error(f"âŒ å¤„ç†æ–‡ä»¶åå¤±è´¥: {e}")

    def _get_processed_filename_for_display(self, filename):
        """
        è·å–ç”¨äºæ˜¾ç¤ºçš„å¤„ç†åæ–‡ä»¶å

        è¿™ä¸ªå‡½æ•°ç”¨äºåœ¨ä¸‹è½½è¿›åº¦ä¸­æ˜¾ç¤ºç”¨æˆ·å‹å¥½çš„æ–‡ä»¶åï¼Œ
        è€Œä¸æ˜¯æŠ€æœ¯æ€§çš„ä¸´æ—¶æ–‡ä»¶å

        Args:
            filename: åŸå§‹æ–‡ä»¶å

        Returns:
            str: å¤„ç†åçš„æ˜¾ç¤ºæ–‡ä»¶å
        """
        import re
        from pathlib import Path

        try:
            file_path = Path(filename)
            file_name = file_path.name
            file_ext = file_path.suffix

            # å¦‚æœæ˜¯ä¸´æ—¶æ ¼å¼æ–‡ä»¶ï¼Œå°è¯•æ¨å¯¼æœ€ç»ˆæ–‡ä»¶å
            if self._is_temp_format_file(filename):
                # ä»ä¸´æ—¶æ–‡ä»¶åæ¨å¯¼è§†é¢‘ID
                # ä¾‹å¦‚ï¼šBV1aDMezREUj_p1.f100026.mp4 -> BV1aDMezREUj_p1
                raw_video_id = file_path.stem
                video_id = re.sub(r'\.f\d+.*$', '', raw_video_id)

                # å°è¯•ä»ç¼“å­˜çš„æ ‡é¢˜ä¿¡æ¯è·å–å¤„ç†åçš„æ–‡ä»¶å
                # è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªç®€åŒ–çš„æ–¹æ³•ï¼šç›´æ¥æ˜¾ç¤ºè§†é¢‘ID
                if "_p" in video_id:
                    # å¤šPè§†é¢‘ï¼šæ˜¾ç¤ºåˆ†é›†ä¿¡æ¯
                    parts = video_id.split("_p")
                    part_num = parts[1]
                    return f"p{part_num.zfill(2)} ä¸‹è½½ä¸­...{file_ext}"
                else:
                    # å•Pè§†é¢‘
                    return f"è§†é¢‘ä¸‹è½½ä¸­...{file_ext}"
            else:
                # å¦‚æœæ˜¯æœ€ç»ˆæ–‡ä»¶ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦å¤„ç†æ ‡é¢˜
                # è¿™é‡Œæˆ‘ä»¬å‡è®¾æ–‡ä»¶åå¯èƒ½åŒ…å«å®Œæ•´çš„æ ‡é¢˜
                if any(keyword in file_name for keyword in ["å°šç¡…è°·", "æ•™ç¨‹", "è¯¾ç¨‹"]):
                    # å°è¯•æå–pxxéƒ¨åˆ†
                    pattern = r'p(\d{1,3})\s+'
                    match = re.search(pattern, file_name, re.IGNORECASE)
                    if match:
                        # æ‰¾åˆ°pxxï¼Œå°è¯•æå–åç»­å†…å®¹
                        start_pos = match.start()
                        remaining = file_name[start_pos:]
                        # ç®€åŒ–å¤„ç†ï¼šåªå–å‰50ä¸ªå­—ç¬¦
                        if len(remaining) > 50:
                            remaining = remaining[:47] + "..."
                        return remaining

                # é»˜è®¤è¿”å›åŸæ–‡ä»¶å
                return file_name

        except Exception as e:
            logger.debug(f"å¤„ç†æ˜¾ç¤ºæ–‡ä»¶åå¤±è´¥: {e}")
            return Path(filename).name

    def _rename_bilibili_file_immediately(self, filename):
        """
        ç«‹å³é‡å‘½åBç«™å¤šPæ–‡ä»¶ï¼ˆåŸºäºæ‚¨çš„ä¼˜ç§€å»ºè®®çš„Pythonå®ç°ï¼‰

        åœ¨æ¯ä¸ªæ–‡ä»¶ä¸‹è½½å®Œæˆæ—¶ç«‹å³æ‰§è¡Œé‡å‘½åï¼Œé¿å…æ‰¹é‡å¤„ç†

        Args:
            filename: ä¸‹è½½å®Œæˆçš„æ–‡ä»¶è·¯å¾„
        """
        import re
        import os
        from pathlib import Path

        try:
            file_path = Path(filename)
            if not file_path.exists():
                logger.warning(f"âš ï¸ æ–‡ä»¶ä¸å­˜åœ¨: {filename}")
                return

            file_name = file_path.name
            file_ext = file_path.suffix
            raw_video_id = file_path.stem

            logger.info(f"ğŸ” åˆ†ææ–‡ä»¶: {file_name}")
            logger.info(f"ğŸ“ åŸå§‹è§†é¢‘ID: {raw_video_id}")

            # æ¸…ç†è§†é¢‘IDï¼Œå»é™¤æ ¼å¼ä»£ç 
            # ä¾‹å¦‚ï¼šBV1aDMezREUj_p2.f100026 -> BV1aDMezREUj_p2
            video_id = re.sub(r'\.f\d+.*$', '', raw_video_id)
            logger.info(f"ğŸ§¹ æ¸…ç†åè§†é¢‘ID: {video_id}")

            # æ„å»ºURLï¼ˆä»æ–‡ä»¶åæ¨å¯¼ï¼‰
            if "_p" in video_id:
                # å¤šPè§†é¢‘æ ¼å¼ï¼šBV1aDMezREUj_p1
                parts = video_id.split("_p")
                bv_id = parts[0]
                part_num = parts[1]
                video_url = f"https://www.bilibili.com/video/{bv_id}?p={part_num}"
            else:
                # å•Pè§†é¢‘æ ¼å¼ï¼šBV1aDMezREUj
                video_url = f"https://www.bilibili.com/video/{video_id}"

            logger.info(f"ğŸ”— æ„å»ºURL: {video_url}")

            # ä½¿ç”¨yt-dlpè·å–å®Œæ•´æ ‡é¢˜
            try:
                import subprocess
                result = subprocess.run(
                    ["yt-dlp", "--get-title", "--skip-download", video_url],
                    capture_output=True,
                    text=True,
                    timeout=30
                )

                if result.returncode == 0 and result.stdout.strip():
                    full_title = result.stdout.strip()
                    logger.info(f"ğŸ“‹ è·å–æ ‡é¢˜: {full_title}")

                    # æå–pxxåŠåç»­å†…å®¹
                    pattern = r'p(\d{1,3}).*'
                    match = re.search(pattern, full_title, re.IGNORECASE)

                    if match:
                        # ä»pxxå¼€å§‹æˆªå–
                        start_pos = match.start()
                        new_name = full_title[start_pos:]

                        # æ¸…ç†æ–‡ä»¶åä¸­çš„ç‰¹æ®Šå­—ç¬¦
                        new_name = re.sub(r'[\\/:*?"<>|ã€ã€‘ï½œ]', '_', new_name)
                        new_name = re.sub(r'\s+', ' ', new_name).strip()

                        new_file_path = file_path.parent / f"{new_name}{file_ext}"

                        logger.info(f"ğŸ¯ æ–°æ–‡ä»¶å: {new_name}{file_ext}")

                        # æ‰§è¡Œé‡å‘½å
                        if file_path != new_file_path:
                            file_path.rename(new_file_path)
                            logger.info(f"âœ… æ™ºèƒ½é‡å‘½åæˆåŠŸ: {file_name} -> {new_name}{file_ext}")
                        else:
                            logger.info(f"ğŸ“ æ–‡ä»¶åå·²æ­£ç¡®: {new_name}{file_ext}")
                    else:
                        logger.warning(f"âš ï¸ æœªæ‰¾åˆ°pxxæ¨¡å¼ï¼Œä¿æŒåŸæ–‡ä»¶å: {file_name}")
                else:
                    logger.warning(f"âš ï¸ æ— æ³•è·å–æ ‡é¢˜ï¼Œä¿æŒåŸæ–‡ä»¶å: {file_name}")
                    logger.warning(f"yt-dlpé”™è¯¯: {result.stderr}")

            except subprocess.TimeoutExpired:
                logger.warning(f"âš ï¸ è·å–æ ‡é¢˜è¶…æ—¶ï¼Œä¿æŒåŸæ–‡ä»¶å: {file_name}")
            except Exception as e:
                logger.warning(f"âš ï¸ è·å–æ ‡é¢˜å¤±è´¥: {e}ï¼Œä¿æŒåŸæ–‡ä»¶å: {file_name}")

        except Exception as e:
            logger.error(f"âŒ é‡å‘½åæ–‡ä»¶å¤±è´¥: {e}")

    def _rename_bilibili_multipart_files(self, download_path, expected_files):
        """
        é‡å‘½åBç«™å¤šPä¸‹è½½çš„æ–‡ä»¶ï¼Œä½¿å…¶åŒ¹é…é¢„æœŸæ–‡ä»¶å

        Args:
            download_path: ä¸‹è½½ç›®å½•è·¯å¾„
            expected_files: é¢„æœŸæ–‡ä»¶åˆ—è¡¨
        """
        import os
        from pathlib import Path

        logger.info(f"ğŸ”„ å¼€å§‹é‡å‘½åBç«™å¤šPæ–‡ä»¶ï¼Œç›®å½•: {download_path}")
        logger.info(f"ğŸ“‹ é¢„æœŸæ–‡ä»¶æ•°é‡: {len(expected_files)}")

        # è·å–ç›®å½•ä¸­æ‰€æœ‰è§†é¢‘æ–‡ä»¶
        video_extensions = ["*.mp4", "*.mkv", "*.webm", "*.avi", "*.mov", "*.flv"]
        all_video_files = []
        for ext in video_extensions:
            all_video_files.extend(list(Path(download_path).glob(ext)))

        logger.info(f"ğŸ“ æ‰¾åˆ°è§†é¢‘æ–‡ä»¶æ•°é‡: {len(all_video_files)}")

        renamed_count = 0
        for expected_file in expected_files:
            expected_filename = expected_file['filename']
            original_title = expected_file['title']

            # æŸ¥æ‰¾åŒ¹é…çš„å®é™…æ–‡ä»¶
            for actual_file in all_video_files:
                actual_filename = actual_file.name

                # ä½¿ç”¨æ™ºèƒ½åŒ¹é…é€»è¾‘æ£€æŸ¥æ˜¯å¦åŒ¹é…
                def clean_filename_for_matching(filename):
                    """æ¸…ç†æ–‡ä»¶åç”¨äºåŒ¹é…"""
                    import re
                    if not filename:
                        return ""

                    # åˆ é™¤yt-dlpçš„å„ç§æ ¼å¼ä»£ç 
                    cleaned = re.sub(r'\.[fm]\d+(\+\d+)*', '', filename)
                    cleaned = re.sub(r'\.f\d+', '', cleaned)

                    # åˆ é™¤YouTubeè§†é¢‘IDæ ‡è¯†ï¼ˆä»…åœ¨å¯ç”¨IDæ ‡ç­¾æ—¶ï¼‰
                    if hasattr(self, 'bot') and hasattr(self.bot, 'youtube_id_tags') and self.bot.youtube_id_tags:
                        cleaned = re.sub(r'\[[a-zA-Z0-9_-]{10,12}\]', '', cleaned)

                    cleaned = re.sub(r'\.(webm|m4a|mp3)$', '.mp4', cleaned)
                    cleaned = re.sub(r'\.(webm|m4a|mp3)\.mp4$', '.mp4', cleaned)

                    # åˆ é™¤åºå·å‰ç¼€
                    cleaned = re.sub(r'^\d+\.\s*', '', cleaned)

                    # å¯¹Bç«™å¤šPæ ‡é¢˜è¿›è¡Œæ™ºèƒ½å¤„ç†
                    pattern = r'\s+[pP](\d{1,3})\s+'
                    match = re.search(pattern, cleaned)
                    if match:
                        start_pos = match.start() + 1
                        cleaned = cleaned[start_pos:]

                    # ç»Ÿä¸€ç‰¹æ®Šå­—ç¬¦ï¼ˆè§£å†³å…¨è§’/åŠè§’å·®å¼‚ï¼‰
                    # å°†å„ç§ç«–çº¿ç»Ÿä¸€ä¸ºä¸‹åˆ’çº¿ï¼Œä¸_sanitize_filenameä¿æŒä¸€è‡´
                    cleaned = re.sub(r'[|ï½œ]', '_', cleaned)
                    # ç»Ÿä¸€å…¶ä»–ç‰¹æ®Šå­—ç¬¦
                    cleaned = re.sub(r'[ã€ã€‘]', '_', cleaned)

                    # ç¡®ä¿ä»¥ .mp4 ç»“å°¾
                    if not cleaned.endswith('.mp4'):
                        cleaned = cleaned.rstrip('.') + '.mp4'

                    return cleaned

                cleaned_actual = clean_filename_for_matching(actual_filename)
                cleaned_expected = clean_filename_for_matching(expected_filename)

                if cleaned_actual == cleaned_expected:
                    # æ‰¾åˆ°åŒ¹é…çš„æ–‡ä»¶ï¼Œè¿›è¡Œé‡å‘½å
                    new_file_path = actual_file.parent / expected_filename

                    if actual_file != new_file_path:  # é¿å…é‡å‘½åä¸ºç›¸åŒåç§°
                        try:
                            actual_file.rename(new_file_path)
                            logger.info(f"âœ… é‡å‘½åæˆåŠŸ: {actual_filename} -> {expected_filename}")
                            renamed_count += 1
                        except Exception as e:
                            logger.warning(f"âš ï¸ é‡å‘½åå¤±è´¥: {actual_filename} -> {expected_filename}, é”™è¯¯: {e}")
                    else:
                        logger.info(f"ğŸ“ æ–‡ä»¶åå·²æ­£ç¡®: {expected_filename}")
                        renamed_count += 1
                    break
            else:
                logger.warning(f"âš ï¸ æœªæ‰¾åˆ°åŒ¹é…æ–‡ä»¶: {expected_filename}")

        logger.info(f"ğŸ‰ é‡å‘½åå®Œæˆ: {renamed_count}/{len(expected_files)} ä¸ªæ–‡ä»¶")

    def _process_bilibili_multipart_title(self, title):
        """
        æ™ºèƒ½å¤„ç†Bç«™å¤šPè§†é¢‘æ ‡é¢˜ï¼Œå»é™¤pxxå‰é¢çš„å†—é•¿å†…å®¹

        ä¾‹å¦‚ï¼š
        è¾“å…¥: "3å°æ—¶è¶…å¿«é€Ÿå…¥é—¨Python | åŠ¨ç”»æ•™å­¦ã€2025æ–°ç‰ˆã€‘ã€è‡ªå­¦Pythonæ•™ç¨‹ã€‘ã€é›¶åŸºç¡€Pythonã€‘ã€è®¡ç®—æœºäºŒçº§Pythonã€‘ã€PythonæœŸæœ«é€Ÿæˆã€‘ p01 å…ˆå¯¼ç¯‡ | ä¸ºä»€ä¹ˆåšè¿™ä¸ªæ•™ç¨‹"
        è¾“å‡º: "p01 å…ˆå¯¼ç¯‡ | ä¸ºä»€ä¹ˆåšè¿™ä¸ªæ•™ç¨‹"
        """
        if not title:
            return title

        import re

        # æŸ¥æ‰¾ pxx æ¨¡å¼ï¼ˆp + æ•°å­—ï¼‰
        # æ”¯æŒ p01, p1, P01, P1 ç­‰æ ¼å¼
        pattern = r'\s+[pP](\d{1,3})\s+'
        match = re.search(pattern, title)

        if match:
            # æ‰¾åˆ° pxxï¼Œä» pxx å¼€å§‹æˆªå–
            start_pos = match.start() + 1  # +1 æ˜¯ä¸ºäº†è·³è¿‡å‰é¢çš„ç©ºæ ¼
            processed_title = title[start_pos:]
            logger.info(f"ğŸ”§ Bç«™å¤šPæ ‡é¢˜å¤„ç†: '{title}' -> '{processed_title}'")
            return processed_title
        else:
            # æ²¡æœ‰æ‰¾åˆ° pxx æ¨¡å¼ï¼Œè¿”å›åŸæ ‡é¢˜
            return title

    def _basic_sanitize_filename(self, filename):
        """
        åŸºæœ¬çš„æ–‡ä»¶åæ¸…ç†ï¼Œä¸yt-dlpä¿æŒä¸€è‡´
        åªæ›¿æ¢æ–‡ä»¶ç³»ç»Ÿä¸æ”¯æŒçš„å­—ç¬¦ï¼Œä¿ç•™å…¶ä»–å­—ç¬¦

        æ³¨æ„ï¼šè¿™ä¸ªå‡½æ•°éœ€è¦å®Œå…¨æ¨¡æ‹Ÿyt-dlpçš„å­—ç¬¦å¤„ç†è¡Œä¸º
        """
        if not filename:
            return "video"

        # yt-dlpçš„å­—ç¬¦å¤„ç†è§„åˆ™ï¼ˆåŸºäºè§‚å¯Ÿåˆ°çš„å®é™…è¡Œä¸ºï¼‰ï¼š
        # 1. åŠè§’ | è½¬æ¢ä¸ºå…¨è§’ ï½œ
        filename = filename.replace('|', 'ï½œ')

        # 2. æ–œæ  / è½¬æ¢ä¸ºå¤§æ–œæ ç¬¦å· â§¸ ï¼ˆè¿™æ˜¯yt-dlpçš„å®é™…è¡Œä¸ºï¼‰
        filename = filename.replace('/', 'â§¸')

        # 3. åªæ›¿æ¢æ–‡ä»¶ç³»ç»Ÿç»å¯¹ä¸æ”¯æŒçš„å­—ç¬¦
        # ä¿ç•™ ï½œ ã€ã€‘ â§¸ ç­‰å­—ç¬¦ï¼Œå› ä¸ºyt-dlpä¹Ÿä¼šä¿ç•™å®ƒä»¬
        filename = re.sub(r'[\\:*?"<>]', '_', filename)

        # 3. å»é™¤å¤šä½™ç©ºæ ¼
        filename = re.sub(r'\s+', ' ', filename).strip()

        # 4. å»é™¤å¼€å¤´å’Œç»“å°¾çš„ä¸‹åˆ’çº¿å’Œç©ºæ ¼
        filename = re.sub(r'^[_\s]+|[_\s]+$', '', filename)

        # ç¡®ä¿æ–‡ä»¶åä¸ä¸ºç©º
        if not filename or filename.isspace():
            filename = "video"

        return filename

    def _detect_part_files(self, download_path):
        """æ£€æµ‹PARTæ–‡ä»¶"""
        from pathlib import Path
        part_files = list(Path(download_path).rglob("*.part"))
        return part_files

    def _analyze_failure_reason(self, part_file):
        """åˆ†æPARTæ–‡ä»¶å¤±è´¥åŸå› """
        try:
            file_size = part_file.stat().st_size
            if file_size == 0:
                return "ä¸‹è½½æœªå¼€å§‹æˆ–ç«‹å³å¤±è´¥"
            elif file_size < 1024 * 1024:  # < 1MB
                return "ä¸‹è½½åˆšå¼€å§‹å°±ä¸­æ–­ï¼Œå¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜"
            elif file_size < 10 * 1024 * 1024:  # < 10MB
                return "ä¸‹è½½è¿›è¡Œä¸­è¢«ä¸­æ–­ï¼Œå¯èƒ½æ˜¯ç½‘ç»œé—®é¢˜"
            else:
                return "ä¸‹è½½è¿›è¡Œä¸­è¢«ä¸­æ–­ï¼Œå¯èƒ½æ˜¯ç½‘ç»œæˆ–ç£ç›˜é—®é¢˜"
        except Exception:
            return "æ— æ³•åˆ†æå¤±è´¥åŸå› "

    def _log_part_files_details(self, part_files):
        """åœ¨æ—¥å¿—ä¸­è®°å½•PARTæ–‡ä»¶è¯¦ç»†ä¿¡æ¯"""
        if part_files:
            logger.warning(f"âš ï¸ å‘ç° {len(part_files)} ä¸ªæœªå®Œæˆçš„PARTæ–‡ä»¶")
            logger.warning("âš ï¸ æœªå®Œæˆçš„æ–‡ä»¶åˆ—è¡¨ï¼š")
            for part_file in part_files:
                reason = self._analyze_failure_reason(part_file)
                logger.warning(f"   - {part_file.name} ({reason})")
        else:
            logger.info("âœ… æœªå‘ç°PARTæ–‡ä»¶ï¼Œæ‰€æœ‰ä¸‹è½½éƒ½å·²å®Œæˆ")

    def _get_enhanced_ydl_opts(self, base_opts=None):
        """è·å–å¢å¼ºçš„yt-dlpé…ç½®ï¼Œé¿å…PARTæ–‡ä»¶äº§ç”Ÿ"""
        enhanced_opts = {
            # åŸºç¡€é…ç½®
            'quiet': False,
            'no_warnings': False,

            # ç½‘ç»œå’Œé‡è¯•é…ç½® - é¿å…ç½‘ç»œä¸­æ–­å¯¼è‡´çš„PARTæ–‡ä»¶
            'socket_timeout': 60,           # å¢åŠ è¶…æ—¶æ—¶é—´åˆ°60ç§’
            'retries': 10,                  # å¢åŠ é‡è¯•æ¬¡æ•°
            'fragment_retries': 10,         # åˆ†ç‰‡é‡è¯•æ¬¡æ•°
            'retry_sleep_functions': {      # é‡è¯•é—´éš”é…ç½®
                'http': lambda n: min(5 * (2 ** n), 60),  # æŒ‡æ•°é€€é¿ï¼Œæœ€å¤§60ç§’
                'fragment': lambda n: min(2 * (2 ** n), 30),  # åˆ†ç‰‡é‡è¯•é—´éš”
            },

            # é˜²æ­¢YouTubeé™æµçš„é…ç½®
            'sleep_interval': 2,            # æ¯ä¸ªè§†é¢‘ä¹‹é—´ç­‰å¾…2ç§’
            'max_sleep_interval': 5,        # æœ€å¤§ç­‰å¾…5ç§’
            'sleep_interval_requests': 1,   # æ¯ä¸ªè¯·æ±‚ä¹‹é—´ç­‰å¾…1ç§’

            # åœ°ç†å’Œå¹´é¾„é™åˆ¶ç»•è¿‡é…ç½®
            'age_limit': 99,                # ç»•è¿‡å¹´é¾„é™åˆ¶
            'geo_bypass': True,             # å°è¯•ç»•è¿‡åœ°ç†é™åˆ¶
            'geo_bypass_country': 'US',     # ä½¿ç”¨ç¾å›½ä½œä¸ºç»•è¿‡å›½å®¶
            # ğŸ¯ å®Œå…¨æ¢å¤v0.4-dev3æ–¹å¼ï¼šç§»é™¤æ‰€æœ‰extractor_argsï¼Œä½¿ç”¨yt-dlpé»˜è®¤é…ç½®
            # v0.4-dev3ç‰ˆæœ¬æ²¡æœ‰extractor_argsï¼Œè¿™æ˜¯å®ƒæˆåŠŸçš„å…³é”®ï¼

            # ğŸ¯ ä¿®å¤ï¼šä¸‹è½½é…ç½® - ä¼˜å…ˆé«˜è´¨é‡ï¼Œå…è®¸è·³è¿‡ä¸å¯ç”¨åˆ†ç‰‡
            'skip_unavailable_fragments': True,   # è·³è¿‡ä¸å¯ç”¨åˆ†ç‰‡ï¼Œå…è®¸ä¸‹è½½é«˜è´¨é‡è§†é¢‘
            'abort_on_unavailable_fragment': False,  # å…è®¸éƒ¨åˆ†åˆ†ç‰‡å¤±è´¥ï¼Œæ”¯æŒæ–­ç‚¹ç»­ä¼ 
            'keep_fragments': False,        # ä¸ä¿ç•™åˆ†ç‰‡ï¼Œé¿å…ä¸´æ—¶æ–‡ä»¶å †ç§¯
            'continue_dl': True,            # å¯ç”¨æ–­ç‚¹ç»­ä¼ 
            'part': True,                   # å…è®¸ç”Ÿæˆ.partæ–‡ä»¶ç”¨äºæ–­ç‚¹ç»­ä¼ 
            'mtime': True,                  # ä¿æŒæ–‡ä»¶ä¿®æ”¹æ—¶é—´ï¼Œæœ‰åŠ©äºæ–­ç‚¹ç»­ä¼ 

            # åˆå¹¶é…ç½® - ç¡®ä¿åˆå¹¶æˆåŠŸ
            'merge_output_format': 'mp4',   # å¼ºåˆ¶åˆå¹¶ä¸ºmp4
            'postprocessor_args': {         # åå¤„ç†å‚æ•°
                'ffmpeg': ['-y']            # ffmpegå¼ºåˆ¶è¦†ç›–è¾“å‡ºæ–‡ä»¶
            },

            # ğŸ¯ ä¿®å¤ï¼šæ·»åŠ é«˜è´¨é‡ä¸‹è½½çš„å…³é”®é…ç½®ï¼ˆä¸å•ç‹¬ä¸‹è½½ä¿æŒä¸€è‡´ï¼‰
            'hls_use_mpegts': False,        # ä½¿ç”¨mp4å®¹å™¨è€Œä¸æ˜¯ts
            'hls_prefer_native': True,      # ä¼˜å…ˆä½¿ç”¨åŸç”ŸHLSä¸‹è½½å™¨
            'concurrent_fragment_downloads': 3,  # å¹¶å‘ä¸‹è½½åˆ†ç‰‡æ•°é‡
            'buffersize': 1024,             # ç¼“å†²åŒºå¤§å°
            'http_chunk_size': 10485760,    # 10MBåˆ†å—å¤§å°

            # é”™è¯¯å¤„ç†é…ç½® - æ³¨æ„ï¼šbase_opts ä¸­çš„ ignoreerrors ä¼šè¦†ç›–è¿™ä¸ªè®¾ç½®
            'abort_on_error': False,        # å•ä¸ªæ–‡ä»¶é”™è¯¯æ—¶ä¸ä¸­æ­¢æ•´ä¸ªä¸‹è½½

            # ä¸´æ—¶æ–‡ä»¶é…ç½®
            'writeinfojson': False,         # ä¸å†™å…¥info.jsonï¼Œå‡å°‘ä¸´æ—¶æ–‡ä»¶
            'writesubtitles': False,        # ä¸ä¸‹è½½å­—å¹•ï¼Œå‡å°‘å¤æ‚æ€§
            'writeautomaticsub': False,     # ä¸ä¸‹è½½è‡ªåŠ¨å­—å¹•
        }

        # åˆå¹¶åŸºç¡€é…ç½®
        if base_opts:
            logger.info(f"ğŸ”§ [ENHANCED_OPTS] åˆå¹¶å‰progress_hooks: {enhanced_opts.get('progress_hooks', [])}")
            logger.info(f"ğŸ”§ [ENHANCED_OPTS] base_optsä¸­çš„progress_hooks: {base_opts.get('progress_hooks', [])}")
            enhanced_opts.update(base_opts)
            logger.info(f"ğŸ”§ [ENHANCED_OPTS] åˆå¹¶åprogress_hooks: {len(enhanced_opts.get('progress_hooks', []))} ä¸ªå›è°ƒ")

        # ğŸ¯ çœŸæ­£ä¿®å¤ï¼šæ¢å¤v0.4-dev3æˆåŠŸæ–¹å¼ - ä¸è®¾ç½®é»˜è®¤formatï¼Œè®©yt-dlpä½¿ç”¨åŸç”Ÿ"best"
        # v0.4-dev3ç‰ˆæœ¬æ²¡æœ‰è®¾ç½®é»˜è®¤formatï¼Œè¿™æ˜¯å®ƒèƒ½ä¸‹è½½æœ€é«˜æ¸…è§†é¢‘çš„å…³é”®ï¼
        # ä¸è®¾ç½®formatï¼Œè®©yt-dlpè‡ªå·±é€‰æ‹©æœ€ä½³æ ¼å¼

        # æ·»åŠ ä»£ç†é…ç½®
        if self.proxy_host:
            enhanced_opts['proxy'] = self.proxy_host

        # æ·»åŠ cookiesé…ç½® - æ³¨æ„ï¼šè¿™é‡Œæ— æ³•åˆ¤æ–­URLç±»å‹ï¼Œæ‰€ä»¥ä¼˜å…ˆä½¿ç”¨YouTube cookies
        # å®é™…çš„URLç‰¹å®šcookiesåº”è¯¥åœ¨è°ƒç”¨æ–¹å¤„ç†
        if hasattr(self, 'youtube_cookies_path') and self.youtube_cookies_path and os.path.exists(self.youtube_cookies_path):
            enhanced_opts['cookiefile'] = self.youtube_cookies_path
        elif hasattr(self, 'x_cookies_path') and self.x_cookies_path and os.path.exists(self.x_cookies_path):
            enhanced_opts['cookiefile'] = self.x_cookies_path

        return enhanced_opts

    def _add_danmaku_options(self, ydl_opts, url):
        """ä¸ºBç«™URLæ·»åŠ å¼¹å¹•ä¸‹è½½é€‰é¡¹"""
        if not self.is_bilibili_url(url):
            return ydl_opts

        # æ£€æŸ¥æ˜¯å¦å¯ç”¨äº†Bç«™å¼¹å¹•ä¸‹è½½
        if hasattr(self, 'bot') and hasattr(self.bot, 'bilibili_danmaku_download') and self.bot.bilibili_danmaku_download:
            logger.info("ğŸ­ å¯ç”¨Bç«™å¼¹å¹•ä¸‹è½½")

            # æ·»åŠ å¼¹å¹•ä¸‹è½½é€‰é¡¹
            ydl_opts.update({
                'writesubtitles': True,  # ä¸‹è½½å­—å¹•
                'writeautomaticsub': False,  # ä¸ä¸‹è½½è‡ªåŠ¨ç”Ÿæˆçš„å­—å¹•
                'subtitlesformat': 'danmaku',  # å¼¹å¹•æ ¼å¼
                'postprocessors': ydl_opts.get('postprocessors', []) + [
                    {
                        'key': 'danmaku',  # ä½¿ç”¨danmakuåå¤„ç†å™¨
                    }
                ],
                'postprocessor_args': {
                    'danmaku': ['filename=%(title)s.ass']  # ç›´æ¥æŒ‡å®šå¼¹å¹•æ–‡ä»¶åï¼Œå»æ‰.danmakuåç¼€
                }
            })

            logger.info("âœ… å·²æ·»åŠ å¼¹å¹•ä¸‹è½½é…ç½®")
        else:
            logger.info("ğŸ“ Bç«™å¼¹å¹•ä¸‹è½½å·²å…³é—­")

        return ydl_opts


    def _resume_part_files(self, download_path, original_url):
        """æ–­ç‚¹ç»­ä¼ PARTæ–‡ä»¶"""
        from pathlib import Path
        part_files = self._detect_part_files(download_path)
        resumed_count = 0

        if not part_files:
            return 0

        logger.info(f"ğŸ”„ å‘ç° {len(part_files)} ä¸ªPARTæ–‡ä»¶ï¼Œå°è¯•æ–­ç‚¹ç»­ä¼ ")

        for part_file in part_files:
            try:
                # è·å–PARTæ–‡ä»¶ä¿¡æ¯
                file_size = part_file.stat().st_size
                logger.info(f"ğŸ“¥ æ–­ç‚¹ç»­ä¼ : {part_file.name} (å·²ä¸‹è½½: {file_size / (1024*1024):.1f}MB)")

                # ä½¿ç”¨yt-dlpçš„æ–­ç‚¹ç»­ä¼ åŠŸèƒ½
                # æ ¹æ®è®¾ç½®å†³å®šæ–‡ä»¶åæ¨¡æ¿
                if hasattr(self, 'bot') and hasattr(self.bot, 'youtube_id_tags') and self.bot.youtube_id_tags and self.is_youtube_url(original_url):
                    outtmpl = str(download_path / '%(title)s[%(id)s].%(ext)s')
                else:
                    outtmpl = str(download_path / '%(title)s.%(ext)s')

                resume_opts = self._get_enhanced_ydl_opts({
                    'outtmpl': outtmpl,
                    'format': 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best',
                    'continue_dl': True,  # å¯ç”¨æ–­ç‚¹ç»­ä¼ 
                    'part': True,         # å…è®¸PARTæ–‡ä»¶
                })

                import yt_dlp
                with yt_dlp.YoutubeDL(resume_opts) as ydl:
                    ydl.download([original_url])

                resumed_count += 1
                logger.info(f"âœ… æ–­ç‚¹ç»­ä¼ æˆåŠŸ: {part_file.name}")

            except Exception as e:
                logger.warning(f"âš ï¸ æ–­ç‚¹ç»­ä¼ å¤±è´¥: {part_file.name}, é”™è¯¯: {e}")
                # å¦‚æœæ–­ç‚¹ç»­ä¼ å¤±è´¥ï¼Œå¯ä»¥é€‰æ‹©åˆ é™¤PARTæ–‡ä»¶é‡æ–°ä¸‹è½½
                try:
                    logger.info(f"ğŸ—‘ï¸ åˆ é™¤æŸåçš„PARTæ–‡ä»¶: {part_file.name}")
                    part_file.unlink()
                except Exception as del_e:
                    logger.warning(f"âš ï¸ åˆ é™¤PARTæ–‡ä»¶å¤±è´¥: {del_e}")

        if resumed_count > 0:
            logger.info(f"âœ… æˆåŠŸæ–­ç‚¹ç»­ä¼  {resumed_count} ä¸ªæ–‡ä»¶")

        return resumed_count

    def smart_download_bilibili_for_ugc(self, url, download_path, progress_callback=None, auto_playlist=False):
        """UGCåˆé›†ä¸“ç”¨çš„Bç«™ä¸‹è½½å™¨ï¼Œå¼ºåˆ¶ä¸‹è½½å•è§†é¢‘è€Œä¸è¿”å›å»ºè®®çŠ¶æ€"""
        logger.info(f"ğŸ¬ UGCåˆé›†æ¨¡å¼ï¼šå¼€å§‹ä¸‹è½½Bç«™è§†é¢‘: {url}")

        # è°ƒç”¨åŸå§‹çš„smart_download_bilibiliï¼Œä½†ä¿®æ”¹å•è§†é¢‘å¤„ç†é€»è¾‘
        try:
            # å…ˆè·å–è§†é¢‘ä¿¡æ¯
            import yt_dlp
            from pathlib import Path
            import os
            import re

            # ä¿å­˜åŸå§‹å·¥ä½œç›®å½•
            original_cwd = os.getcwd()
            logger.info(f"ğŸ“ åŸå§‹å·¥ä½œç›®å½•: {original_cwd}")

            try:
                # æ£€æŸ¥è§†é¢‘ç±»å‹
                logger.info(f"ğŸ” æ­£åœ¨æ£€æŸ¥è§†é¢‘ç±»å‹: {url}")

                info_opts = {
                    "quiet": True,
                    "no_warnings": True,
                    "socket_timeout": 15,
                    "retries": 2,
                }
                if self.proxy_host:
                    info_opts["proxy"] = self.proxy_host

                with yt_dlp.YoutubeDL(info_opts) as ydl:
                    try:
                        info = ydl.extract_info(url, download=False)
                        entries = info.get("entries", [info] if info else [])
                        count = len([e for e in entries if e])
                        logger.info(f"ğŸ“‹ æ£€æµ‹åˆ° {count} ä¸ªè§†é¢‘")
                    except Exception as e:
                        logger.warning(f"è·å–è§†é¢‘ä¿¡æ¯å¤±è´¥: {e}")
                        count = 1  # é»˜è®¤ä¸ºå•è§†é¢‘

                # å¯¹äºUGCåˆé›†ï¼Œå³ä½¿æ£€æµ‹åˆ°å•è§†é¢‘ä¹Ÿè¦ç»§ç»­ä¸‹è½½
                if count == 1:
                    logger.info("ğŸ¬ UGCåˆé›†æ¨¡å¼ï¼šæ£€æµ‹åˆ°å•è§†é¢‘ï¼Œç»§ç»­ä½¿ç”¨smart_download_bilibiliä¸‹è½½")

                    # è®¾ç½®ä¸‹è½½è·¯å¾„
                    final_download_path = Path(download_path)
                    final_download_path.mkdir(parents=True, exist_ok=True)

                    # æ„å»ºè¾“å‡ºæ¨¡æ¿
                    output_template = str(final_download_path / "%(title)s.%(ext)s")

                    # é…ç½®ä¸‹è½½é€‰é¡¹
                    ydl_opts = {
                        "outtmpl": output_template,
                        "format": "bestvideo[ext=mp4]+bestaudio[ext=m4a]/bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best",
                        "merge_output_format": "mp4",
                        "ignoreerrors": True,
                        "retries": 8,
                        "fragment_retries": 8,
                        "skip_unavailable_fragments": True,
                        "quiet": True,
                        "no_warnings": True,
                        "socket_timeout": 30,
                    }

                    if self.proxy_host:
                        ydl_opts["proxy"] = self.proxy_host

                    if progress_callback:
                        ydl_opts["progress_hooks"] = [progress_callback]

                    # å¦‚æœå¼€å¯äº†Bç«™å°é¢ä¸‹è½½ï¼Œæ·»åŠ ç¼©ç•¥å›¾ä¸‹è½½é€‰é¡¹
                    if hasattr(self, 'bot') and hasattr(self.bot, 'bilibili_thumbnail_download') and self.bot.bilibili_thumbnail_download:
                        ydl_opts["writethumbnail"] = True
                        # æ·»åŠ ç¼©ç•¥å›¾æ ¼å¼è½¬æ¢åå¤„ç†å™¨ï¼šWebP -> JPG
                        if "postprocessors" not in ydl_opts:
                            ydl_opts["postprocessors"] = []
                        ydl_opts["postprocessors"].append({
                            'key': 'FFmpegThumbnailsConvertor',
                            'format': 'jpg',
                            'when': 'before_dl'
                        })
                        logger.info("ğŸ–¼ï¸ UGCåˆé›†å¼€å¯Bç«™å°é¢ä¸‹è½½ï¼ˆè½¬æ¢ä¸ºJPGæ ¼å¼ï¼‰")

                    # æ‰§è¡Œä¸‹è½½
                    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
                        ydl.download([url])

                    logger.info("âœ… UGCåˆé›†å•è§†é¢‘ä¸‹è½½å®Œæˆ")
                    return True
                else:
                    # å¤šè§†é¢‘æƒ…å†µï¼Œè°ƒç”¨åŸå§‹çš„smart_download_bilibili
                    logger.info(f"ğŸ¬ UGCåˆé›†æ¨¡å¼ï¼šæ£€æµ‹åˆ°å¤šè§†é¢‘({count}ä¸ª)ï¼Œè°ƒç”¨åŸå§‹ä¸‹è½½å™¨")
                    return self.smart_download_bilibili(url, download_path, progress_callback, auto_playlist)

            finally:
                # æ¢å¤å·¥ä½œç›®å½•
                os.chdir(original_cwd)
                logger.info(f"ğŸ“ å·²æ¢å¤å·¥ä½œç›®å½•: {original_cwd}")

        except Exception as e:
            logger.error(f"âŒ UGCåˆé›†ä¸‹è½½å¤±è´¥: {e}")
            return False

    def _resume_failed_downloads(self, download_path, original_url, max_retries=5):
        """æ£€æµ‹å¹¶æ–­ç‚¹ç»­ä¼ å¤±è´¥çš„ä¸‹è½½"""
        part_files = self._detect_part_files(download_path)

        if not part_files:
            return True  # æ²¡æœ‰PARTæ–‡ä»¶ï¼Œä¸‹è½½æˆåŠŸ

        if max_retries <= 0:
            logger.warning(f"âš ï¸ é‡è¯•æ¬¡æ•°å·²ç”¨å®Œï¼Œä»æœ‰ {len(part_files)} ä¸ªæœªå®Œæˆæ–‡ä»¶")
            return False

        logger.info(f"ğŸ”„ æ£€æµ‹åˆ° {len(part_files)} ä¸ªæœªå®Œæˆæ–‡ä»¶ï¼Œå°è¯•æ–­ç‚¹ç»­ä¼  (å‰©ä½™é‡è¯•: {max_retries})")

        # å°è¯•æ–­ç‚¹ç»­ä¼ PARTæ–‡ä»¶
        resumed_count = self._resume_part_files(download_path, original_url)

        # ç­‰å¾…ä¸€æ®µæ—¶é—´å†æ£€æŸ¥
        import time
        time.sleep(1)

        # é€’å½’æ£€æŸ¥æ˜¯å¦è¿˜æœ‰PARTæ–‡ä»¶
        remaining_part_files = self._detect_part_files(download_path)

        if not remaining_part_files:
            logger.info("âœ… æ‰€æœ‰PARTæ–‡ä»¶å·²æˆåŠŸç»­ä¼ å®Œæˆ")
            return True
        elif len(remaining_part_files) < len(part_files):
            logger.info(f"ğŸ“ˆ éƒ¨åˆ†æ–‡ä»¶ç»­ä¼ æˆåŠŸï¼Œå‰©ä½™ {len(remaining_part_files)} ä¸ªæ–‡ä»¶")
            # ç»§ç»­å°è¯•å‰©ä½™æ–‡ä»¶
            return self._resume_failed_downloads(download_path, original_url, max_retries - 1)
        else:
            logger.warning(f"âš ï¸ æ–­ç‚¹ç»­ä¼ æœªèƒ½å‡å°‘PARTæ–‡ä»¶æ•°é‡ï¼Œå‰©ä½™é‡è¯•: {max_retries - 1}")
            if max_retries > 1:
                return self._resume_failed_downloads(download_path, original_url, max_retries - 1)
            else:
                return False

    def _sanitize_filename(self, filename, max_length=200):
        """æ¸…ç†æ–‡ä»¶åï¼Œå»é™¤ç‰¹æ®Šå­—ç¬¦ï¼Œé™åˆ¶é•¿åº¦"""
        if not filename:
            return "video"

        # å»é™¤ç‰¹æ®Šå­—ç¬¦ï¼ˆä¿ç•™ä¸­æ–‡å­—ç¬¦ï¼Œåªç§»é™¤çœŸæ­£å±é™©çš„å­—ç¬¦ï¼‰
        filename = re.sub(r'[\\/:*?"<>|]', '_', filename)
        # å»é™¤å¤šä½™ç©ºæ ¼
        filename = re.sub(r'\s+', ' ', filename).strip()
        # å»é™¤å¼€å¤´å’Œç»“å°¾çš„ç‰¹æ®Šå­—ç¬¦
        filename = re.sub(r'^[_\s]+|[_\s]+$', '', filename)

        # å¦‚æœæ–‡ä»¶åå¤ªé•¿ï¼Œè¿›è¡Œæ™ºèƒ½æˆªæ–­
        if len(filename) > max_length:
            # ä¿ç•™æ‰©å±•åï¼ˆå¦‚æœæœ‰ï¼‰
            name, ext = os.path.splitext(filename)
            if ext:
                # å¦‚æœæœ‰æ‰©å±•åï¼Œä¿ç•™æ‰©å±•åï¼Œæˆªæ–­ä¸»æ–‡ä»¶å
                max_name_length = max_length - len(ext) - 3  # 3æ˜¯"..."çš„é•¿åº¦
                if max_name_length > 0:
                    filename = name[:max_name_length] + "..." + ext
                else:
                    # å¦‚æœæ‰©å±•åå¤ªé•¿ï¼Œåªä¿ç•™æ‰©å±•å
                    filename = "..." + ext
            else:
                # æ²¡æœ‰æ‰©å±•åï¼Œç›´æ¥æˆªæ–­
                filename = filename[:max_length-3] + "..."

        # ç¡®ä¿æ–‡ä»¶åä¸ä¸ºç©º
        if not filename or filename.isspace():
            filename = "video"

        return filename

    def _optimize_instagram_filename(self, title, video_info=None):
        """
        Instagramä¸“ç”¨æ–‡ä»¶åä¼˜åŒ–
        
        Args:
            title: åŸå§‹æ ‡é¢˜
            video_info: è§†é¢‘ä¿¡æ¯å­—å…¸ï¼ˆå¯é€‰ï¼‰
            
        Returns:
            ä¼˜åŒ–åçš„æ–‡ä»¶å
        """
        if not title:
            return f"instagram_{int(time.time())}"
        
        # å»é™¤å¸¸è§çš„Instagramæ ‡é¢˜å‰ç¼€
        optimized = title
        
        # å»é™¤ "Video by" å‰ç¼€
        if optimized.startswith("Video by "):
            optimized = optimized[9:]  # å»é™¤ "Video by "
        
        # å»é™¤ "Photo by" å‰ç¼€
        if optimized.startswith("Photo by "):
            optimized = optimized[9:]  # å»é™¤ "Photo by "
        
        # å»é™¤ "Reel by" å‰ç¼€  
        if optimized.startswith("Reel by "):
            optimized = optimized[8:]  # å»é™¤ "Reel by "
        
        # å¤„ç†ä½œè€…åç§°åçš„å†…å®¹
        if " â€¢ " in optimized:
            # å¦‚æœæœ‰ " â€¢ " åˆ†éš”ç¬¦ï¼Œå–åé¢çš„å†…å®¹ä½œä¸ºä¸»è¦æ ‡é¢˜
            parts = optimized.split(" â€¢ ", 1)
            if len(parts) > 1 and parts[1].strip():
                optimized = parts[1].strip()
            else:
                optimized = parts[0].strip()
        elif ": " in optimized:
            # å¦‚æœæœ‰ ": " åˆ†éš”ç¬¦ï¼Œå–åé¢çš„å†…å®¹
            parts = optimized.split(": ", 1)
            if len(parts) > 1 and parts[1].strip():
                optimized = parts[1].strip()
            else:
                optimized = parts[0].strip()
        
        # å»é™¤æœ«å°¾çš„å¸¸è§æ ‡ç­¾å’Œç¬¦å·ï¼ˆåœ¨çŸ­æ ‡é¢˜æ£€æŸ¥ä¹‹å‰ï¼‰
        optimized = re.sub(r'\s*[#@]\s*.*$', '', optimized)  # å»é™¤æœ«å°¾çš„#æ ‡ç­¾å’Œ@æåŠ
        optimized = re.sub(r'\s*\.\.\.$', '', optimized)     # å»é™¤æœ«å°¾çš„çœç•¥å·
        
        # å¦‚æœå¤„ç†åçš„æ ‡é¢˜å¤ªçŸ­ï¼ˆå¯èƒ½åªæ˜¯ç”¨æˆ·åï¼‰ï¼Œæ·»åŠ Instagramå‰ç¼€å’Œæ—¶é—´æˆ³
        if len(optimized.strip()) <= 3:  # ä¿®æ”¹ä¸º <= 3
            timestamp = int(time.time()) % 100000  # ä½¿ç”¨æ—¶é—´æˆ³å5ä½é¿å…å¤ªé•¿
            optimized = f"instagram_{optimized}_{timestamp}" if optimized.strip() else f"instagram_{timestamp}"
        
        # é™åˆ¶é•¿åº¦å¹¶æ¸…ç†
        optimized = self._sanitize_filename(optimized.strip(), max_length=50)
        
        # å¦‚æœæœ€ç»ˆç»“æœä¸ºç©ºï¼Œä½¿ç”¨é»˜è®¤åç§°
        if not optimized or optimized.isspace():
            return f"instagram_{int(time.time())}"
        
        # æ·»åŠ æ—¶é—´æˆ³åç¼€é¿å…é‡å¤ï¼ˆå¯é€‰ï¼Œå–å†³äºç”¨æˆ·åå¥½ï¼‰
        # å¯ä»¥æ ¹æ®éœ€è¦å¯ç”¨è¿™ä¸ªåŠŸèƒ½
        # timestamp = int(time.time()) % 10000
        # optimized = f"{optimized}_{timestamp}"
        
        return optimized

    def _create_gallery_dl_config(self):
        """åˆ›å»º gallery-dl.conf é…ç½®æ–‡ä»¶"""
        import json

        config_path = Path(self.download_path / "gallery-dl.conf")

        # ä½¿ç”¨ GALLERY_DL_DOWNLOAD_PATH ç¯å¢ƒå˜é‡ï¼Œå¦‚æœæ²¡æœ‰è®¾ç½®åˆ™ä½¿ç”¨é»˜è®¤å€¼
        gallery_dl_download_path = os.environ.get("GALLERY_DL_DOWNLOAD_PATH")
        if not gallery_dl_download_path:
            # æœ¬åœ°å¼€å‘ç¯å¢ƒé»˜è®¤å€¼
            gallery_dl_download_path = str(self.download_path / "gallery")
            logger.info(f"âš ï¸ æœªè®¾ç½® GALLERY_DL_DOWNLOAD_PATH ç¯å¢ƒå˜é‡ï¼Œä½¿ç”¨é»˜è®¤å€¼: {gallery_dl_download_path}")
        else:
            logger.info(f"âœ… ä½¿ç”¨ GALLERY_DL_DOWNLOAD_PATH ç¯å¢ƒå˜é‡: {gallery_dl_download_path}")

        logger.info(f"ğŸ¯ ä½¿ç”¨ GALLERY_DL_DOWNLOAD_PATH: {gallery_dl_download_path}")

        # ä»ç¯å¢ƒå˜é‡è·å–X_COOKIESè·¯å¾„
        x_cookies_env = os.environ.get("X_COOKIES")
        if x_cookies_env:
            cookies_path = x_cookies_env
            logger.info(f"ğŸª ä»ç¯å¢ƒå˜é‡è·å–X_COOKIES: {cookies_path}")
        else:
            cookies_path = str(self.x_cookies_path) if self.x_cookies_path else None
            logger.info(f"ğŸª ä½¿ç”¨åˆå§‹åŒ–å‚æ•°ä¸­çš„X cookies: {cookies_path}")

        config = {
            "base-directory": gallery_dl_download_path,
            "extractor": {
                "twitter": {
                    "cookies": cookies_path
                }
            },
            "downloader": {
                "http": {
                    "timeout": 120,
                    "retries": 15,
                    "sleep": 5,
                    "verify": False,
                    "headers": {
                        "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36",
                        "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8",
                        "Accept-Language": "zh-CN,zh;q=0.9,en;q=0.8",
                        "Accept-Encoding": "gzip, deflate, br",
                        "DNT": "1",
                        "Connection": "keep-alive",
                        "Upgrade-Insecure-Requests": "1",
                        "Sec-Fetch-Dest": "document",
                        "Sec-Fetch-Mode": "navigate",
                        "Sec-Fetch-Site": "cross-site",
                        "Sec-Fetch-User": "?1",
                        "Cache-Control": "max-age=0",
                        "Referer": "https://telegra.ph/",
                        "Origin": "https://telegra.ph"
                    },
                    "max_retries": 15,
                    "retry_delay": 5,
                    "connection_timeout": 60,
                    "read_timeout": 120,
                    "chunk_size": 8192,
                    "stream": True,
                    "allow_redirects": True,
                    "max_redirects": 10
                }
            }
        }

        with open(config_path, 'w', encoding='utf-8') as f:
            json.dump(config, f, indent=2, ensure_ascii=False)

        logger.info(f"å·²æˆåŠŸåˆ›å»º gallery-dl.conf é…ç½®æ–‡ä»¶: {config_path}")
        logger.info(f"é…ç½®æ–‡ä»¶å†…å®¹:\n{json.dumps(config, indent=2, ensure_ascii=False)}")

    async def _download_apple_music(self, url: str, download_path: str, message_updater=None, status_message=None, context=None) -> dict:
        """ä¸‹è½½ Apple Music"""
        try:
            if not self.apple_music_downloader:
                # å°è¯•é‡æ–°åˆå§‹åŒ–
                try:
                    from applemusic_downloader_plus import AppleMusicDownloaderPlus
                    
                    self.apple_music_downloader = AppleMusicDownloaderPlus(
                        output_dir=str(self.apple_music_download_path),
                        cookies_path=self.apple_music_cookies_path
                    )
                    
                    # æ£€æŸ¥æ˜¯å¦æˆåŠŸ
                    if not (self.apple_music_downloader and self.apple_music_downloader.is_available()):
                        self.apple_music_downloader = None
                        
                except Exception:
                    self.apple_music_downloader = None
                
                # å¦‚æœé‡æ–°åˆå§‹åŒ–ä¹Ÿå¤±è´¥ï¼Œè¿”å›é”™è¯¯
                if not self.apple_music_downloader:
                    return {
                        "success": False,
                        "error": "Apple Music ä¸‹è½½å™¨æœªåˆå§‹åŒ–",
                        "platform": "AppleMusic",
                        "content_type": "music"
                    }

            # æ›´æ–°æ¶ˆæ¯çŠ¶æ€
            if message_updater and callable(message_updater):
                try:
                    if asyncio.iscoroutinefunction(message_updater):
                        await message_updater("ğŸ æ­£åœ¨è§£æ Apple Music é“¾æ¥...")
                    else:
                        message_updater("ğŸ æ­£åœ¨è§£æ Apple Music é“¾æ¥...")
                except Exception as e:
                    logger.warning(f"æ¶ˆæ¯æ›´æ–°å¤±è´¥: {e}")

            # æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆçš„ Apple Music é“¾æ¥
            if not self.apple_music_downloader.is_apple_music_url(url):
                return {
                    "success": False,
                    "error": "ä¸æ˜¯æœ‰æ•ˆçš„ Apple Music é“¾æ¥",
                    "platform": "AppleMusic",
                    "content_type": "music"
                }

            # æå–éŸ³ä¹ä¿¡æ¯
            music_info = self.apple_music_downloader.extract_music_info(url)
            logger.info(f"ğŸ Apple Music ä¿¡æ¯: {music_info}")

            # åˆ›å»ºè¿›åº¦å›è°ƒ
            progress_data = {"final_filename": None, "lock": threading.Lock()}

            # ä½¿ç”¨ Apple Music è¿›åº¦å›è°ƒ
            progress_callback = apple_music_progress_hook(
                message_updater=message_updater,
                progress_data=progress_data,
                status_message=status_message,
                context=context
            )

            # æ‰§è¡Œä¸‹è½½
            try:
                # æ ¹æ®éŸ³ä¹ç±»å‹é€‰æ‹©ä¸‹è½½æ–¹æ³•ï¼Œå¹¶æ·»åŠ è¶…æ—¶æ§åˆ¶
                if music_info.get('type') == 'album':
                    # ä¸“è¾‘ä¸‹è½½ï¼šè®¾ç½®è¾ƒé•¿çš„è¶…æ—¶æ—¶é—´ï¼ˆ15åˆ†é’Ÿï¼‰
                    logger.info("ğŸ å¼€å§‹ä¸‹è½½ä¸“è¾‘ï¼Œè¶…æ—¶æ—¶é—´ï¼š15åˆ†é’Ÿ")
                    try:
                        result = await asyncio.wait_for(
                            self.apple_music_downloader.download_album(url, progress_callback),
                            timeout=900.0  # 15åˆ†é’Ÿè¶…æ—¶
                        )
                    except asyncio.TimeoutError:
                        logger.error("â° Apple Musicä¸“è¾‘ä¸‹è½½è¶…æ—¶ï¼ˆ15åˆ†é’Ÿï¼‰")
                        return {
                            "success": False,
                            "error": "ä¸“è¾‘ä¸‹è½½è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•æˆ–æ£€æŸ¥ç½‘ç»œè¿æ¥",
                            "platform": "AppleMusic",
                            "content_type": "album",
                            "url": url
                        }
                else:
                    # å•æ›²ä¸‹è½½ï¼šè®¾ç½®è¾ƒçŸ­çš„è¶…æ—¶æ—¶é—´ï¼ˆ5åˆ†é’Ÿï¼‰
                    logger.info("ğŸ å¼€å§‹ä¸‹è½½å•æ›²ï¼Œè¶…æ—¶æ—¶é—´ï¼š5åˆ†é’Ÿ")
                    try:
                        result = await asyncio.wait_for(
                            self.apple_music_downloader.download_song(url, progress_callback),
                            timeout=300.0  # 5åˆ†é’Ÿè¶…æ—¶
                        )
                    except asyncio.TimeoutError:
                        logger.error("â° Apple Musicå•æ›²ä¸‹è½½è¶…æ—¶ï¼ˆ5åˆ†é’Ÿï¼‰")
                        return {
                            "success": False,
                            "error": "å•æ›²ä¸‹è½½è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•æˆ–æ£€æŸ¥ç½‘ç»œè¿æ¥",
                            "platform": "AppleMusic",
                            "content_type": "song",
                            "url": url
                        }
                
                if result.get('success'):
                    logger.info(f"ğŸ Apple Music ä¸‹è½½æˆåŠŸ: {result}")
                    return {
                        "success": True,
                        "platform": "AppleMusic",
                        "content_type": music_info.get('type', 'music'),
                        "download_path": str(self.apple_music_download_path),
                        "files_count": result.get('files_count', 0),
                        "total_size_mb": result.get('total_size_mb', 0),  # ğŸ”§ ä¿®å¤ï¼šåªä½¿ç”¨total_size_mbå­—æ®µ
                        "file_formats": result.get('file_formats', []),
                        "music_type": music_info.get('type'),
                        "country": music_info.get('country'),
                        "url": url,  # ä¿®å¤ï¼šæ·»åŠ åŸå§‹URLå­—æ®µï¼Œç”¨äºåç»­çš„ä¸“è¾‘/å•æ›²ç±»å‹åˆ¤æ–­
                        "music_info": result.get('music_info', {})  # æ·»åŠ éŸ³ä¹ä¿¡æ¯å­—æ®µ
                    }
                else:
                    logger.error(f"ğŸ Apple Music ä¸‹è½½å¤±è´¥: {result.get('error')}")
                    return {
                        "success": False,
                        "error": result.get('error', 'æœªçŸ¥é”™è¯¯'),
                        "platform": "AppleMusic",
                        "content_type": "music",
                        "url": url  # æ·»åŠ URLå­—æ®µ
                    }
                    
            except Exception as e:
                logger.error(f"ğŸ Apple Music ä¸‹è½½å¼‚å¸¸: {e}")
                return {
                    "success": False,
                    "error": f"ä¸‹è½½å¼‚å¸¸: {str(e)}",
                    "platform": "AppleMusic",
                    "content_type": "music",
                    "url": url  # æ·»åŠ URLå­—æ®µ
                }

        except Exception as e:
            logger.error(f"ğŸ Apple Music ä¸‹è½½å™¨è°ƒç”¨å¤±è´¥: {e}")
            return {
                "success": False,
                "error": f"ä¸‹è½½å™¨è°ƒç”¨å¤±è´¥: {str(e)}",
                "platform": "AppleMusic",
                "content_type": "music",
                "url": url  # æ·»åŠ URLå­—æ®µ
            }


    async def _download_netease_music(self, url: str, download_path: str, message_updater=None, status_message=None, context=None) -> dict:
        """ä¸‹è½½ç½‘æ˜“äº‘éŸ³ä¹"""
        import threading
        try:
            if not self.netease_downloader:
                # å°è¯•é‡æ–°åˆå§‹åŒ–ç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½å™¨
                try:
                    # åŠ¨æ€å¯¼å…¥neteasecloud_musicæ¨¡å—ï¼Œé¿å…å…¨å±€å¯¼å…¥å¤±è´¥çš„å½±å“
                    import neteasecloud_music
                    from neteasecloud_music import NeteaseDownloader
                    
                    # ç›´æ¥ä½¿ç”¨NeteaseDownloaderï¼Œä¸éœ€è¦é€‚é…å™¨
                    self.netease_downloader = NeteaseDownloader(bot=self)
                    logger.info(f"ğŸµ ç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½å™¨é‡æ–°åˆå§‹åŒ–æˆåŠŸ (æ¨¡å—: {neteasecloud_music.__file__})")
                except Exception as e:
                    logger.warning(f"ç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½å™¨é‡æ–°åˆå§‹åŒ–å¤±è´¥: {e}")
                    return {
                        "success": False,
                        "error": "ç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½å™¨æœªåˆå§‹åŒ–ä¸”é‡æ–°åˆå§‹åŒ–å¤±è´¥",
                        "platform": "Netease",
                        "content_type": "music"
                    }

            # æ›´æ–°æ¶ˆæ¯çŠ¶æ€
            if message_updater and callable(message_updater):
                try:
                    if asyncio.iscoroutinefunction(message_updater):
                        await message_updater("ğŸµ æ­£åœ¨è§£æç½‘æ˜“äº‘éŸ³ä¹é“¾æ¥...")
                    else:
                        message_updater("ğŸµ æ­£åœ¨è§£æç½‘æ˜“äº‘éŸ³ä¹é“¾æ¥...")
                except Exception as e:
                    logger.warning(f"æ¶ˆæ¯æ›´æ–°å¤±è´¥: {e}")

            # è®¾ç½®éŸ³è´¨
            quality = self.netease_downloader.get_quality_setting()

            # åˆ›å»ºè¿›åº¦å›è°ƒ
            progress_data = {"final_filename": None, "lock": threading.Lock()}

            if message_updater:
                progress_callback = netease_music_progress_hook(
                    message_updater=message_updater,
                    progress_data=progress_data,
                    status_message=status_message,
                    context=context
                )
            else:
                progress_callback = lambda d: None

            # ä½¿ç”¨æ–°çš„download_by_urlæ–¹æ³•ï¼Œè‡ªåŠ¨å¤„ç†æ‰€æœ‰é“¾æ¥æ ¼å¼
            logger.info(f"ğŸ”— ä½¿ç”¨æ–°çš„download_by_urlæ–¹æ³•å¤„ç†é“¾æ¥: {url}")
            
            try:
                loop = asyncio.get_running_loop()
            except RuntimeError:
                loop = asyncio.get_event_loop()

            if loop is None:
                return {
                    "success": False,
                    "error": "æ— æ³•è·å–äº‹ä»¶å¾ªç¯",
                    "platform": "Netease",
                    "content_type": "music"
                }

            # è°ƒç”¨download_by_urlæ–¹æ³•ï¼Œå®ƒä¼šè‡ªåŠ¨è¯†åˆ«é“¾æ¥ç±»å‹å¹¶è°ƒç”¨ç›¸åº”çš„ä¸‹è½½æ–¹æ³•
            result = await loop.run_in_executor(
                None,
                self.netease_downloader.download_by_url,
                url,
                str(download_path),
                self.netease_downloader.quality_map.get(quality, '320k'),
                progress_callback
            )

            if result.get('success'):
                # æ ¹æ®ä¸‹è½½ç±»å‹è¿”å›ç›¸åº”çš„ç»“æœ
                if 'playlist_name' in result:
                    # æ­Œå•ä¸‹è½½ç»“æœ
                    return {
                        "success": True,
                        "message": result.get('message', 'ç½‘æ˜“äº‘éŸ³ä¹æ­Œå•ä¸‹è½½å®Œæˆ'),
                        "platform": "Netease",
                        "content_type": "music",
                        "download_path": result.get('download_path', ''),
                        "playlist_name": result.get('playlist_name', ''),
                        "creator": result.get('creator', ''),
                        "total_songs": result.get('total_songs', 0),
                        "downloaded_songs": result.get('downloaded_songs', 0),
                        "failed_songs": result.get('failed_songs', 0),
                        "total_size_mb": result.get('total_size_mb', 0),
                        "songs": result.get('songs', []),
                        "quality": result.get('quality', quality),
                        "failed_details": result.get('failed_details', [])
                    }
                elif 'album_name' in result:
                    # ä¸“è¾‘ä¸‹è½½ç»“æœ
                    return {
                        "success": True,
                        "message": result.get('message', 'ç½‘æ˜“äº‘éŸ³ä¹ä¸“è¾‘ä¸‹è½½å®Œæˆ'),
                        "platform": "Netease",
                        "content_type": "music",
                        "download_path": result.get('download_path', ''),
                        "album_name": result.get('album_name', ''),
                        "total_songs": result.get('total_songs', 0),
                        "downloaded_songs": result.get('downloaded_songs', 0),
                        "total_size_mb": result.get('total_size_mb', 0),
                        "songs": result.get('songs', []),
                        "quality": result.get('quality', quality)
                    }
                else:
                    # å•æ›²ä¸‹è½½ç»“æœ
                    return {
                        "success": True,
                        "message": result.get('message', 'ç½‘æ˜“äº‘éŸ³ä¹å•æ›²ä¸‹è½½å®Œæˆ'),
                        "platform": "Netease",
                        "content_type": "music",
                        "download_path": result.get('download_path', ''),
                        "filename": result.get('filename', ''),
                        "size_mb": result.get('size_mb', 0),
                        "song_title": result.get('song_title', ''),
                        "song_artist": result.get('song_artist', ''),
                        "quality": result.get('quality', quality),
                        "quality_name": result.get('quality_name', 'æœªçŸ¥'),
                        "bitrate": result.get('bitrate', 'æœªçŸ¥'),
                        "duration": result.get('duration', 'æœªçŸ¥'),
                        "file_format": result.get('file_format', 'MP3')
                    }
            else:
                return {
                    "success": False,
                    "error": result.get('error', 'ä¸‹è½½å¤±è´¥'),
                    "platform": "Netease",
                    "content_type": "music"
                }

                try:
                    loop = asyncio.get_running_loop()
                except RuntimeError:
                    loop = asyncio.get_event_loop()

                if loop is None:
                    return {
                        "success": False,
                        "error": "æ— æ³•è·å–äº‹ä»¶å¾ªç¯",
                        "platform": "Netease",
                        "content_type": "music"
                    }

                if song_id:
                    # ç›´æ¥ä½¿ç”¨æ­Œæ›²IDä¸‹è½½å•æ›²
                    result = await loop.run_in_executor(
                        None,
                        self.netease_downloader.download_song_by_id,
                        song_id,
                        str(download_path),
                        self.netease_downloader.quality_map.get(quality, '320k'),
                        progress_callback
                    )
                else:
                    # å¦‚æœæ— æ³•æå–IDï¼Œä½¿ç”¨é€šç”¨æœç´¢
                    search_keyword = "çƒ­é—¨æ­Œæ›²"
                    result = await loop.run_in_executor(
                        None,
                        self.netease_downloader.download_song_by_search,
                        search_keyword,
                        "",  # artist
                        str(download_path),
                        self.netease_downloader.quality_map.get(quality, '320k'),
                        progress_callback
                    )

                if result.get('success'):
                    return {
                        "success": True,
                        "message": result.get('message', 'ç½‘æ˜“äº‘éŸ³ä¹å•æ›²ä¸‹è½½å®Œæˆ'),
                        "platform": "Netease",
                        "content_type": "music",
                        "download_path": result.get('download_path', ''),
                        "filename": result.get('filename', ''),
                        "size_mb": result.get('size_mb', 0),
                        "song_title": result.get('song_title', ''),
                        "song_artist": result.get('song_artist', ''),
                        "quality": result.get('quality', quality),
                        "quality_name": result.get('quality_name', 'æœªçŸ¥'),
                        "bitrate": result.get('bitrate', 'æœªçŸ¥'),
                        "duration": result.get('duration', 'æœªçŸ¥'),
                        "file_format": result.get('file_format', 'MP3')
                    }
                else:
                    return {
                        "success": False,
                        "error": result.get('error', 'å•æ›²ä¸‹è½½å¤±è´¥'),
                        "platform": "Netease",
                        "content_type": "music"
                    }

        except Exception as e:
            logger.error(f"ç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½å¼‚å¸¸: {str(e)}")
            return {
                "success": False,
                "error": f"ä¸‹è½½å¤±è´¥: {str(e)}",
                "platform": "Netease",
                "content_type": "music"
            }

    async def _download_qqmusic_music(self, url: str, download_path: str, message_updater=None, status_message=None, context=None) -> dict:
        """ä¸‹è½½QQéŸ³ä¹"""
        import threading
        try:
            if not self.qqmusic_downloader:
                # å°è¯•é‡æ–°åˆå§‹åŒ–QQéŸ³ä¹ä¸‹è½½å™¨
                try:
                    # åŠ¨æ€å¯¼å…¥qqmusic_downloaderæ¨¡å—ï¼Œé¿å…å…¨å±€å¯¼å…¥å¤±è´¥çš„å½±å“
                    import qqmusic_downloader
                    from qqmusic_downloader import QQMusicDownloader
                    
                    # ç›´æ¥ä½¿ç”¨QQMusicDownloader
                    self.qqmusic_downloader = QQMusicDownloader(bot=self)
                    logger.info(f"ğŸµ QQéŸ³ä¹ä¸‹è½½å™¨é‡æ–°åˆå§‹åŒ–æˆåŠŸ (æ¨¡å—: {qqmusic_downloader.__file__})")
                except Exception as e:
                    logger.warning(f"QQéŸ³ä¹ä¸‹è½½å™¨é‡æ–°åˆå§‹åŒ–å¤±è´¥: {e}")
                    return {
                        "success": False,
                        "error": "QQéŸ³ä¹ä¸‹è½½å™¨ä¸å¯ç”¨",
                        "platform": "QQMusic",
                        "content_type": "music"
                    }

            # æ›´æ–°çŠ¶æ€æ¶ˆæ¯
            if message_updater:
                try:
                    message_updater("ğŸµ æ­£åœ¨è§£æQQéŸ³ä¹é“¾æ¥...")
                except Exception as e:
                    logger.warning(f"æ¶ˆæ¯æ›´æ–°å¤±è´¥: {e}")

            # åˆ›å»ºè¿›åº¦å›è°ƒ
            progress_data = {"final_filename": None, "lock": threading.Lock()}

            if message_updater:
                # æ·»åŠ é€Ÿåº¦è®¡ç®—æ‰€éœ€çš„æ—¶é—´è·Ÿè¸ª
                import time
                last_time = time.time()
                last_downloaded = 0
                last_update_time = time.time()
                
                def progress_callback(progress, downloaded, total, filename=None):
                    nonlocal last_time, last_downloaded, last_update_time
                    try:
                        with progress_data["lock"]:
                            if total > 0:
                                # æ·»åŠ é¢‘ç‡æ§åˆ¶ï¼šæ¯0.2ç§’æ›´æ–°ä¸€æ¬¡ï¼ˆæé«˜æ›´æ–°é¢‘ç‡ï¼‰
                                current_time = time.time()
                                if current_time - last_update_time < 0.2:
                                    return
                                last_update_time = current_time
                                progress_percent = (downloaded / total) * 100
                                total_mb = total / (1024 * 1024)
                                downloaded_mb = downloaded / (1024 * 1024)
                                
                                # è®¡ç®—çœŸæ­£çš„ä¸‹è½½é€Ÿåº¦
                                time_diff = current_time - last_time
                                downloaded_diff = downloaded - last_downloaded
                                
                                if time_diff > 0 and downloaded_diff > 0:
                                    speed_bytes_per_sec = downloaded_diff / time_diff
                                    speed_mb = speed_bytes_per_sec / (1024 * 1024)
                                elif progress_percent >= 100:
                                    # ä¸‹è½½å®Œæˆæ—¶ï¼Œæ˜¾ç¤º"å®Œæˆ"
                                    speed_mb = "å®Œæˆ"
                                else:
                                    speed_mb = 0
                                
                                # æ›´æ–°æ—¶é—´å’Œä¸‹è½½é‡
                                last_time = current_time
                                last_downloaded = downloaded
                                
                                # è®¡ç®—é¢„è®¡å‰©ä½™æ—¶é—´
                                if isinstance(speed_mb, (int, float)) and speed_mb > 0 and total > downloaded:
                                    remaining = total - downloaded
                                    eta_seconds = int(remaining / (speed_bytes_per_sec))
                                    mins, secs = divmod(eta_seconds, 60)
                                    if mins > 0:
                                        eta_str = f"{mins:02d}:{secs:02d}"
                                    else:
                                        eta_str = f"00:{secs:02d}"
                                else:
                                    eta_str = "æœªçŸ¥"
                                
                                # åˆ›å»ºè¿›åº¦æ¡ï¼ˆå‚è€ƒç½‘æ˜“äº‘éŸ³ä¹æ ¼å¼ï¼‰
                                def _create_progress_bar(percent: float, length: int = 20) -> str:
                                    filled_length = int(length * percent / 100)
                                    return "â–ˆ" * filled_length + "â–‘" * (length - filled_length)
                                
                                progress_bar = _create_progress_bar(progress_percent)
                                
                                # å¤„ç†æ–‡ä»¶åæ˜¾ç¤º
                                display_filename = "æ­£åœ¨ä¸‹è½½..."
                                if filename:
                                    # æ¸…ç†æ–‡ä»¶åæ˜¾ç¤ºï¼ˆå‚è€ƒç½‘æ˜“äº‘éŸ³ä¹æ ¼å¼ï¼‰
                                    import os
                                    display_filename = os.path.basename(filename)
                                    if len(display_filename) > 35:
                                        name, ext = os.path.splitext(display_filename)
                                        display_filename = name[:30] + "..." + ext
                                
                                # ä½¿ç”¨å’Œç½‘æ˜“äº‘éŸ³ä¹ç›¸åŒçš„æ ¼å¼
                                if isinstance(speed_mb, str):
                                    speed_display = speed_mb
                                else:
                                    speed_display = f"{speed_mb:.2f}MB/s"
                                
                                progress_text = (
                                    f"ğŸµ éŸ³ä¹: QQéŸ³ä¹ä¸‹è½½ä¸­...\n"
                                    f"ğŸ“ æ–‡ä»¶: {display_filename}\n"
                                    f"ğŸ’¾ å¤§å°: {downloaded_mb:.2f}MB / {total_mb:.2f}MB\n"
                                    f"âš¡ é€Ÿåº¦: {speed_display}\n"
                                    f"â³ é¢„è®¡å‰©ä½™: {eta_str}\n"
                                    f"ğŸ“Š è¿›åº¦: {progress_bar} ({progress_percent:.1f}%)"
                                )
                                
                                # å¤„ç†å¼‚æ­¥å‡½æ•°
                                if asyncio.iscoroutinefunction(message_updater):
                                    # å¼‚æ­¥å‡½æ•°ï¼Œä½¿ç”¨ run_coroutine_threadsafe
                                    try:
                                        loop = asyncio.get_running_loop()
                                        asyncio.run_coroutine_threadsafe(
                                            message_updater(progress_text), loop
                                        )
                                    except Exception as e:
                                        logger.warning(f"å¼‚æ­¥æ¶ˆæ¯æ›´æ–°å¤±è´¥: {e}")
                                else:
                                    # åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                                    message_updater(progress_text)
                    except Exception as e:
                        logger.warning(f"QQéŸ³ä¹è¿›åº¦æ›´æ–°å¤±è´¥: {e}")
            else:
                progress_callback = None

            # ä½¿ç”¨asyncio.run_in_executoråœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­è¿è¡ŒåŒæ­¥çš„ä¸‹è½½å‡½æ•°
            import asyncio
            loop = asyncio.get_event_loop()
            
            # è°ƒç”¨download_by_urlæ–¹æ³•
            result = await loop.run_in_executor(
                None,
                self.qqmusic_downloader.download_by_url,
                url,
                str(download_path),
                'best',  # ä½¿ç”¨æœ€é«˜éŸ³è´¨
                progress_callback
            )

            if result.get('success'):
                # æ£€æŸ¥æ˜¯å¦ä¸ºæ­Œå•ä¸‹è½½
                if result.get('playlist_name'):
                    # æ­Œå•ä¸‹è½½ç»“æœ
                    return {
                        "success": True,
                        "platform": "QQMusic",
                        "content_type": "music",
                        "download_path": result.get('download_path', ''),
                        "playlist_name": result.get('playlist_name', ''),
                        "total_songs": result.get('total_songs', 0),
                        "downloaded_songs": result.get('downloaded_songs', 0),
                        "failed_songs": result.get('failed_songs', 0),
                        "total_size_mb": result.get('total_size_mb', 0),
                        "quality": result.get('quality', 'æœªçŸ¥'),
                        "downloaded_list": result.get('downloaded_list', []),
                        "failed_list": result.get('failed_list', []),
                        "url": url
                    }
                # æ£€æŸ¥æ˜¯å¦ä¸ºä¸“è¾‘ä¸‹è½½
                elif result.get('album_name'):
                    # ä¸“è¾‘ä¸‹è½½ç»“æœ
                    return {
                        "success": True,
                        "platform": "QQMusic",
                        "content_type": "music",
                        "download_path": result.get('download_path', ''),
                        "album_name": result.get('album_name', ''),
                        "singer_name": result.get('singer_name', ''),
                        "total_songs": result.get('total_songs', 0),
                        "downloaded_songs": result.get('downloaded_songs', 0),
                        "failed_songs": result.get('failed_songs', 0),
                        "downloaded_list": result.get('downloaded_list', []),
                        "failed_list": result.get('failed_list', []),
                        "url": url
                    }
                else:
                    # å•é¦–æ­Œæ›²ä¸‹è½½ç»“æœ
                    song_info = result.get('song_info', {})
                    
                    # æ­£ç¡®æå–æ­Œæ‰‹ä¿¡æ¯
                    song_artist = song_info.get('singer', 'æœªçŸ¥æ­Œæ‰‹')
                    
                    # æ­£ç¡®æå–ä¸“è¾‘ä¿¡æ¯
                    album_name = song_info.get('album', 'æœªçŸ¥ä¸“è¾‘')
                    
                    return {
                        "success": True,
                        "platform": "QQMusic",
                        "content_type": "music",
                        "file_path": result.get('file_path', ''),
                        "song_title": song_info.get('title', 'æœªçŸ¥æ­Œæ›²'),
                        "song_artist": song_artist,
                        "album": album_name,
                        "quality": song_info.get('quality', 'æœªçŸ¥éŸ³è´¨'),
                        "format": song_info.get('format', 'æœªçŸ¥æ ¼å¼'),
                        "duration": song_info.get('interval', 0),
                        "url": url
                    }
            else:
                return {
                    "success": False,
                    "error": result.get('error', 'QQéŸ³ä¹ä¸‹è½½å¤±è´¥'),
                    "platform": "QQMusic",
                    "content_type": "music"
                }

        except Exception as e:
            logger.error(f"QQéŸ³ä¹ä¸‹è½½å¼‚å¸¸: {str(e)}")
            return {
                "success": False,
                "error": f"ä¸‹è½½å¤±è´¥: {str(e)}",
                "platform": "QQMusic",
                "content_type": "music"
            }

    async def _download_youtubemusic_music(self, url: str, download_path: str, message_updater=None, status_message=None, context=None) -> dict:
        """ä¸‹è½½YouTube Music"""
        import threading
        try:
            if not self.youtubemusic_downloader:
                # å°è¯•é‡æ–°åˆå§‹åŒ–YouTube Musicä¸‹è½½å™¨
                try:
                    # åŠ¨æ€å¯¼å…¥youtubemusic_downloaderæ¨¡å—ï¼Œé¿å…å…¨å±€å¯¼å…¥å¤±è´¥çš„å½±å“
                    import youtubemusic_downloader
                    from youtubemusic_downloader import YouTubeMusicDownloader
                    
                    # ç›´æ¥ä½¿ç”¨YouTubeMusicDownloader
                    self.youtubemusic_downloader = YouTubeMusicDownloader(bot=self)
                    logger.info(f"ğŸµ YouTube Musicä¸‹è½½å™¨é‡æ–°åˆå§‹åŒ–æˆåŠŸ (æ¨¡å—: {youtubemusic_downloader.__file__})")
                except Exception as e:
                    logger.warning(f"YouTube Musicä¸‹è½½å™¨é‡æ–°åˆå§‹åŒ–å¤±è´¥: {e}")
                    return {
                        "success": False,
                        "error": "YouTube Musicä¸‹è½½å™¨ä¸å¯ç”¨",
                        "platform": "YouTubeMusic",
                        "content_type": "music"
                    }

            # æ›´æ–°çŠ¶æ€æ¶ˆæ¯
            if message_updater:
                try:
                    if asyncio.iscoroutinefunction(message_updater):
                        await message_updater("ğŸµ æ­£åœ¨è§£æYouTube Musicé“¾æ¥...")
                    else:
                        message_updater("ğŸµ æ­£åœ¨è§£æYouTube Musicé“¾æ¥...")
                except Exception as e:
                    logger.warning(f"æ¶ˆæ¯æ›´æ–°å¤±è´¥: {e}")

            # è®¾ç½®éŸ³è´¨
            quality = 'best'  # YouTube Musicé»˜è®¤ä½¿ç”¨æœ€é«˜éŸ³è´¨

            # åˆ›å»ºè¿›åº¦å›è°ƒ
            progress_data = {"final_filename": None, "lock": threading.Lock()}

            def youtubemusic_progress_callback(data):
                """
YouTube Musicä¸‹è½½è¿›åº¦å›è°ƒå‡½æ•°"""
                try:
                    # å¤„ç†å­—ç¬¦ä¸²æ ¼å¼çš„æ¶ˆæ¯ï¼ˆå®Œæˆæ¶ˆæ¯ï¼‰
                    if isinstance(data, str):
                        if message_updater:
                            try:
                                if asyncio.iscoroutinefunction(message_updater):
                                    # å¼‚æ­¥å‡½æ•°ï¼Œä½¿ç”¨ run_coroutine_threadsafe
                                    try:
                                        loop = asyncio.get_running_loop()
                                        asyncio.run_coroutine_threadsafe(
                                            message_updater(data), loop
                                        )
                                    except Exception as e:
                                        logger.warning(f"å¼‚æ­¥æ¶ˆæ¯æ›´æ–°å¤±è´¥: {e}")
                                else:
                                    # åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                                    message_updater(data)
                            except Exception as e:
                                logger.warning(f"YouTube Musicæ¶ˆæ¯æ›´æ–°å¤±è´¥: {e}")
                    # å¤„ç†å­—å…¸æ ¼å¼çš„æ¶ˆæ¯ï¼ˆä¸‹è½½è¿›åº¦ï¼‰
                    elif isinstance(data, dict) and data.get('status') == 'downloading':
                        progress_text = data.get('progress_text', '')
                        if progress_text and message_updater:
                            try:
                                if asyncio.iscoroutinefunction(message_updater):
                                    # å¼‚æ­¥å‡½æ•°ï¼Œä½¿ç”¨ run_coroutine_threadsafe
                                    try:
                                        loop = asyncio.get_running_loop()
                                        asyncio.run_coroutine_threadsafe(
                                            message_updater(progress_text), loop
                                        )
                                    except Exception as e:
                                        logger.warning(f"å¼‚æ­¥æ¶ˆæ¯æ›´æ–°å¤±è´¥: {e}")
                                else:
                                    # åŒæ­¥å‡½æ•°ï¼Œç›´æ¥è°ƒç”¨
                                    message_updater(progress_text)
                            except Exception as e:
                                logger.warning(f"YouTube Musicè¿›åº¦æ›´æ–°å¤±è´¥: {e}")
                    elif isinstance(data, dict) and data.get('status') == 'finished':
                        if message_updater:
                            finished_text = data.get('progress_text', 'âœ… YouTube Musicä¸‹è½½å®Œæˆ')
                            try:
                                if asyncio.iscoroutinefunction(message_updater):
                                    try:
                                        loop = asyncio.get_running_loop()
                                        asyncio.run_coroutine_threadsafe(
                                            message_updater(finished_text), loop
                                        )
                                    except Exception as e:
                                        logger.warning(f"å¼‚æ­¥æ¶ˆæ¯æ›´æ–°å¤±è´¥: {e}")
                                else:
                                    message_updater(finished_text)
                            except Exception as e:
                                logger.warning(f"YouTube Musicå®Œæˆæ¶ˆæ¯æ›´æ–°å¤±è´¥: {e}")
                except Exception as e:
                    logger.warning(f"YouTube Musicè¿›åº¦å›è°ƒå¤„ç†å¤±è´¥: {e}")

            # ä½¿ç”¨asyncio.run_in_executoråœ¨ç‹¬ç«‹çº¿ç¨‹ä¸­è¿è¡ŒåŒæ­¥çš„ä¸‹è½½å‡½æ•°
            import asyncio
            loop = asyncio.get_event_loop()
            
            # è°ƒç”¨download_by_urlæ–¹æ³•
            result = await loop.run_in_executor(
                None,
                self.youtubemusic_downloader.download_by_url,
                url,
                str(download_path),
                quality,
                youtubemusic_progress_callback
            )

            if result.get('success'):
                # æ ¹æ®ä¸‹è½½ç±»å‹è¿”å›ç›¸åº”çš„ç»“æœ
                if 'playlist_name' in result:
                    # æ’­æ”¾åˆ—è¡¨ä¸‹è½½ç»“æœ
                    return {
                        "success": True,
                        "message": result.get('message', 'YouTube Music æ’­æ”¾åˆ—è¡¨ä¸‹è½½å®Œæˆ'),
                        "platform": "YouTubeMusic",
                        "content_type": "music",
                        "download_path": result.get('download_path', ''),
                        "playlist_name": result.get('playlist_name', ''),
                        "creator": result.get('creator', ''),
                        "total_songs": result.get('total_songs', 0),
                        "downloaded_songs": result.get('downloaded_songs', 0),
                        "failed_songs": result.get('failed_songs', 0),
                        "total_size_mb": result.get('total_size_mb', 0),
                        "songs": result.get('songs', []),
                        "quality": result.get('quality', quality),
                        "url": result.get('url', url)
                    }
                elif 'album_name' in result:
                    # ä¸“è¾‘ä¸‹è½½ç»“æœ
                    return {
                        "success": True,
                        "message": result.get('message', 'YouTube Music ä¸“è¾‘ä¸‹è½½å®Œæˆ'),
                        "platform": "YouTubeMusic",
                        "content_type": "music",
                        "download_path": result.get('download_path', ''),
                        "album_name": result.get('album_name', ''),
                        "total_songs": result.get('total_songs', 0),
                        "downloaded_songs": result.get('downloaded_songs', 0),
                        "total_size_mb": result.get('total_size_mb', 0),
                        "songs": result.get('songs', []),
                        "quality": result.get('quality', quality),
                        "url": result.get('url', url)
                    }
                else:
                    # å•æ›²ä¸‹è½½ç»“æœ
                    return {
                        "success": True,
                        "message": result.get('message', 'YouTube Music å•æ›²ä¸‹è½½å®Œæˆ'),
                        "platform": "YouTubeMusic",
                        "content_type": "music",
                        "download_path": result.get('download_path', ''),
                        "filename": result.get('filename', ''),
                        "file_path": result.get('file_path', ''),
                        "size_mb": result.get('size_mb', 0),
                        "song_title": result.get('song_title', ''),
                        "song_artist": result.get('song_artist', ''),
                        "quality": result.get('quality', quality),
                        "format": result.get('format', 'M4A'),
                        "duration": result.get('duration', 0),
                        "url": result.get('url', url)
                    }
            else:
                return {
                    "success": False,
                    "error": result.get('error', 'YouTube Musicä¸‹è½½å¤±è´¥'),
                    "platform": "YouTubeMusic",
                    "content_type": "music"
                }

        except Exception as e:
            logger.error(f"YouTube Musicä¸‹è½½å¼‚å¸¸: {str(e)}")
            return {
                "success": False,
                "error": f"ä¸‹è½½å¤±è´¥: {str(e)}",
                "platform": "YouTubeMusic",
                "content_type": "music"
            }


class TelegramBot:
    def __init__(self, token: str, downloader: VideoDownloader):
        self.token = token
        self.downloader = downloader
        # è®¾ç½®ä¸‹è½½å™¨å¯¹botçš„å¼•ç”¨ï¼Œä»¥ä¾¿è®¿é—®è®¾ç½®
        self.downloader.bot = self
        self.application = None
        self.bot_id = None
        self.qbit_client = None

        # åˆå§‹åŒ–é…ç½®ç®¡ç†å™¨ï¼ˆä»…ä½¿ç”¨æ•°æ®åº“ï¼‰
        try:
            self.config_manager = ConfigManager("/app/db/savextube.db")
            # ä»æ•°æ®åº“åŠ è½½é…ç½®
            self.config = self.config_manager.get_all_config()
            logger.info("âœ… ä½¿ç”¨ SQLite æ•°æ®åº“é…ç½®")
        except Exception as e:
            logger.error(f"âŒ SQLite æ•°æ®åº“é…ç½®åˆå§‹åŒ–å¤±è´¥: {e}")
            raise  # ç›´æ¥æŠ›å‡ºå¼‚å¸¸ï¼Œä¸å›é€€åˆ°æ–‡ä»¶é…ç½®
        
        # è®¾ç½®é…ç½®é¡¹
        self.auto_download_enabled = self.config.get("auto_download_enabled", True)
        self.download_tasks = (
            {}
        )  # å­˜å‚¨ä¸‹è½½ä»»åŠ¡ {task_id: {'task': asyncio.Task, 'cancelled': bool}}
        self.task_lock = asyncio.Lock()  # ç”¨äºä¿æŠ¤ä»»åŠ¡å­—å…¸çš„é”
        self.user_client: Optional[TelegramClient] = None
        self.main_loop: Optional[asyncio.AbstractEventLoop] = None  # ä¿å­˜ä¸»äº‹ä»¶å¾ªç¯

        # æ–°å¢ï¼šBç«™è‡ªåŠ¨ä¸‹è½½å…¨é›†é…ç½®
        self.bilibili_auto_playlist = self.config.get("bilibili_auto_playlist", False)  # é»˜è®¤å…³é—­è‡ªåŠ¨ä¸‹è½½å…¨é›†

        # æ–°å¢ï¼šYouTubeéŸ³é¢‘æ¨¡å¼é…ç½®
        self.youtube_audio_mode = self.config.get("youtube_audio_mode", False)  # é»˜è®¤å…³é—­éŸ³é¢‘æ¨¡å¼

        # æ–°å¢ï¼šYouTube Mixæ’­æ”¾åˆ—è¡¨è‡ªåŠ¨ä¸‹è½½é…ç½®
        self.youtube_mix_playlist = self.config.get("youtube_mix_playlist", False)  # é»˜è®¤å…³é—­Mixæ’­æ”¾åˆ—è¡¨ä¸‹è½½

        # æ–°å¢ï¼šYouTube IDæ ‡ç­¾é…ç½®
        self.youtube_id_tags = self.config.get("youtube_id_tags", False)  # é»˜è®¤å…³é—­IDæ ‡ç­¾

        # æ–°å¢ï¼šBç«™å¼¹å¹•ä¸‹è½½é…ç½®
        self.bilibili_danmaku_download = self.config.get("bilibili_danmaku_download", False)  # é»˜è®¤å…³é—­å¼¹å¹•ä¸‹è½½

        # æ–°å¢ï¼šBç«™UGCæ’­æ”¾åˆ—è¡¨è‡ªåŠ¨ä¸‹è½½é…ç½®
        self.bilibili_ugc_playlist = self.config.get("bilibili_ugc_playlist", False)  # é»˜è®¤å…³é—­UGCåˆé›†ä¸‹è½½

        # æ–°å¢ï¼šç½‘æ˜“äº‘æ­Œè¯åˆå¹¶é…ç½®
        self.netease_lyrics_merge = self.config.get("netease_lyrics_merge", False)  # é»˜è®¤å…³é—­æ­Œè¯åˆå¹¶

        # æ–°å¢ï¼šç½‘æ˜“äº‘artistä¸‹è½½é…ç½®
        self.netease_artist_download = self.config.get("netease_artist_download", True)  # é»˜è®¤å¼€å¯artistä¸‹è½½

        # æ–°å¢ï¼šç½‘æ˜“äº‘coverä¸‹è½½é…ç½®
        self.netease_cover_download = self.config.get("netease_cover_download", True)  # é»˜è®¤å¼€å¯coverä¸‹è½½

        # æ–°å¢ï¼šYouTubeå°é¢ä¸‹è½½é…ç½®
        self.youtube_thumbnail_download = self.config.get("youtube_thumbnail_download", False)  # é»˜è®¤å…³é—­å°é¢ä¸‹è½½

        # æ–°å¢ï¼šYouTubeå­—å¹•ä¸‹è½½é…ç½®
        self.youtube_subtitle_download = self.config.get("youtube_subtitle_download", False)  # é»˜è®¤å…³é—­å­—å¹•ä¸‹è½½

        # æ–°å¢ï¼šYouTubeæ—¶é—´æˆ³å‘½åé…ç½®
        self.youtube_timestamp_naming = self.config.get("youtube_timestamp_naming", False)  # é»˜è®¤å…³é—­æ—¶é—´æˆ³å‘½å

        # æ–°å¢ï¼šBç«™å°é¢ä¸‹è½½é…ç½®
        self.bilibili_thumbnail_download = self.config.get("bilibili_thumbnail_download", False)  # é»˜è®¤å…³é—­Bç«™å°é¢ä¸‹è½½

        # Bç«™æ”¶è—å¤¹è®¢é˜…ç®¡ç†å™¨ - ç¡®ä¿å±æ€§å§‹ç»ˆå­˜åœ¨
        self.fav_manager = None  # å…ˆè®¾ç½®é»˜è®¤å€¼
        try:
            self.fav_manager = BilibiliFavSubscriptionManager(
                download_path=self.downloader.download_path,
                proxy_host=self.downloader.proxy_host,
                cookies_path=self.downloader.b_cookies_path
            )
            logger.info("âœ… Bç«™æ”¶è—å¤¹è®¢é˜…ç®¡ç†å™¨åˆå§‹åŒ–æˆåŠŸ")
        except Exception as e:
            logger.warning(f"âš ï¸ åˆå§‹åŒ– Bç«™æ”¶è—å¤¹è®¢é˜…ç®¡ç†å™¨å¤±è´¥: {e}")
            # self.fav_manager å·²ç»æ˜¯ None

        # qBittorrent é…ç½® - ä¼˜å…ˆä»TOMLé…ç½®æ–‡ä»¶è¯»å–ï¼Œå›é€€åˆ°ç¯å¢ƒå˜é‡
        self.qb_config = {
            "host": None,
            "port": None,
            "username": None,
            "password": None,
            "enabled": False,  # é»˜è®¤ç¦ç”¨
        }

        # å°è¯•ä»TOMLé…ç½®æ–‡ä»¶è¯»å–qBittorrenté…ç½®
        toml_config = None
        if load_toml_config and get_qbittorrent_config:
            try:
                # å°è¯•å¤šä¸ªå¯èƒ½çš„é…ç½®æ–‡ä»¶è·¯å¾„
                config_paths = [
                    "savextube.toml",
                    "savextube_full.toml",
                    "/app/config/savextube.toml",
                    "config.toml"
                ]
                
                for config_path in config_paths:
                    if os.path.exists(config_path):
                        logger.info(f"ğŸ“– å°è¯•ä»TOMLé…ç½®æ–‡ä»¶è¯»å–qBittorrenté…ç½®: {config_path}")
                        toml_config = load_toml_config(config_path)
                        if toml_config:
                            qb_toml_config = get_qbittorrent_config(toml_config)
                            if qb_toml_config and all(qb_toml_config.values()):
                                self.qb_config.update(qb_toml_config)
                                logger.info(f"âœ… ä»TOMLé…ç½®æ–‡ä»¶æˆåŠŸè¯»å–qBittorrenté…ç½®: {config_path}")
                                break
            except Exception as e:
                logger.warning(f"âš ï¸ ä»TOMLé…ç½®æ–‡ä»¶è¯»å–qBittorrenté…ç½®å¤±è´¥: {e}")

        # å¦‚æœTOMLé…ç½®ä¸å®Œæ•´ï¼Œå°è¯•ä»ç¯å¢ƒå˜é‡è¯»å–
        if not all([self.qb_config["host"], self.qb_config["port"], 
                   self.qb_config["username"], self.qb_config["password"]]):
            logger.info("ğŸ“– ä»ç¯å¢ƒå˜é‡è¯»å–qBittorrenté…ç½®")
            env_config = {
                "host": os.getenv("QB_HOST"),
                "port": os.getenv("QB_PORT"),
                "username": os.getenv("QB_USERNAME"),
                "password": os.getenv("QB_PASSWORD"),
            }
            
            # åªæ›´æ–°æœªè®¾ç½®çš„é…ç½®é¡¹
            for key, value in env_config.items():
                if value and not self.qb_config[key]:
                    self.qb_config[key] = value

        # æ£€æŸ¥æ˜¯å¦æœ‰å®Œæ•´çš„ qBittorrent é…ç½®
        if all([
            self.qb_config["host"],
            self.qb_config["port"],
            self.qb_config["username"],
            self.qb_config["password"],
        ]):
            try:
                self.qb_config["port"] = int(self.qb_config["port"])
                self.qb_config["enabled"] = True
                logger.info(f"âœ… å·²é…ç½® qBittorrent: {self.qb_config['host']}:{self.qb_config['port']}")
            except (ValueError, TypeError):
                logger.warning("qBittorrent ç«¯å£é…ç½®æ— æ•ˆï¼Œè·³è¿‡è¿æ¥")
        else:
            logger.info("âŒ æœªé…ç½® qBittorrent (ç¼ºå°‘å¿…è¦çš„é…ç½®é¡¹)")

        # æ–°å¢ï¼šæƒé™ç®¡ç†
        self.allowed_user_ids = self._parse_user_ids(os.getenv("TELEGRAM_BOT_ALLOWED_USER_IDS", ""))
        logger.info(f"ğŸ” å…è®¸çš„ç”¨æˆ·: {self.allowed_user_ids}")

    async def hot_reload_user_client(self, session_string: str, api_id: Optional[str] = None, api_hash: Optional[str] = None) -> str:
        """åœ¨ä¸»äº‹ä»¶å¾ªç¯ä¸­çƒ­é‡è½½ Telethon user_client"""
        try:
            # æ–­å¼€æ—§å®¢æˆ·ç«¯
            if self.user_client:
                try:
                    await self.user_client.disconnect()
                except Exception:
                    pass
                self.user_client = None

            # å‚æ•°å…œåº•
            api_id = api_id or os.getenv("TELEGRAM_BOT_API_ID")
            api_hash = api_hash or os.getenv("TELEGRAM_BOT_API_HASH")
            if not api_id or not api_hash:
                return "missing api_id/api_hash"

            # æ„å»ºæ–°å®¢æˆ·ç«¯
            # ä½¿ç”¨64ä½æ•´æ•°å¤„ç†å¤§çš„API ID
            try:
                api_id_int = int(api_id)
                if api_id_int > 2147483647:  # å¦‚æœè¶…è¿‡32ä½æ•´æ•°èŒƒå›´
                    logger.info(f"ğŸ” API ID {api_id_int} è¶…è¿‡32ä½æ•´æ•°èŒƒå›´ï¼Œä½¿ç”¨64ä½å¤„ç†")
            except (ValueError, OverflowError) as e:
                logger.error(f"âŒ API IDè½¬æ¢å¤±è´¥: {e}")
                return f"error: invalid api_id format"

            client = TelegramClient(StringSession(session_string), api_id_int, api_hash)

            # ä»£ç†é…ç½®
            if self.downloader and getattr(self.downloader, "proxy_host", None):
                from urllib.parse import urlparse
                p_url = urlparse(self.downloader.proxy_host)
                proxy_config = (p_url.scheme, p_url.hostname, p_url.port)
                client.set_proxy(proxy_config)

            await client.start()
            self.user_client = client
            logger.info("âœ… Telethon å®¢æˆ·ç«¯çƒ­é‡è½½æˆåŠŸ")
            return "ok"
        except Exception as e:
            logger.error(f"âŒ Telethon å®¢æˆ·ç«¯çƒ­é‡è½½å¤±è´¥: {e}", exc_info=True)
            return f"error: {e}"

    def schedule_hot_reload(self, session_string: str, api_id: Optional[str] = None, api_hash: Optional[str] = None) -> str:
        """è·¨çº¿ç¨‹è°ƒåº¦çƒ­é‡è½½ï¼Œä¾›Flaskè·¯ç”±è°ƒç”¨"""
        if not self.main_loop:
            return "no main loop"

        fut = asyncio.run_coroutine_threadsafe(
            self.hot_reload_user_client(session_string, api_id, api_hash),
            self.main_loop
        )
        try:
            return fut.result(timeout=30)
        except Exception as e:
            return f"error: {e}"

    def _parse_user_ids(self, user_ids_str: str) -> list:
        """è§£æç”¨æˆ·IDå­—ç¬¦ä¸²ä¸ºåˆ—è¡¨"""
        if not user_ids_str:
            return []

        try:
            # æ”¯æŒé€—å·ã€åˆ†å·ã€ç©ºæ ¼åˆ†éš”çš„ç”¨æˆ·ID
            user_ids = []
            for user_id_str in re.split(r"[,;\s]+", user_ids_str.strip()):
                if user_id_str.strip():
                    user_ids.append(int(user_id_str.strip()))
            return user_ids
        except ValueError as e:
            logger.error(f"è§£æç”¨æˆ·IDå¤±è´¥: {e}")
            return []

    def _check_user_permission(self, user_id: int) -> bool:
        """æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æœ‰æƒé™ä½¿ç”¨æœºå™¨äºº"""
        # å¦‚æœæ²¡æœ‰é…ç½®å…è®¸çš„ç”¨æˆ·ï¼Œåˆ™å…è®¸æ‰€æœ‰ç”¨æˆ·ï¼ˆå‘åå…¼å®¹ï¼‰
        if not self.allowed_user_ids:
            return True

        # æ£€æŸ¥æ˜¯å¦åœ¨å…è®¸çš„ç”¨æˆ·åˆ—è¡¨ä¸­
        return user_id in self.allowed_user_ids

    def _save_config_sync(self, config_data=None):
        """åŒæ­¥ä¿å­˜é…ç½®åˆ°æ•°æ®åº“"""
        try:
            if config_data is None:
                config_data = {
                    "auto_download_enabled": self.auto_download_enabled,
                    "bilibili_auto_playlist": self.bilibili_auto_playlist,
                    "youtube_audio_mode": self.youtube_audio_mode,
                    "youtube_id_tags": self.youtube_id_tags,
                    "bilibili_danmaku_download": self.bilibili_danmaku_download,
                    "bilibili_ugc_playlist": self.bilibili_ugc_playlist,
                    "youtube_thumbnail_download": self.youtube_thumbnail_download,
                    "youtube_subtitle_download": self.youtube_subtitle_download,
                    "youtube_timestamp_naming": self.youtube_timestamp_naming,
                    "bilibili_thumbnail_download": self.bilibili_thumbnail_download,
                    "netease_lyrics_merge": self.netease_lyrics_merge,
                    "netease_artist_download": self.netease_artist_download,
                    "netease_cover_download": self.netease_cover_download,
                    "youtube_mix_playlist": self.youtube_mix_playlist
                }

            # ä½¿ç”¨æ•°æ®åº“ä¿å­˜é…ç½®
            if self.config_manager:
                try:
                    for key, value in config_data.items():
                        self.config_manager.set_config(key, value)
                    logger.info("é…ç½®å·²ä¿å­˜åˆ°æ•°æ®åº“")
                except Exception as e:
                    logger.error(f"âŒ æ•°æ®åº“ä¿å­˜å¤±è´¥: {e}")
                    raise  # ç›´æ¥æŠ›å‡ºå¼‚å¸¸ï¼Œä¸å›é€€åˆ°æ–‡ä»¶ä¿å­˜
            else:
                logger.error("âŒ é…ç½®ç®¡ç†å™¨æœªåˆå§‹åŒ–")
                raise Exception("é…ç½®ç®¡ç†å™¨æœªåˆå§‹åŒ–")
        except Exception as e:
            logger.error(f"ä¿å­˜é…ç½®å¤±è´¥: {e}")
            raise  # ç›´æ¥æŠ›å‡ºå¼‚å¸¸ï¼Œä¸å›é€€åˆ°æ–‡ä»¶ä¿å­˜

    async def _save_config_async(self):
        """å¼‚æ­¥ä¿å­˜é…ç½®åˆ°æ–‡ä»¶æˆ–æ•°æ®åº“"""
        loop = asyncio.get_running_loop()
        await loop.run_in_executor(None, self._save_config_sync)



    def _extract_duration_from_filename(self, filename: str) -> str:
        """ä»æ–‡ä»¶åä¸­æå–æ—¶é•¿ä¿¡æ¯"""
        try:
            # å¸¸è§çš„æ—¶é•¿æ ¼å¼ï¼šæ–‡ä»¶åä¸­åŒ…å«æ—¶é•¿ä¿¡æ¯
            # ä¾‹å¦‚ï¼šæ­Œæ›²å (3:45).m4a æˆ– æ­Œæ›²å [3:45].m4a
            import re
            
            # åŒ¹é… (MM:SS) æˆ– [MM:SS] æ ¼å¼
            duration_pattern = r'[\(\[\]]([0-9]+):([0-9]{2})[\)\]]'
            match = re.search(duration_pattern, filename)
            
            if match:
                minutes = int(match.group(1))
                seconds = int(match.group(2))
                return f"{minutes}:{seconds:02d}"
            
            # å¦‚æœæ²¡æœ‰æ‰¾åˆ°æ—¶é•¿ä¿¡æ¯ï¼Œè¿”å›é»˜è®¤å€¼
            return "æœªçŸ¥"
            
        except Exception:
            return "æœªçŸ¥"
    
    def _escape_markdown(self, text: str) -> str:
        """è½¬ä¹‰Markdownç‰¹æ®Šå­—ç¬¦"""
        if not text:
            return text

        # å…ˆè½¬ä¹‰åæ–œæ ï¼Œé¿å…é‡å¤è½¬ä¹‰
        escaped_text = text.replace("\\", "\\\\")

        # éœ€è¦è½¬ä¹‰çš„ç‰¹æ®Šå­—ç¬¦ï¼ˆä¸åŒ…æ‹¬åæ–œæ ï¼Œå› ä¸ºå·²ç»å¤„ç†è¿‡äº†ï¼‰
        special_chars = [
            "_",
            "*",
            "[",
            "]",
            "(",
            ")",
            "~",
            "`",
            ">",
            "#",
            "+",
            "-",
            "=",
            "|",
            "{",
            "}",
            ".",
            "!",
        ]

        for char in special_chars:
            escaped_text = escaped_text.replace(char, f"\\{char}")

        return escaped_text

    def _get_netease_quality_info(self, quality: str) -> dict:
        """è·å–ç½‘æ˜“äº‘éŸ³è´¨çš„è¯¦ç»†ä¿¡æ¯ï¼ˆåç§°ã€æ ¼å¼ã€ç ç‡ï¼‰"""
        # éŸ³è´¨æ˜ å°„è¡¨
        quality_map = {
            'standard': '128k',
            'higher': '320k', 
            'exhigh': '320k',
            'lossless': 'flac',
            'hires': 'flac24bit',
            'jyeffect': 'flac24bit',
            'jymaster': 'flac24bit',
            'sky': 'flac24bit',
            # å…¼å®¹æ—§å‚æ•°
            'high': '320k',
            'master': 'flac24bit',
            'surround': 'flac24bit'
        }
        
        # è¯¦ç»†éŸ³è´¨ä¿¡æ¯
        quality_info_map = {
            '128k': {'name': 'æ ‡å‡†', 'format': 'MP3', 'bitrate': '16bit/44khz/128kbps'},
            '320k': {'name': 'è¾ƒé«˜', 'format': 'MP3', 'bitrate': '16bit/44khz/320kbps'},
            'flac': {'name': 'æ— æŸ', 'format': 'FLAC', 'bitrate': '16bit/44khz/1058kbps'},
            'flac24bit': {'name': 'é«˜è§£æåº¦æ— æŸ', 'format': 'FLAC', 'bitrate': '24bit/96khz/2016kbps'}
        }
        
        # è·å–è´¨é‡ä»£ç 
        quality_code = quality_map.get(quality, quality)
        
        # è¿”å›è¯¦ç»†ä¿¡æ¯
        return quality_info_map.get(quality_code, {
            'name': quality.upper(),
            'format': 'Unknown',
            'bitrate': 'Unknown'
        })
    
    def _get_qqmusic_quality_info(self, quality: str) -> dict:
        """è·å–QQéŸ³ä¹éŸ³è´¨çš„è¯¦ç»†ä¿¡æ¯ï¼ˆåç§°ã€æ ¼å¼ã€ç ç‡ï¼‰"""
        # éŸ³è´¨æ˜ å°„è¡¨
        quality_map = {
            'best': 'flac',
            'flac': 'flac',
            '320mp3': '320k',
            '128mp3': '128k',
            '96aac': '96k',
            '48aac': '48k',
            # å…¼å®¹å…¶ä»–æ ¼å¼
            'high': '320k',
            'standard': '128k',
            'lossless': 'flac'
        }
        
        # è¯¦ç»†éŸ³è´¨ä¿¡æ¯
        quality_info_map = {
            '48k': {'name': 'AACæ ‡å‡†', 'format': 'AAC', 'bitrate': '48kbps'},
            '96k': {'name': 'AACè¾ƒé«˜', 'format': 'AAC', 'bitrate': '96kbps'},
            '128k': {'name': 'MP3æ ‡å‡†', 'format': 'MP3', 'bitrate': '16bit/44khz/128kbps'},
            '320k': {'name': 'MP3é«˜å“è´¨', 'format': 'MP3', 'bitrate': '16bit/44khz/320kbps'},
            'flac': {'name': 'FLACæ— æŸ', 'format': 'FLAC', 'bitrate': '16bit/44khz/1058kbps'}
        }
        
        # è·å–è´¨é‡ä»£ç 
        quality_code = quality_map.get(quality, quality)
        
        # è¿”å›è¯¦ç»†ä¿¡æ¯
        return quality_info_map.get(quality_code, {
            'name': quality.upper(),
            'format': 'Unknown',
            'bitrate': 'Unknown'
        })

    def _extract_artist_from_path(self, download_path: str, album_name: str, songs: list = None) -> str:
        """ä»ä¸‹è½½è·¯å¾„æˆ–æ­Œæ›²åˆ—è¡¨ä¸­æå–è‰ºæœ¯å®¶ä¿¡æ¯"""
        try:
            # é¦–å…ˆå°è¯•ä»æ­Œæ›²åˆ—è¡¨ä¸­æå–è‰ºæœ¯å®¶
            if songs and len(songs) > 0:
                artist_counts = {}
                for song in songs[:5]:  # åªæ£€æŸ¥å‰5é¦–æ­Œï¼Œæé«˜æ•ˆç‡
                    song_title = song.get('title', '')
                    if ' - ' in song_title:
                        # æ ¼å¼ï¼šæ­Œæ›²å - è‰ºæœ¯å®¶
                        artist = song_title.split(' - ')[1].strip()
                        # å»é™¤åˆä½œè‰ºæœ¯å®¶æ ‡è¯†
                        if ',' in artist:
                            artist = artist.split(',')[0].strip()
                        # ç»Ÿè®¡è‰ºæœ¯å®¶å‡ºç°æ¬¡æ•°
                        if artist and artist != '':
                            artist_counts[artist] = artist_counts.get(artist, 0) + 1
                
                # é€‰æ‹©å‡ºç°æ¬¡æ•°æœ€å¤šçš„è‰ºæœ¯å®¶
                if artist_counts:
                    most_common_artist = max(artist_counts, key=artist_counts.get)
                    if most_common_artist:
                        return most_common_artist
            
            # ä»è·¯å¾„ä¸­æå–è‰ºæœ¯å®¶ä¿¡æ¯
            # è·¯å¾„æ ¼å¼é€šå¸¸æ˜¯ï¼š/downloads/Netease/è‰ºæœ¯å®¶/ä¸“è¾‘åç§°
            path_parts = download_path.split('/')
            
            # æŸ¥æ‰¾å¯èƒ½çš„è‰ºæœ¯å®¶ç›®å½•ï¼ˆæ’é™¤ä¸“è¾‘åå’Œç³»ç»Ÿç›®å½•ï¼‰
            for part in reversed(path_parts):
                if (part and 
                    part != album_name and 
                    not part.startswith('downloads') and
                    not part.startswith('Netease') and
                    not part.startswith('netease') and
                    part != 'v04' and
                    not part.endswith('(2016)') and  # æ’é™¤å¹´ä»½ä¿¡æ¯
                    not part.endswith('(2017)') and
                    not part.endswith('(2018)') and
                    not part.endswith('(2019)') and
                    not part.endswith('(2020)') and
                    not part.endswith('(2021)') and
                    not part.endswith('(2022)') and
                    not part.endswith('(2023)') and
                    not part.endswith('(2024)')):
                    return part
            
            # å¦‚æœè·¯å¾„ä¸­æ²¡æœ‰æ‰¾åˆ°è‰ºæœ¯å®¶ï¼Œå°è¯•ä»ä¸“è¾‘åç§°ä¸­æå–
            if ' - ' in album_name:
                artist = album_name.split(' - ')[0].strip()
                return artist
            
            # é»˜è®¤è¿”å›æœªçŸ¥è‰ºæœ¯å®¶
            return "æœªçŸ¥è‰ºæœ¯å®¶"
                
        except Exception as e:
            logger.warning(f"æå–è‰ºæœ¯å®¶ä¿¡æ¯å¤±è´¥: {e}")
            return "æœªçŸ¥è‰ºæœ¯å®¶"

    async def post_init(self, application: Application):
        """åœ¨åº”ç”¨å¯åŠ¨åè¿è¡Œçš„åˆå§‹åŒ–ä»»åŠ¡, è·å–æœºå™¨äººè‡ªèº« ID"""
        print("ğŸš€ [INIT] post_init å¼€å§‹æ‰§è¡Œ...")
        bot_info = await application.bot.get_me()
        self.bot_id = bot_info.id
        print(f"ğŸ¤– [INIT] æœºå™¨äººå·²å¯åŠ¨: @{bot_info.username} (ID: {self.bot_id})")
        logger.info(f"æœºå™¨äººå·²å¯åŠ¨ï¼Œç”¨æˆ·åä¸º: @{bot_info.username} (ID: {self.bot_id})")

        # è®¾ç½®å‘½ä»¤èœå•
        print("ğŸ”§ [INIT] å‡†å¤‡è®¾ç½®å‘½ä»¤èœå•...")
        await self._setup_bot_commands(application.bot)
        print("âœ… [INIT] post_init æ‰§è¡Œå®Œæˆ")

    async def _setup_bot_commands(self, bot: Bot):
        """è®¾ç½®Botå‘½ä»¤èœå•"""
        try:
            print("ğŸ”§ [MENU] å¼€å§‹è®¾ç½®Telegram Botå‘½ä»¤èœå•...")
            logger.info("ğŸ”§ å¼€å§‹è®¾ç½®Telegram Botå‘½ä»¤èœå•...")

            # å®šä¹‰å‘½ä»¤èœå•
            from telegram import BotCommand
            commands = [
                BotCommand("start", "ğŸ å¼€å§‹ä½¿ç”¨"),
                BotCommand("help", "ğŸ“– æŸ¥çœ‹å¸®åŠ©"),
                BotCommand("status", "ğŸ“Š æŸ¥çœ‹ä¸‹è½½ç»Ÿè®¡"),
                BotCommand("cancel", "âŒ å–æ¶ˆä¸‹è½½ä»»åŠ¡"),
                BotCommand("version", "ğŸ”§ æŸ¥çœ‹ç‰ˆæœ¬ä¿¡æ¯"),
                BotCommand("settings", "âš™ï¸ åŠŸèƒ½è®¾ç½®"),
                BotCommand("favsub", "ğŸ“š Bç«™æ”¶è—å¤¹è®¢é˜…ä¸‹è½½"),
                BotCommand("cleanup", "ğŸ§¹ æ¸…ç†ä¸´æ—¶æ–‡ä»¶"),
                BotCommand("reboot", "ğŸ”„ é‡å¯å®¹å™¨"),
            ]

            print(f"ğŸ”§ [MENU] å‡†å¤‡è®¾ç½® {len(commands)} ä¸ªå‘½ä»¤")
            for i, cmd in enumerate(commands, 1):
                print(f"  {i}. /{cmd.command} - {cmd.description}")

            # è®¾ç½®å‘½ä»¤èœå•
            print("ğŸ”§ [MENU] æ­£åœ¨è°ƒç”¨ set_my_commands...")
            await bot.set_my_commands(commands)
            print("âœ… [MENU] set_my_commands è°ƒç”¨æˆåŠŸ")
            logger.info(f"âœ… å·²æˆåŠŸè®¾ç½®Telegram Botå‘½ä»¤èœå•ï¼Œå…± {len(commands)} ä¸ªå‘½ä»¤")

            # éªŒè¯è®¾ç½®
            print("ğŸ” [MENU] éªŒè¯å‘½ä»¤èœå•è®¾ç½®...")
            set_commands = await bot.get_my_commands()
            print(f"ğŸ” [MENU] è·å–åˆ° {len(set_commands)} ä¸ªå·²è®¾ç½®çš„å‘½ä»¤")

            if len(set_commands) == len(commands):
                print("ğŸ‰ [MENU] å‘½ä»¤èœå•è®¾ç½®å®Œå…¨æˆåŠŸï¼")
                logger.info("ğŸ‰ å‘½ä»¤èœå•è®¾ç½®å®Œå…¨æˆåŠŸï¼")
                logger.info("ğŸ“‹ å¯ç”¨å‘½ä»¤:")
                for cmd in set_commands:
                    print(f"  âœ… /{cmd.command} - {cmd.description}")
                    logger.info(f"  /{cmd.command} - {cmd.description}")
            else:
                print(f"âš ï¸ [MENU] å‘½ä»¤èœå•è®¾ç½®å¯èƒ½æœ‰é—®é¢˜ï¼ŒæœŸæœ› {len(commands)} ä¸ªï¼Œå®é™… {len(set_commands)} ä¸ª")
                logger.warning(f"âš ï¸ å‘½ä»¤èœå•è®¾ç½®å¯èƒ½æœ‰é—®é¢˜ï¼ŒæœŸæœ› {len(commands)} ä¸ªï¼Œå®é™… {len(set_commands)} ä¸ª")

        except Exception as e:
            print(f"âŒ [MENU] è®¾ç½®å‘½ä»¤èœå•å¤±è´¥: {e}")
            logger.error(f"âŒ è®¾ç½®å‘½ä»¤èœå•å¤±è´¥: {e}")
            import traceback
            print(f"âŒ [MENU] è¯¦ç»†é”™è¯¯: {traceback.format_exc()}")
            logger.error(f"è¯¦ç»†é”™è¯¯: {traceback.format_exc()}")

    def _connect_qbittorrent(self):
        """è¿æ¥åˆ° qBittorrent å®¢æˆ·ç«¯"""
        try:
            # æ£€æŸ¥æ˜¯å¦å¯ç”¨äº† qBittorrent
            if not self.qb_config["enabled"]:
                return

            logger.info(
                f"æ­£åœ¨è¿æ¥ qBittorrent: {self.qb_config['host']}:{self.qb_config['port']}"
            )

            # åˆ›å»ºå®¢æˆ·ç«¯
            self.qbit_client = qbittorrentapi.Client(
                host=self.qb_config["host"],
                port=self.qb_config["port"],
                username=self.qb_config["username"],
                password=self.qb_config["password"],
                VERIFY_WEBUI_CERTIFICATE=False,  # ç¦ç”¨SSLè¯ä¹¦éªŒè¯
                REQUESTS_ARGS={"timeout": 10},  # è®¾ç½®10ç§’è¶…æ—¶
            )

            # å°è¯•ç™»å½•
            self.qbit_client.auth_log_in()

            # æ£€æŸ¥è¿æ¥çŠ¶æ€
            if not self.qbit_client.is_logged_in:
                logger.error("qBittorrent è¿æ¥å¤±è´¥")
                self.qbit_client = None
                return

            # è·å– qBittorrent ç‰ˆæœ¬ä¿¡æ¯
            try:
                version_info = self.qbit_client.app.version
                logger.info(f"qBittorrent è¿æ¥æˆåŠŸ (ç‰ˆæœ¬: {version_info})")
            except Exception as e:
                logger.info("qBittorrent è¿æ¥æˆåŠŸ")

            # åˆ›å»ºæ ‡ç­¾
            try:
                self.qbit_client.torrents_create_tags(tags="savextube")
            except Exception:
                pass

        except qbittorrentapi.LoginFailed as e:
            logger.error("qBittorrent è¿æ¥å¤±è´¥: ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯")
            self.qbit_client = None
        except qbittorrentapi.APIConnectionError as e:
            logger.error("qBittorrent è¿æ¥å¤±è´¥: æ— æ³•è¿æ¥åˆ°æœåŠ¡å™¨")
            self.qbit_client = None
        except Exception as e:
            logger.error(f"qBittorrent è¿æ¥å¤±è´¥: {e}")
            self.qbit_client = None

    def _is_magnet_link(self, text: str) -> bool:
        magnet_pattern = r"magnet:\?xt=urn:btih:[a-fA-F0-9]{32,40}"
        return bool(re.search(magnet_pattern, text))

    def _extract_magnet_links(self, text: str):
        # æ”¯æŒå¤šæ¡ç£åŠ›é“¾æ¥ï¼Œå¿½ç•¥å‰åå…¶å®ƒæ–‡å­—
        magnet_pattern = r"(magnet:\?xt=urn:btih:[a-fA-F0-9]{32,40}[^\s]*)"
        return re.findall(magnet_pattern, text)

    async def add_magnet_to_qb(self, magnet_link: str) -> bool:
        """æ·»åŠ ç£åŠ›é“¾æ¥åˆ° qBittorrent"""
        try:
            # æ£€æŸ¥ qBittorrent å®¢æˆ·ç«¯æ˜¯å¦å¯ç”¨
            if not self.qbit_client:
                logger.error("qBittorrent å®¢æˆ·ç«¯æœªè¿æ¥")
                return False

            # æ£€æŸ¥ç™»å½•çŠ¶æ€
            if not self.qbit_client.is_logged_in:
                logger.error("qBittorrent æœªç™»å½•")
                return False

            # éªŒè¯ç£åŠ›é“¾æ¥æ ¼å¼
            if not self._is_magnet_link(magnet_link):
                logger.error(f"æ— æ•ˆçš„ç£åŠ›é“¾æ¥æ ¼å¼: {magnet_link}")
                return False

            logger.info(f"æ­£åœ¨æ·»åŠ ç£åŠ›é“¾æ¥åˆ° qBittorrent: {magnet_link[:50]}...")

            # æ·»åŠ ç£åŠ›é“¾æ¥
            self.qbit_client.torrents_add(urls=magnet_link, tags="savextube")

            logger.info("âœ… æˆåŠŸæ·»åŠ ç£åŠ›é“¾æ¥åˆ° qBittorrent")
            return True

        except qbittorrentapi.APIConnectionError as e:
            logger.error(f"qBittorrent API è¿æ¥é”™è¯¯: {e}")
            return False
        except qbittorrentapi.LoginFailed as e:
            logger.error(f"qBittorrent ç™»å½•å¤±è´¥: {e}")
            return False
        except Exception as e:
            logger.error(f"æ·»åŠ ç£åŠ›é“¾æ¥å¤±è´¥: {e}")
            logger.error(f"é”™è¯¯ç±»å‹: {type(e).__name__}")
            return False

    async def add_torrent_file_to_qb(self, torrent_data: bytes, filename: str) -> bool:
        """æ·»åŠ ç§å­æ–‡ä»¶åˆ° qBittorrent"""
        try:
            # æ£€æŸ¥ qBittorrent å®¢æˆ·ç«¯æ˜¯å¦å¯ç”¨
            if not self.qbit_client:
                logger.error("qBittorrent å®¢æˆ·ç«¯æœªè¿æ¥")
                return False

            # æ£€æŸ¥ç™»å½•çŠ¶æ€
            if not self.qbit_client.is_logged_in:
                logger.error("qBittorrent æœªç™»å½•")
                return False

            logger.info(f"æ­£åœ¨æ·»åŠ ç§å­æ–‡ä»¶åˆ° qBittorrent: {filename}")

            # å°†å­—èŠ‚æ•°æ®å†™å…¥ä¸´æ—¶æ–‡ä»¶
            import tempfile
            import os

            with tempfile.NamedTemporaryFile(delete=False, suffix='.torrent') as temp_file:
                temp_file.write(torrent_data)
                temp_file_path = temp_file.name

            try:
                # ä½¿ç”¨ä¸´æ—¶æ–‡ä»¶è·¯å¾„æ·»åŠ ç§å­
                self.qbit_client.torrents_add(torrent_files=temp_file_path, tags="savextube")
                logger.info("âœ… æˆåŠŸæ·»åŠ ç§å­æ–‡ä»¶åˆ° qBittorrent")
                return True
            finally:
                # æ¸…ç†ä¸´æ—¶æ–‡ä»¶
                try:
                    os.unlink(temp_file_path)
                except Exception as e:
                    logger.warning(f"æ¸…ç†ä¸´æ—¶æ–‡ä»¶å¤±è´¥: {e}")

        except qbittorrentapi.APIConnectionError as e:
            logger.error(f"qBittorrent API è¿æ¥é”™è¯¯: {e}")
            return False
        except qbittorrentapi.LoginFailed as e:
            logger.error(f"qBittorrent ç™»å½•å¤±è´¥: {e}")
            return False
        except Exception as e:
            logger.error(f"æ·»åŠ ç§å­æ–‡ä»¶å¤±è´¥: {e}")
            logger.error(f"é”™è¯¯ç±»å‹: {type(e).__name__}")
            return False



    def _get_resolution_quality(self, resolution):
        """æ ¹æ®åˆ†è¾¨ç‡ç”Ÿæˆè´¨é‡æ ‡è¯†ï¼Œå¦‚æœå·²æœ‰è´¨é‡æ ‡è¯†åˆ™ä¸é‡å¤æ·»åŠ """
        if not resolution or resolution == 'æœªçŸ¥':
            return ''

        # æ£€æŸ¥æ˜¯å¦å·²ç»åŒ…å«è´¨é‡æ ‡è¯†
        import re
        quality_patterns = [r'\(8K\)', r'\(4K\)', r'\(2K\)', r'\(1080[Pp]\)', r'\(720[Pp]\)', r'\(480[Pp]\)', r'\(360[Pp]\)', r'\(\d+[Pp]\)']
        if any(re.search(pattern, resolution) for pattern in quality_patterns):
            return ''  # å·²ç»æœ‰è´¨é‡æ ‡è¯†ï¼Œä¸é‡å¤æ·»åŠ 

        # æå–åˆ†è¾¨ç‡æ•°å­—
        match = re.search(r'(\d+)x(\d+)', resolution)
        if not match:
            # å°è¯•åŒ¹é…å•ä¸ªæ•°å­—ï¼ˆå¦‚"1080 (1080p)"ï¼‰
            height_match = re.search(r'(\d+)', resolution)
            if height_match:
                try:
                    height = int(height_match.group(1))
                    # æ ¹æ®é«˜åº¦åˆ¤æ–­è´¨é‡
                    if height >= 4320:
                        return ' (8K)'
                    elif height >= 2160:
                        return ' (4K)'
                    elif height >= 1440:
                        return ' (2K)'
                    elif height >= 1080:
                        return ' (1080P)'
                    elif height >= 720:
                        return ' (720P)'
                    elif height >= 480:
                        return ' (480P)'
                    elif height >= 360:
                        return ' (360P)'
                    else:
                        return f' ({height}P)'
                except (ValueError, TypeError):
                    return ''
            return ''

        try:
            width = int(match.group(1))
            height = int(match.group(2))
        except (ValueError, TypeError):
            return ''

        # æ ¹æ®é«˜åº¦åˆ¤æ–­è´¨é‡
        if height >= 4320:
            return ' (8K)'
        elif height >= 2160:
            return ' (4K)'
        elif height >= 1440:
            return ' (2K)'
        elif height >= 1080:
            return ' (1080P)'
        elif height >= 720:
            return ' (720P)'
        elif height >= 480:
            return ' (480P)'
        elif height >= 360:
            return ' (360P)'
        else:
            return ' (ä½ç”»è´¨)'





    def _signal_handler(self, signum, frame):
        """å¤„ç†ç³»ç»Ÿä¿¡å·"""
        logger.info(f"æ”¶åˆ°ä¿¡å· {signum}ï¼Œæ­£åœ¨ä¼˜é›…å…³é—­...")
        if self.user_client:
            asyncio.create_task(self.user_client.disconnect())
        # æ³¨æ„ï¼šexecutor åœ¨è¿™ä¸ªç‰ˆæœ¬ä¸­æ²¡æœ‰ä½¿ç”¨ï¼Œæ‰€ä»¥ç§»é™¤è¿™ä¸ªè°ƒç”¨
        # if hasattr(self, 'executor') and self.executor:
        #     self.executor.shutdown(wait=True)
        sys.exit(0)

    def _setup_handlers(self):
        """è®¾ç½®æ‰€æœ‰çš„å‘½ä»¤å’Œæ¶ˆæ¯å¤„ç†å™¨"""
        if not self.application:
            return

        self.application.add_handler(CommandHandler("start", self.start_command))
        self.application.add_handler(CommandHandler("help", self.help_command))
        self.application.add_handler(CommandHandler("version", self.version_command))
        self.application.add_handler(CommandHandler("reboot", self.reboot_command))
        self.application.add_handler(CommandHandler("status", self.status_command))
        # self.application.add_handler(CommandHandler("sxt", self.sxt_command))
        # # å·²åˆ é™¤ï¼šsxtå‘½ä»¤å¤„ç†å™¨
        self.application.add_handler(CommandHandler("settings", self.settings_command))
        self.application.add_handler(CommandHandler("favsub", self.favsub_command))
        self.application.add_handler(CommandHandler("cancel", self.cancel_command))
        self.application.add_handler(CommandHandler("cleanup", self.cleanup_command))
        self.application.add_handler(
            CallbackQueryHandler(self.settings_button_handler, pattern="toggle_autop")
        )
        self.application.add_handler(
            CallbackQueryHandler(self.settings_button_handler, pattern="toggle_id_tags")
        )
        self.application.add_handler(
            CallbackQueryHandler(self.settings_button_handler, pattern="toggle_danmaku")
        )
        self.application.add_handler(
            CallbackQueryHandler(self.settings_button_handler, pattern="toggle_audio_mode")
        )
        self.application.add_handler(
            CallbackQueryHandler(self.settings_button_handler, pattern="toggle_ugc_playlist")
        )
        self.application.add_handler(
            CallbackQueryHandler(self.settings_button_handler, pattern="toggle_thumbnail")
        )
        self.application.add_handler(
            CallbackQueryHandler(self.settings_button_handler, pattern="toggle_subtitle")
        )
        self.application.add_handler(
            CallbackQueryHandler(self.settings_button_handler, pattern="toggle_timestamp")
        )
        self.application.add_handler(
            CallbackQueryHandler(self.settings_button_handler, pattern="toggle_bilibili_thumbnail")
        )
        self.application.add_handler(
            CallbackQueryHandler(self.settings_button_handler, pattern="toggle_lyrics_merge")
        )
        self.application.add_handler(
            CallbackQueryHandler(self.settings_button_handler, pattern="toggle_artist_download")
        )
        self.application.add_handler(
            CallbackQueryHandler(self.settings_button_handler, pattern="toggle_cover_download")
        )
        self.application.add_handler(
            CallbackQueryHandler(self.cancel_task_callback, pattern="cancel:")
        )
        # ç»Ÿä¸€çš„åª’ä½“å¤„ç†å™¨ï¼Œæ˜ç¡®æŒ‡å‘æ–°å‡½æ•°
        media_filter = (
            filters.AUDIO | filters.VIDEO | filters.Document.ALL
        ) & ~filters.COMMAND
        # self.application.add_handler(MessageHandler(media_filter,
        # self.handle_media)) # ç¦ç”¨æ—§çš„å¤„ç†å™¨
        self.application.add_handler(
            MessageHandler(media_filter, self.download_user_media)
        )  # å¯ç”¨æ–°å¤„ç†å™¨

        # æ–‡æœ¬æ¶ˆæ¯å¤„ç†å™¨ - ä¿æŒä¸å˜
        self.application.add_handler(
            MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_message)
        )

        # é”™è¯¯å¤„ç†å™¨
        self.application.add_error_handler(self.error_handler)
        logger.info("æ‰€æœ‰å¤„ç†å™¨å·²è®¾ç½®ã€‚")

    async def run(self):
        """å¯åŠ¨æœºå™¨äººå’Œæ‰€æœ‰å®¢æˆ·ç«¯"""
        # 0. ä¿å­˜ä¸»äº‹ä»¶å¾ªç¯
        self.main_loop = asyncio.get_running_loop()

        # 1. è¿æ¥ qBittorrent
        self._connect_qbittorrent()
        # 2. åˆå§‹åŒ–å¹¶è¿æ¥ Telethon å®¢æˆ·ç«¯
        api_id = os.getenv("TELEGRAM_BOT_API_ID")
        api_hash = os.getenv("TELEGRAM_BOT_API_HASH")
        session_string = os.getenv("TELEGRAM_SESSION_STRING")

        # å¦‚æœç¯å¢ƒå˜é‡ä¸­æ²¡æœ‰ session_stringï¼Œå°è¯•ä»å›ºå®šè·¯å¾„åŠ è½½
        if not session_string:
            # ç¡¬ç¼–ç sessionæ–‡ä»¶è·¯å¾„åˆ°/app/cookiesç›®å½•
            session_file_path = "/app/cookies/telethon_session.txt"

            if os.path.exists(session_file_path):
                try:
                    with open(session_file_path, "r", encoding="utf-8") as f:
                        session_string = f.read().strip()
                    logger.info(f"âœ… ä»æ–‡ä»¶åŠ è½½ Telethon Session: {session_file_path}")
                except Exception as e:
                    logger.warning(f"âš ï¸ è¯»å– session æ–‡ä»¶å¤±è´¥: {e}")
            else:
                logger.info(
                    f"â„¹ï¸ æœªæ‰¾åˆ° session æ–‡ä»¶: {session_file_path}ï¼Œè¯·å…ˆé€šè¿‡ /setup ç”Ÿæˆæˆ–è®¾ç½® TELEGRAM_SESSION_STRING"
                )

        logger.info("--- Telethon é…ç½®è¯Šæ–­ ---")
        logger.info(f"è¯»å– TELEGRAM_BOT_API_ID: {'å·²æ‰¾åˆ°' if api_id else 'æœªæ‰¾åˆ°'}")
        logger.info(
            f"è¯»å– TELEGRAM_BOT_API_HASH: {'å·²æ‰¾åˆ°' if api_hash else 'æœªæ‰¾åˆ°'}"
        )
        logger.info(
            f"è¯»å– TELEGRAM_SESSION_STRING: {'å·²æ‰¾åˆ°' if session_string else 'æœªæ‰¾åˆ°'}"
        )
        logger.info("--------------------------")
        if all([api_id, api_hash, session_string]):
            try:
                # ä½¿ç”¨64ä½æ•´æ•°å¤„ç†å¤§çš„API ID
                try:
                    api_id_int = int(api_id)
                    if api_id_int > 2147483647:  # å¦‚æœè¶…è¿‡32ä½æ•´æ•°èŒƒå›´
                        logger.info(f"ğŸ” API ID {api_id_int} è¶…è¿‡32ä½æ•´æ•°èŒƒå›´ï¼Œä½¿ç”¨64ä½å¤„ç†")
                except (ValueError, OverflowError) as e:
                    logger.error(f"âŒ API IDè½¬æ¢å¤±è´¥: {e}")
                    raise ValueError(f"Invalid API ID format: {api_id}")

                self.user_client = TelegramClient(
                    StringSession(session_string), api_id_int, api_hash
                )
                if self.downloader.proxy_host:
                    p_url = urlparse(self.downloader.proxy_host)
                    proxy_config = (p_url.scheme, p_url.hostname, p_url.port)
                    self.user_client.set_proxy(proxy_config)
                    logger.info(
                        f"Telethon å®¢æˆ·ç«¯ä½¿ç”¨ä»£ç†: {self.downloader.proxy_host}"
                    )
                logger.info("æ­£åœ¨è¿æ¥ Telethon å®¢æˆ·ç«¯...")
                await self.user_client.start()
                logger.info("Telethon å®¢æˆ·ç«¯è¿æ¥æˆåŠŸã€‚")
            except Exception as e:
                logger.error(f"Telethon å®¢æˆ·ç«¯å¯åŠ¨å¤±è´¥: {e}", exc_info=True)
                self.user_client = None
        else:
            logger.warning("Telethon æœªå®Œæ•´é…ç½®ï¼Œåª’ä½“è½¬å­˜åŠŸèƒ½å°†ä¸å¯ç”¨ã€‚")
        # 3. è®¾ç½®å¹¶å¯åŠ¨ PTB Application
        # åº”ç”¨ç¨‹åºå°†åœ¨é‡è¯•å¾ªç¯ä¸­åˆ›å»º

        # é…ç½®Telegram Botåº“çš„æ—¥å¿—è®°å½•å™¨ï¼Œä½¿å…¶ä½¿ç”¨savextubeå‰ç¼€
        import logging
        telegram_loggers = [
            'telegram.ext.Application',
            'telegram.ext.Updater',
            'telegram.ext.JobQueue',
            'telegram.bot'
        ]
        for logger_name in telegram_loggers:
            telegram_logger = logging.getLogger(logger_name)
            telegram_logger.name = 'savextube'

        logger.info("å¯åŠ¨ Telegram Bot (PTB)...")

        # åˆ›å»ºåº”ç”¨ç¨‹åºå®ä¾‹
        if self.downloader.proxy_host:
            logger.info(f"Telegram Bot ä½¿ç”¨ä»£ç†: {self.downloader.proxy_host}")
            self.application = (
                Application.builder().token(self.token).proxy(self.downloader.proxy_host).post_init(self.post_init).build()
            )
        else:
            logger.info("Telegram Bot ç›´æ¥è¿æ¥")
            self.application = (
                Application.builder().token(self.token).post_init(self.post_init).build()
            )
        self._setup_handlers()

        # å¯åŠ¨åº”ç”¨ç¨‹åº
        try:
            async with self.application:
                await self.application.initialize()
                await self.application.start()

                # é…ç½®æ›´å¼ºçš„ç½‘ç»œå‚æ•°
                await self.application.updater.start_polling(
                    timeout=30,  # å¢åŠ è¶…æ—¶æ—¶é—´
                    read_timeout=30,
                    write_timeout=30,
                    connect_timeout=30,
                    pool_timeout=30
                )

                logger.info("æœºå™¨äººå·²æˆåŠŸå¯åŠ¨å¹¶æ­£åœ¨è¿è¡Œã€‚")

                # å¥åº·æ£€æŸ¥åŠŸèƒ½å·²åˆ é™¤ï¼Œé¿å…äº‹ä»¶å¾ªç¯å†²çª
                asyncio.create_task(self._keep_alive_heartbeat())

                # å¯åŠ¨Bç«™æ”¶è—å¤¹è®¢é˜…æ£€æŸ¥ä»»åŠ¡
                if self.fav_manager:
                    try:
                        subscriptions = self.fav_manager.load_subscriptions()
                        if subscriptions:
                            self.fav_manager.ensure_check_task_running()
                            logger.info(f"ğŸ“š å‘ç° {len(subscriptions)} ä¸ªè®¢é˜…ï¼Œå·²å¯åŠ¨å®šæœŸæ£€æŸ¥ä»»åŠ¡")
                    except Exception as e:
                        logger.warning(f"âš ï¸ å¯åŠ¨Bç«™æ”¶è—å¤¹è®¢é˜…æ£€æŸ¥ä»»åŠ¡å¤±è´¥: {e}")
                else:
                    logger.info("ğŸ“š Bç«™æ”¶è—å¤¹è®¢é˜…ç®¡ç†å™¨æœªåˆå§‹åŒ–ï¼Œè·³è¿‡è®¢é˜…æ£€æŸ¥")

                # ä½¿ç”¨å¯ä¸­æ–­çš„ç­‰å¾…
                try:
                    await asyncio.Event().wait()
                except KeyboardInterrupt:
                    logger.info("æ”¶åˆ°ä¸­æ–­ä¿¡å·ï¼Œæ­£åœ¨å…³é—­...")
                except Exception as e:
                    logger.error(f"è¿è¡Œæ—¶å¼‚å¸¸: {e}")
                    raise
        except Exception as e:
            logger.error(f"åº”ç”¨ç¨‹åºå¯åŠ¨å¤±è´¥: {e}")
            # ç¡®ä¿åº”ç”¨ç¨‹åºæ­£ç¡®å…³é—­
            if self.application and self.application.running:
                try:
                    await self.application.stop()
                except:
                    pass
            raise

    # å¥åº·æ£€æŸ¥åŠŸèƒ½å·²åˆ é™¤ï¼Œé¿å…äº‹ä»¶å¾ªç¯å†²çª

    async def _restart_bot_connection(self):
        """é‡å¯Botè¿æ¥"""
        logger.info("ğŸ”„ å¼€å§‹é‡å¯Botè¿æ¥...")

        try:
            # åœæ­¢å½“å‰çš„polling
            if self.application.updater.running:
                await self.application.updater.stop()
                logger.info("ğŸ“´ å·²åœæ­¢å½“å‰polling")

            # ç­‰å¾…ä¸€æ®µæ—¶é—´
            await asyncio.sleep(5)

            # é‡æ–°å¯åŠ¨polling
            await self.application.updater.start_polling(
                timeout=30,
                read_timeout=30,
                write_timeout=30,
                connect_timeout=30,
                pool_timeout=30
            )
            logger.info("ğŸ“¡ å·²é‡æ–°å¯åŠ¨polling")

        except Exception as e:
            logger.error(f"âŒ é‡å¯Botè¿æ¥å¤±è´¥: {e}")
            raise e

    # ç½‘ç»œç›‘æ§åŠŸèƒ½å·²åˆ é™¤ï¼Œé¿å…äº‹ä»¶å¾ªç¯å†²çª

    async def _keep_alive_heartbeat(self):
        """ä¿æŒè¿æ¥æ´»è·ƒçš„å¿ƒè·³æœºåˆ¶"""
        heartbeat_interval = int(os.getenv("HEARTBEAT_INTERVAL", "300"))  # 5åˆ†é’Ÿå‘é€ä¸€æ¬¡å¿ƒè·³

        while True:
            try:
                await asyncio.sleep(heartbeat_interval)

                # å‘é€ä¸€ä¸ªè½»é‡çº§çš„APIè°ƒç”¨æ¥ä¿æŒè¿æ¥æ´»è·ƒ
                try:
                    await self.application.bot.get_me()
                    logger.debug("ğŸ’“ å¿ƒè·³ä¿æŒè¿æ¥æ´»è·ƒ")
                except Exception as e:
                    logger.warning(f"ğŸ’” å¿ƒè·³å¤±è´¥: {e}")
                    # å¿ƒè·³å¤±è´¥ä¸éœ€è¦ç‰¹æ®Šå¤„ç†ï¼Œå¥åº·æ£€æŸ¥ä¼šå¤„ç†

            except Exception as e:
                logger.error(f"âŒ å¿ƒè·³æœºåˆ¶å¼‚å¸¸: {e}")
                await asyncio.sleep(60)  # å¼‚å¸¸æ—¶ç­‰å¾…1åˆ†é’Ÿ

    async def reboot_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """å¤„ç† /reboot å‘½ä»¤ - é‡å¯å®¹å™¨"""
        user_id = update.message.from_user.id

        # æƒé™æ£€æŸ¥
        if not self._check_user_permission(user_id):
            await update.message.reply_text("âŒ æ‚¨æ²¡æœ‰æƒé™ä½¿ç”¨æ­¤æœºå™¨äºº")
            return

        try:
            # å‘é€é‡å¯ç¡®è®¤æ¶ˆæ¯
            await update.message.reply_text("ğŸ”„ æ­£åœ¨é‡å¯ savextube å®¹å™¨...")
            logger.info(f"ğŸ‘¤ ç”¨æˆ· {user_id} è¯·æ±‚é‡å¯å®¹å™¨")

            import os
            import asyncio

            # ç›´æ¥ä½¿ç”¨Docker SDKé‡å¯æ–¹æ³•
            logger.info("ğŸ”„ å¼€å§‹å®¹å™¨é‡å¯æµç¨‹")

            # æ£€æŸ¥ç¯å¢ƒå¹¶æ‰§è¡Œç›¸åº”çš„é‡å¯å‘½ä»¤
            if os.path.exists('/.dockerenv'):
                logger.info("ğŸ³ Dockerå®¹å™¨ç¯å¢ƒ")

                # æ£€æŸ¥æ˜¯å¦æ˜ å°„äº†Docker socket
                docker_sock_paths = ['/var/run/docker.sock', '/var/run/docker.sock.raw']
                has_docker_sock = any(os.path.exists(path) for path in docker_sock_paths)

                if has_docker_sock:
                        logger.info("ğŸ”Œ æ£€æµ‹åˆ°Docker socketæ˜ å°„ï¼Œä½¿ç”¨Docker SDKé‡å¯")

                        await update.message.reply_text(
                            "ğŸ³ Dockerç¯å¢ƒ + Socketæ˜ å°„\n"
                            "ğŸ”„ ä½¿ç”¨Docker SDKè‡ªåŠ¨é‡å¯å®¹å™¨...\n"
                            "â³ è¯·ç­‰å¾…çº¦30ç§’è®©æœåŠ¡é‡æ–°å¯åŠ¨"
                        )
                        await asyncio.sleep(2)

                        try:
                            # ä½¿ç”¨Docker SDKé‡å¯æ–¹æ³•
                            await self._restart_via_docker_api()
                            logger.info("âœ… é€šè¿‡Docker SDKé‡å¯æˆåŠŸ")

                        except Exception as e:
                            # é™åˆ¶é”™è¯¯æ¶ˆæ¯é•¿åº¦ï¼Œé¿å…Telegramæ¶ˆæ¯è¿‡é•¿
                            error_msg = str(e)
                            if len(error_msg) > 100:
                                error_msg = error_msg[:100] + "..."

                            logger.error(f"âŒ Docker SDKé‡å¯å¤±è´¥: {error_msg}")
                            await update.message.reply_text(
                                f"âŒ SDKé‡å¯å¤±è´¥\n\n"
                                "ğŸ“‹ å¤‡ç”¨æ–¹æ¡ˆ:\n"
                                "1. æ‰‹åŠ¨é‡å¯: `docker restart <å®¹å™¨å>`\n"
                                "2. æˆ–æ‰§è¡Œä¼˜é›…é€€å‡ºè®©å®¹å™¨è‡ªåŠ¨é‡å¯"
                            )

                            # ä¼˜é›…é€€å‡ºä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆ
                            await asyncio.sleep(2)
                            await update.message.reply_text("ğŸ”„ æ‰§è¡Œä¼˜é›…é€€å‡º...")
                            await asyncio.sleep(1)
                            import sys
                            sys.exit(0)
                else:
                    logger.info("âŒ æœªæ£€æµ‹åˆ°Docker socketæ˜ å°„")
                    await update.message.reply_text(
                        "ğŸ³ æ£€æµ‹åˆ°Dockerå®¹å™¨ç¯å¢ƒ\n\n"
                        "âš ï¸ æœªæ˜ å°„Docker socketï¼Œæ— æ³•è‡ªåŠ¨é‡å¯\n\n"
                        "ğŸ“‹ è¯·æ‰‹åŠ¨é‡å¯å®¹å™¨:\n"
                        "â€¢ æ–¹æ³•1: `docker restart <å®¹å™¨å>`\n"
                        "â€¢ æ–¹æ³•2: `docker-compose restart savextube`\n\n"
                        "ğŸ’¡ è¦å¯ç”¨è‡ªåŠ¨é‡å¯ï¼Œè¯·æ˜ å°„Docker socket:\n"
                        "`-v /var/run/docker.sock:/var/run/docker.sock`"
                    )

                    # å°è¯•ä¼˜é›…é€€å‡ºï¼Œè®©å®¹å™¨ç®¡ç†å™¨é‡å¯
                    logger.info("ğŸ”„ å°è¯•ä¼˜é›…é€€å‡ºè¿›ç¨‹ï¼ŒæœŸæœ›å®¹å™¨è‡ªåŠ¨é‡å¯")
                    await asyncio.sleep(3)

                    try:
                        await update.message.reply_text(
                            "ğŸ”„ æ­£åœ¨ä¼˜é›…é€€å‡ºè¿›ç¨‹...\n"
                            "å¦‚æœå®¹å™¨é…ç½®äº†è‡ªåŠ¨é‡å¯ï¼ŒBotå°†è‡ªåŠ¨æ¢å¤"
                        )
                        await asyncio.sleep(2)
                    except:
                        pass

                    # ä¼˜é›…é€€å‡º
                    import sys
                    logger.info("ğŸ‘‹ è¿›ç¨‹å³å°†é€€å‡º")
                    sys.exit(0)

            elif os.path.exists('docker-compose.yml') or os.path.exists('docker-compose.yaml'):
                logger.info("ğŸ³ docker-composeç¯å¢ƒ")
                await update.message.reply_text(
                    "ğŸ”„ docker-composeç¯å¢ƒæ£€æµ‹åˆ°\n"
                    "âš ï¸ æ— æ³•ä»å®¹å™¨å†…é‡å¯æœåŠ¡\n\n"
                    "ğŸ“‹ è¯·åœ¨å®¿ä¸»æœºä¸Šè¿è¡Œ:\n"
                    "`docker-compose restart savextube`\n\n"
                    "ğŸ’¡ æˆ–è€…åˆ›å»ºé‡å¯è„šæœ¬æ¥è‡ªåŠ¨åŒ–æ­¤è¿‡ç¨‹"
                )

            else:
                logger.info("ğŸ’» æ™®é€šè¿›ç¨‹ç¯å¢ƒ")
                await update.message.reply_text(
                    "ğŸ”„ æ™®é€šè¿›ç¨‹ç¯å¢ƒ\n"
                    "âš ï¸ å°†å°è¯•é‡å¯å½“å‰è¿›ç¨‹\n"
                    "ğŸ“± è¯·ç­‰å¾…æœåŠ¡é‡æ–°å¯åŠ¨..."
                )
                await asyncio.sleep(2)

                # é‡å¯å½“å‰è¿›ç¨‹
                import sys
                logger.info("ğŸ”„ é‡å¯è¿›ç¨‹")
                os.execv(sys.executable, ['python'] + sys.argv)

        except Exception as e:
            error_msg = f"âŒ é‡å¯å¤±è´¥: {e}"
            logger.error(error_msg)
            await update.message.reply_text(error_msg)

    async def _restart_via_docker_api(self):
        """é€šè¿‡Docker SDKé‡å¯å®¹å™¨"""
        try:
            import docker
            logger.info("ğŸ“¦ ä½¿ç”¨Docker SDKé‡å¯å®¹å™¨")

            # åˆ›å»ºDockerå®¢æˆ·ç«¯
            client = docker.DockerClient(base_url='unix://var/run/docker.sock')

            # å°è¯•å¤šç§æ–¹æ³•è·å–å®¹å™¨ID
            container_id = None
            container = None

            # æ–¹æ³•1: é€šè¿‡cpusetè·å–å®¹å™¨ID
            try:
                container_id = os.popen("basename $(cat /proc/1/cpuset)").read().strip()
                if container_id and len(container_id) >= 12:
                    logger.info(f"ğŸ“‹ é€šè¿‡cpusetè·å–å®¹å™¨ID: {container_id[:12]}...")
                    container = client.containers.get(container_id)
                else:
                    container_id = None
            except Exception as e:
                logger.warning(f"âš ï¸ cpusetæ–¹æ³•å¤±è´¥: {e}")
                container_id = None

            # æ–¹æ³•2: é€šè¿‡hostnameè·å–å®¹å™¨ID
            if not container:
                try:
                    hostname_id = os.popen("hostname").read().strip()
                    if hostname_id and len(hostname_id) >= 12:
                        logger.info(f"ğŸ“‹ é€šè¿‡hostnameè·å–å®¹å™¨ID: {hostname_id[:12]}...")
                        container = client.containers.get(hostname_id)
                        container_id = hostname_id
                except Exception as e:
                    logger.warning(f"âš ï¸ hostnameæ–¹æ³•å¤±è´¥: {e}")

            # æ–¹æ³•3: æŸ¥æ‰¾åä¸ºsavextubeçš„å®¹å™¨
            if not container:
                try:
                    logger.info("ğŸ“‹ å°è¯•æŸ¥æ‰¾savextubeå®¹å™¨...")
                    containers = client.containers.list(filters={"name": "savextube"})
                    if containers:
                        container = containers[0]
                        container_id = container.id
                        logger.info(f"ğŸ“‹ æ‰¾åˆ°savextubeå®¹å™¨: {container_id[:12]}...")
                except Exception as e:
                    logger.warning(f"âš ï¸ æŒ‰åç§°æŸ¥æ‰¾å¤±è´¥: {e}")

            # æ£€æŸ¥æ˜¯å¦æ‰¾åˆ°å®¹å™¨
            if not container:
                raise ValueError("æ— æ³•æ‰¾åˆ°å½“å‰å®¹å™¨ï¼Œå°è¯•äº†å¤šç§æ–¹æ³•éƒ½å¤±è´¥")

            # è·å–å®¹å™¨ä¿¡æ¯
            container_name = getattr(container, 'name', 'unknown')
            logger.info(f"ğŸ”„ å‡†å¤‡é‡å¯å®¹å™¨: {container_name}")

            # æ‰§è¡Œé‡å¯
            container.restart()
            logger.info("âœ… Docker SDKé‡å¯å‘½ä»¤å·²æ‰§è¡Œ")

        except ImportError:
            logger.error("âŒ Docker Pythonåº“æœªå®‰è£…")
            logger.info("ğŸ’¡ è¯·å®‰è£…: pip install docker")
            raise ImportError("Docker Pythonåº“æœªå®‰è£…ï¼Œæ— æ³•ä½¿ç”¨SDKé‡å¯")
        except Exception as e:
            # é¿å…æ—¥å¿—è¿‡é•¿ï¼Œåªè®°å½•å…³é”®é”™è¯¯ä¿¡æ¯
            error_msg = str(e)
            if len(error_msg) > 200:
                error_msg = error_msg[:200] + "..."
            logger.error(f"âŒ Docker SDKé‡å¯å¤±è´¥: {error_msg}")
            raise e

    async def version_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """å¤„ç† /version å‘½ä»¤ - æ˜¾ç¤ºç‰ˆæœ¬ä¿¡æ¯"""
        user_id = update.message.from_user.id

        # æƒé™æ£€æŸ¥
        if not self._check_user_permission(user_id):
            await update.message.reply_text("âŒ æ‚¨æ²¡æœ‰æƒé™ä½¿ç”¨æ­¤æœºå™¨äºº")
            return

        # å¿ƒè·³æ›´æ–°å·²åˆ é™¤
        try:
            version_text = (
                f"âš™ï¸ <b>ç³»ç»Ÿç‰ˆæœ¬ä¿¡æ¯</b>\n\n"
                f"  - <b>æœºå™¨äºº</b>: <code>{BOT_VERSION}</code>"
            )
            await update.message.reply_text(version_text, parse_mode="HTML")
        except Exception as e:
            await update.message.reply_text(f"âŒ è·å–ç‰ˆæœ¬ä¿¡æ¯å¤±è´¥: {e}")

    async def formats_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """å¤„ç† /formats å‘½ä»¤ - æ£€æŸ¥è§†é¢‘æ ¼å¼"""
        user_id = update.message.from_user.id

        # æƒé™æ£€æŸ¥
        if not self._check_user_permission(user_id):
            await update.message.reply_text("âŒ æ‚¨æ²¡æœ‰æƒé™ä½¿ç”¨æ­¤æœºå™¨äºº")
            return

        # å¿ƒè·³æ›´æ–°å·²åˆ é™¤

        try:
            # è·å–ç”¨æˆ·å‘é€çš„URL
            if not context.args:
                await update.message.reply_text(
                    """æ ¼å¼æ£€æŸ¥å‘½ä»¤
ä½¿ç”¨æ–¹æ³•ï¼š
/formats <è§†é¢‘é“¾æ¥>
ç¤ºä¾‹ï¼š
/formats https://www.youtube.com/watch?v=xxx
æ­¤å‘½ä»¤ä¼šæ˜¾ç¤ºè§†é¢‘çš„å¯ç”¨æ ¼å¼ï¼Œå¸®åŠ©è°ƒè¯•ä¸‹è½½é—®é¢˜ã€‚"""
                )
                return

            url = context.args[0]

            # éªŒè¯URL
            if not url.startswith(("http://", "https://")):
                await update.message.reply_text("è¯·æä¾›æœ‰æ•ˆçš„è§†é¢‘é“¾æ¥")
                return

            check_message = await update.message.reply_text("æ­£åœ¨æ£€æŸ¥è§†é¢‘æ ¼å¼...")

            # æ£€æŸ¥æ ¼å¼
            result = self.downloader.check_video_formats(url)

            if result["success"]:
                formats_text = f"""è§†é¢‘æ ¼å¼ä¿¡æ¯
æ ‡é¢˜ï¼š{result['title']}
å¯ç”¨æ ¼å¼ï¼ˆå‰10ä¸ªï¼‰ï¼š
"""
                for i, fmt in enumerate(result["video_formats"], 1):
                    size_info = ""
                    if fmt["filesize"] and fmt["filesize"] > 0:
                        size_mb = fmt["filesize"] / (1024 * 1024)
                        size_info = f" ({size_mb:.1f}MB)"

                    formats_text += f"{i}. ID: {fmt['id']} | {fmt['ext']} | {fmt['quality']}{size_info}\n"

                formats_text += "\néŸ³é¢‘æ ¼å¼ï¼ˆå‰5ä¸ªï¼‰ï¼š\n"
                for i, fmt in enumerate(result["audio_formats"], 1):
                    size_info = ""
                    if fmt["filesize"] and fmt["filesize"] > 0:
                        size_mb = fmt["filesize"] / (1024 * 1024)
                        size_info = f" ({size_mb:.1f}MB)"

                    formats_text += f"{i}. ID: {fmt['id']} | {fmt['ext']} | {fmt['quality']}{size_info}\n"

                formats_text += "\nå¦‚æœä¸‹è½½å¤±è´¥ï¼Œå¯ä»¥å°è¯•å…¶ä»–è§†é¢‘æˆ–æŠ¥å‘Šæ­¤ä¿¡æ¯ã€‚"

                await check_message.edit_text(formats_text)
            else:
                await check_message.edit_text(f"æ ¼å¼æ£€æŸ¥å¤±è´¥: {result['error']}")

        except Exception as e:
            await update.message.reply_text(f"æ ¼å¼æ£€æŸ¥å‡ºé”™: {str(e)}")

    async def cancel_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """å¤„ç† /cancel å‘½ä»¤ - å–æ¶ˆå½“å‰ä¸‹è½½ä»»åŠ¡"""
        user_id = update.message.from_user.id

        # æƒé™æ£€æŸ¥
        if not self._check_user_permission(user_id):
            await update.message.reply_text("âŒ æ‚¨æ²¡æœ‰æƒé™ä½¿ç”¨æ­¤æœºå™¨äºº")
            return

        try:
            # æ£€æŸ¥æ˜¯å¦æœ‰æ­£åœ¨è¿›è¡Œçš„ä¸‹è½½ä»»åŠ¡
            logger.info(f"ğŸ” ç”¨æˆ· {user_id} è¯·æ±‚å–æ¶ˆä»»åŠ¡")
            logger.info(f"ğŸ” å½“å‰ä»»åŠ¡æ•°é‡: {len(self.download_tasks) if hasattr(self, 'download_tasks') else 0}")

            if hasattr(self, 'download_tasks') and self.download_tasks:
                # æ‰“å°æ‰€æœ‰ä»»åŠ¡ä¿¡æ¯ç”¨äºè°ƒè¯•
                for tid, tinfo in self.download_tasks.items():
                    logger.info(f"ğŸ” ä»»åŠ¡ {tid}: user_id={tinfo.get('user_id')}, done={tinfo.get('task').done() if tinfo.get('task') else 'None'}")

                cancelled_count = 0
                for task_id, task_info in list(self.download_tasks.items()):
                    task_user_id = task_info.get('user_id')
                    task_done = task_info.get('task').done() if task_info.get('task') else True

                    logger.info(f"ğŸ” æ£€æŸ¥ä»»åŠ¡ {task_id}: user_id={task_user_id}, done={task_done}, åŒ¹é…ç”¨æˆ·={task_user_id == user_id}")

                    if task_user_id == user_id and not task_done:
                        logger.info(f"ğŸš« å–æ¶ˆä»»åŠ¡: {task_id}")
                        # è®¾ç½®å–æ¶ˆæ ‡å¿—ï¼Œè®© update_progress æ£€æµ‹åˆ°
                        task_info['cancelled'] = True
                        task_info['task'].cancel()
                        cancelled_count += 1
                        # å‘é€å–æ¶ˆæ¶ˆæ¯
                        try:
                            status_message = task_info.get('status_message')
                            if status_message:
                                await status_message.edit_text("âŒ ä¸‹è½½å·²è¢«ç”¨æˆ·å–æ¶ˆ", parse_mode=None)
                        except Exception as e:
                            logger.debug(f"ç¼–è¾‘å–æ¶ˆæ¶ˆæ¯å¤±è´¥: {e}")
                            pass  # å¿½ç•¥ç¼–è¾‘æ¶ˆæ¯å¤±è´¥çš„é”™è¯¯

                if cancelled_count > 0:
                    await update.message.reply_text(f"âœ… å·²å–æ¶ˆ {cancelled_count} ä¸ªä¸‹è½½ä»»åŠ¡")
                else:
                    await update.message.reply_text("â„¹ï¸ æ²¡æœ‰æ‰¾åˆ°æ­£åœ¨è¿›è¡Œçš„ä¸‹è½½ä»»åŠ¡")
            else:
                await update.message.reply_text("â„¹ï¸ æ²¡æœ‰æ‰¾åˆ°æ­£åœ¨è¿›è¡Œçš„ä¸‹è½½ä»»åŠ¡")

        except Exception as e:
            logger.error(f"å–æ¶ˆä¸‹è½½ä»»åŠ¡å¤±è´¥: {e}")
            await update.message.reply_text(f"âŒ å–æ¶ˆä»»åŠ¡å¤±è´¥: {str(e)}")

    async def cleanup_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """å¤„ç† /cleanup å‘½ä»¤"""
        user_id = update.message.from_user.id

        # æƒé™æ£€æŸ¥
        if not self._check_user_permission(user_id):
            await update.message.reply_text("âŒ æ‚¨æ²¡æœ‰æƒé™ä½¿ç”¨æ­¤æœºå™¨äºº")
            return

        # å¿ƒè·³æ›´æ–°å·²åˆ é™¤

        cleanup_message = await update.message.reply_text("å¼€å§‹æ¸…ç†é‡å¤æ–‡ä»¶...")

        try:
            cleaned_count = self.downloader.cleanup_duplicates()
            if cleaned_count > 0:
                completion_text = f"""æ¸…ç†å®Œæˆ!
åˆ é™¤äº† {cleaned_count} ä¸ªé‡å¤æ–‡ä»¶
é‡Šæ”¾äº†å­˜å‚¨ç©ºé—´"""
            else:
                completion_text = "æ¸…ç†å®Œæˆ! æœªå‘ç°é‡å¤æ–‡ä»¶"

            await cleanup_message.edit_text(completion_text)
        except Exception as e:
            await cleanup_message.edit_text(f"æ¸…ç†å¤±è´¥: {str(e)}")

    async def status_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """å¤„ç† /status å‘½ä»¤"""
        user_id = update.message.from_user.id

        # æƒé™æ£€æŸ¥
        if not self._check_user_permission(user_id):
            await update.message.reply_text("âŒ æ‚¨æ²¡æœ‰æƒé™ä½¿ç”¨æ­¤æœºå™¨äºº")
            return

        # å¿ƒè·³æ›´æ–°å·²åˆ é™¤
        try:
            # ç»Ÿè®¡æ–‡ä»¶
            video_extensions = ["*.mp4", "*.mkv", "*.webm", "*.mov", "*.avi"]
            x_files = []
            if self.downloader.x_download_path.exists():
                for ext in video_extensions:
                    x_files.extend(self.downloader.x_download_path.glob(ext))
            youtube_files = []
            if self.downloader.youtube_download_path.exists():
                for ext in video_extensions:
                    youtube_files.extend(
                        self.downloader.youtube_download_path.glob(ext)
                    )
            bilibili_files = []
            if self.downloader.bilibili_download_path.exists():
                for ext in video_extensions:
                    bilibili_files.extend(
                        self.downloader.bilibili_download_path.glob(ext)
                    )
            douyin_files = []
            if self.downloader.douyin_download_path.exists():
                for ext in video_extensions:
                    douyin_files.extend(
                        self.downloader.douyin_download_path.glob(ext)
                    )
            total_files = len(x_files) + len(youtube_files) + len(bilibili_files) + len(douyin_files)
            status_text = (
                f"ğŸ“Š <b>ä¸‹è½½çŠ¶æ€</b>\n\n"
                f"  - <b>X (Twitter)</b>: {len(x_files)} ä¸ªæ–‡ä»¶\n"
                f"  - <b>YouTube</b>: {len(youtube_files)} ä¸ªæ–‡ä»¶\n"
                f"  - <b>Bilibili</b>: {len(bilibili_files)} ä¸ªæ–‡ä»¶\n"
                f"  - <b>æ€»è®¡</b>: {total_files} ä¸ªæ–‡ä»¶\n\n"
            )
            # qBittorrent çŠ¶æ€
            if self.qbit_client and self.qbit_client.is_logged_in:
                torrents = self.qbit_client.torrents_info(tag="savextube")
                active_torrents = [
                    t for t in torrents if t.state not in ["completed", "pausedUP"]
                ]
                status_text += f"<b>qBittorrent ä»»åŠ¡</b>: {len(torrents)} (æ´»åŠ¨: {len(active_torrents)})"
            else:
                status_text += "<b>qBittorrent</b>: æœªè¿æ¥"
            await update.message.reply_text(status_text, parse_mode="HTML")
        except Exception as e:
            await update.message.reply_text(f"âŒ è·å–çŠ¶æ€å¤±è´¥: {str(e)}")

    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """å¤„ç†æ–‡æœ¬æ¶ˆæ¯ï¼Œä¸»è¦æ˜¯è§†é¢‘é“¾æ¥"""
        user_id = update.message.from_user.id

        # æƒé™æ£€æŸ¥
        if not self._check_user_permission(user_id):
            await update.message.reply_text("âŒ æ‚¨æ²¡æœ‰æƒé™ä½¿ç”¨æ­¤æœºå™¨äºº")
            return

        # æ›´æ–°å¿ƒè·³
        # å¿ƒè·³æ›´æ–°å·²åˆ é™¤

        message = update.message
        url = None

        # æ£€æŸ¥æœç´¢å‘½ä»¤
        if message.text and message.text.startswith("/search"):
            await self._handle_search_command(message, context)
            return

        # æ£€æŸ¥æ¶ˆæ¯ç±»å‹å¹¶æå–URL
        if message.text and message.text.startswith("http"):
            # æ™®é€šæ–‡æœ¬é“¾æ¥
            url = message.text
        elif message.text and (message.text.startswith("magnet:") or message.text.endswith(".torrent")):
            # ç£åŠ›é“¾æ¥æˆ–ç§å­æ–‡ä»¶ - æ–°å¢æ”¯æŒ
            url = message.text
        elif message.text and "magnet:" in message.text:
            # ä»æ··åˆæ–‡æœ¬ä¸­æå–ç£åŠ›é“¾æ¥
            import re
            magnet_match = re.search(r'magnet:\?xt=urn:btih:[a-fA-F0-9]{32,40}[^\s]*', message.text)
            if magnet_match:
                url = magnet_match.group(0)
                logger.info(f"ğŸ”§ ä»æ··åˆæ–‡æœ¬ä¸­æå–ç£åŠ›é“¾æ¥: {message.text} -> {url}")
        elif message.text and ".torrent" in message.text:
            # ä»æ··åˆæ–‡æœ¬ä¸­æå–ç§å­æ–‡ä»¶é“¾æ¥
            import re
            torrent_match = re.search(r'https?://[^\s]*\.torrent[^\s]*', message.text)
            if torrent_match:
                url = torrent_match.group(0)
                logger.info(f"ğŸ”§ ä»æ··åˆæ–‡æœ¬ä¸­æå–ç§å­æ–‡ä»¶é“¾æ¥: {message.text} -> {url}")
        elif message.entities:
            # æ£€æŸ¥æ˜¯å¦æœ‰é“¾æ¥å®ä½“
            for entity in message.entities:
                if entity.type == "url":
                    url = message.text[entity.offset:entity.offset + entity.length]
                    break
                elif entity.type == "text_link":
                    url = entity.url
                    break
        elif message.text and ("http" in message.text or "tp://" in message.text or "kuaishou.com" in message.text or "douyin.com" in message.text):
            # å°è¯•ä»æ–‡æœ¬ä¸­æå–URLï¼ŒåŒ…æ‹¬ä¿®å¤é”™è¯¯çš„åè®®å’Œæ™ºèƒ½æå–
            import re

            # é¦–å…ˆä½¿ç”¨æ™ºèƒ½æå–æ–¹æ³•
            extracted_urls = self.downloader.extract_urls_from_text(message.text)
            if extracted_urls:
                url = extracted_urls[0]  # ä½¿ç”¨ç¬¬ä¸€ä¸ªæ‰¾åˆ°çš„URL
                logger.info(f"ğŸ”§ æ™ºèƒ½æå–URL: {message.text} -> {url}")
            else:
                # å¤‡é€‰æ–¹æ¡ˆï¼šä¿®å¤é”™è¯¯çš„åè®®
                fixed_text = message.text.replace("tp://", "http://")
                url_match = re.search(r'https?://[^\s]+', fixed_text)
                if url_match:
                    url = url_match.group(0)
                    logger.info(f"ğŸ”§ ä¿®å¤äº†é”™è¯¯çš„URLåè®®: {message.text} -> {url}")

        # æ£€æŸ¥è½¬å‘æ¶ˆæ¯
        if not url and message.forward_from_chat:
            # å¤„ç†è½¬å‘çš„é¢‘é“/ç¾¤ç»„æ¶ˆæ¯
            if message.text and ("http" in message.text or "tp://" in message.text or "magnet:" in message.text):
                import re
                # é¦–å…ˆå°è¯•æå–ç£åŠ›é“¾æ¥
                magnet_match = re.search(r'magnet:\?xt=urn:btih:[a-fA-F0-9]{32,40}[^\s]*', message.text)
                if magnet_match:
                    url = magnet_match.group(0)
                    logger.info(f"ğŸ”§ è½¬å‘æ¶ˆæ¯ä¸­æå–ç£åŠ›é“¾æ¥: {message.text} -> {url}")
                else:
                    # å°è¯•æå–ç§å­æ–‡ä»¶é“¾æ¥
                    torrent_match = re.search(r'https?://[^\s]*\.torrent[^\s]*', message.text)
                    if torrent_match:
                        url = torrent_match.group(0)
                        logger.info(f"ğŸ”§ è½¬å‘æ¶ˆæ¯ä¸­æå–ç§å­æ–‡ä»¶é“¾æ¥: {message.text} -> {url}")
                    else:
                        # ä¿®å¤é”™è¯¯çš„åè®®
                        fixed_text = message.text.replace("tp://", "http://")
                        url_match = re.search(r'https?://[^\s]+', fixed_text)
                        if url_match:
                            url = url_match.group(0)
                            logger.info(f"ğŸ”§ è½¬å‘æ¶ˆæ¯ä¸­ä¿®å¤äº†é”™è¯¯çš„URLåè®®: {message.text} -> {url}")

        # æ£€æŸ¥å›å¤çš„æ¶ˆæ¯
        if not url and message.reply_to_message:
            reply_msg = message.reply_to_message
            if reply_msg.text and ("http" in reply_msg.text or "tp://" in reply_msg.text or "magnet:" in reply_msg.text):
                import re
                # é¦–å…ˆå°è¯•æå–ç£åŠ›é“¾æ¥
                magnet_match = re.search(r'magnet:\?xt=urn:btih:[a-fA-F0-9]{32,40}[^\s]*', reply_msg.text)
                if magnet_match:
                    url = magnet_match.group(0)
                    logger.info(f"ğŸ”§ å›å¤æ¶ˆæ¯ä¸­æå–ç£åŠ›é“¾æ¥: {reply_msg.text} -> {url}")
                else:
                    # å°è¯•æå–ç§å­æ–‡ä»¶é“¾æ¥
                    torrent_match = re.search(r'https?://[^\s]*\.torrent[^\s]*', reply_msg.text)
                    if torrent_match:
                        url = torrent_match.group(0)
                        logger.info(f"ğŸ”§ å›å¤æ¶ˆæ¯ä¸­æå–ç§å­æ–‡ä»¶é“¾æ¥: {reply_msg.text} -> {url}")
                    else:
                        # ä¿®å¤é”™è¯¯çš„åè®®
                        fixed_text = reply_msg.text.replace("tp://", "http://")
                        url_match = re.search(r'https?://[^\s]+', fixed_text)
                        if url_match:
                            url = url_match.group(0)
                            logger.info(f"ğŸ”§ å›å¤æ¶ˆæ¯ä¸­ä¿®å¤äº†é”™è¯¯çš„URLåè®®: {reply_msg.text} -> {url}")
            elif reply_msg.entities:
                for entity in reply_msg.entities:
                    if entity.type == "url":
                        url = reply_msg.text[entity.offset:entity.offset + entity.length]
                        break
                    elif entity.type == "text_link":
                        url = entity.url
                        break

        if not url:
            await message.reply_text("ğŸ¤” è¯·å‘é€ä¸€ä¸ªæœ‰æ•ˆçš„é“¾æ¥æˆ–åŒ…å«é“¾æ¥çš„æ¶ˆæ¯ã€‚\n\nğŸ’¡ æç¤ºï¼š\nâ€¢ ç›´æ¥å‘é€é“¾æ¥\nâ€¢ è½¬å‘åŒ…å«é“¾æ¥çš„æ¶ˆæ¯\nâ€¢ å›å¤åŒ…å«é“¾æ¥çš„æ¶ˆæ¯")
            return

        # æ·»åŠ è°ƒè¯•æ—¥å¿—
        logger.info(f"æ”¶åˆ°æ¶ˆæ¯: {url}")

        # ç«‹å³å‘é€å¿«é€Ÿå“åº”
        status_message = await message.reply_text("ğŸš€ æ­£åœ¨å¤„ç†æ‚¨çš„è¯·æ±‚...")

        # å¼‚æ­¥å¤„ç†ä¸‹è½½ä»»åŠ¡ï¼Œä¸é˜»å¡å“åº”
        asyncio.create_task(
            self._process_download_async(update, context, url, status_message)
        )

    async def _handle_search_command(self, message, context):
        """å¤„ç†æœç´¢å‘½ä»¤ /search ncm å…³é”®è¯"""
        try:
            # è§£æå‘½ä»¤
            parts = message.text.split(' ', 2)  # /search ncm å…³é”®è¯
            if len(parts) < 3:
                help_text = """
ğŸ” <b>ç½‘æ˜“äº‘éŸ³ä¹æœç´¢ä¸‹è½½</b>

<b>ä½¿ç”¨æ–¹æ³•ï¼š</b>
<code>/search ncm å…³é”®è¯</code>

<b>ç¤ºä¾‹ï¼š</b>
<code>/search ncm ä¸œé£ç ´</code>
<code>/search ncm å‘¨æ°ä¼¦ ç¨»é¦™</code>
<code>/search ncm ç‹åŠ›å® ç›–ä¸–è‹±é›„</code>

<b>è¯´æ˜ï¼š</b>
â€¢ æ”¯æŒæ­Œæ›²åã€è‰ºæœ¯å®¶åã€ä¸“è¾‘åæœç´¢
â€¢ è‡ªåŠ¨è¯†åˆ«æ˜¯å•æ›²è¿˜æ˜¯ä¸“è¾‘
â€¢ ä½¿ç”¨é…ç½®çš„ç›®å½•ç»“æ„å’Œæ–‡ä»¶å‘½åæ ¼å¼
                """
                await message.reply_text(help_text, parse_mode="HTML")
                return

            platform = parts[1].lower()
            keyword = parts[2]

            if platform != 'ncm':
                await message.reply_text("âŒ æš‚åªæ”¯æŒç½‘æ˜“äº‘éŸ³ä¹æœç´¢ï¼Œè¯·ä½¿ç”¨ <code>/search ncm å…³é”®è¯</code>", parse_mode="HTML")
                return

            # å‘é€çŠ¶æ€æ¶ˆæ¯
            status_message = await message.reply_text(f"ğŸ” æ­£åœ¨æœç´¢: {keyword}")

            try:
                # è°ƒç”¨ç½‘æ˜“äº‘éŸ³ä¹æœç´¢ä¸‹è½½
                result = await self._search_and_download_ncm(keyword, status_message)
                
                if result.get('success'):
                    await status_message.edit_text(f"âœ… æœç´¢ä¸‹è½½å®Œæˆï¼\n\nğŸ” å…³é”®è¯: {keyword}\nğŸ“ ä¿å­˜ä½ç½®: {result.get('download_path', 'æœªçŸ¥')}", parse_mode=None)
                else:
                    await status_message.edit_text(f"âŒ æœç´¢ä¸‹è½½å¤±è´¥: {result.get('error', 'æœªçŸ¥é”™è¯¯')}", parse_mode=None)

            except Exception as e:
                logger.error(f"æœç´¢ä¸‹è½½å¤±è´¥: {e}")
                await status_message.edit_text(f"âŒ æœç´¢ä¸‹è½½æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}", parse_mode=None)

        except Exception as e:
            logger.error(f"å¤„ç†æœç´¢å‘½ä»¤å¤±è´¥: {e}")
            await message.reply_text(f"âŒ å‘½ä»¤å¤„ç†å¤±è´¥: {str(e)}")

    async def _search_and_download_ncm(self, keyword: str, status_message):
        """æœç´¢å¹¶ä¸‹è½½ç½‘æ˜“äº‘éŸ³ä¹"""
        try:
            # åˆ›å»ºè¿›åº¦å›è°ƒ
            async def progress_callback(text):
                try:
                    await status_message.edit_text(text, parse_mode=None)
                except Exception as e:
                    logger.warning(f"æ›´æ–°è¿›åº¦æ¶ˆæ¯å¤±è´¥: {e}")

            # è°ƒç”¨ç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½å™¨çš„æœç´¢ä¸‹è½½æ–¹æ³•
            loop = asyncio.get_running_loop()
            result = await loop.run_in_executor(
                None,
                self.downloader.netease_downloader.download_album,
                keyword,
                str(self.downloader.netease_download_path),
                self.downloader.netease_downloader.get_quality_setting(),
                progress_callback
            )

            return result

        except Exception as e:
            logger.error(f"æœç´¢ä¸‹è½½ç½‘æ˜“äº‘éŸ³ä¹å¤±è´¥: {e}")
            return {'success': False, 'error': str(e)}

    async def favsub_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """å¤„ç† /favsub å‘½ä»¤ - è®¢é˜…Bç«™æ”¶è—å¤¹"""
        user_id = update.message.from_user.id

        # æƒé™æ£€æŸ¥
        if not self._check_user_permission(user_id):
            await update.message.reply_text("âŒ æ‚¨æ²¡æœ‰æƒé™ä½¿ç”¨æ­¤åŠŸèƒ½")
            return

        try:
            # è·å–å‘½ä»¤å‚æ•°
            args = context.args
            if not args:
                help_text = f"""
ğŸ“š <b>Bç«™æ”¶è—å¤¹è®¢é˜…åŠŸèƒ½</b>

<b>ä½¿ç”¨æ–¹æ³•ï¼š</b>
<code>/favsub æ”¶è—å¤¹ID</code>

<b>ç¤ºä¾‹ï¼š</b>
<code>/favsub 3604284050</code>

<b>è¯´æ˜ï¼š</b>
â€¢ æ”¶è—å¤¹IDå¯ä»¥ä»æ”¶è—å¤¹URLä¸­è·å–
â€¢ ä¾‹å¦‚ï¼šhttps://www.bilibili.com/medialist/play/ml3604284050
â€¢ è®¢é˜…åä¼šæ¯{self.fav_manager.poll_interval}åˆ†é’Ÿè‡ªåŠ¨æ£€æŸ¥å¹¶ä¸‹è½½æ–°è§†é¢‘

<b>ç®¡ç†å‘½ä»¤ï¼š</b>
<code>/favsub list</code> - æŸ¥çœ‹å·²è®¢é˜…çš„æ”¶è—å¤¹
<code>/favsub remove æ”¶è—å¤¹ID</code> - å–æ¶ˆè®¢é˜…
<code>/favsub download æ”¶è—å¤¹ID</code> - æ‰‹åŠ¨ä¸‹è½½æ”¶è—å¤¹
<code>/favsub status</code> - æŸ¥çœ‹è®¢é˜…ä»»åŠ¡çŠ¶æ€
                """
                await update.message.reply_text(help_text, parse_mode="HTML")
                return

            command = args[0].lower()

            if command == "status":
                # æŸ¥çœ‹è®¢é˜…ä»»åŠ¡çŠ¶æ€
                subscriptions = self.fav_manager.get_subscriptions_list()
                task_running = self.fav_manager.is_check_task_running()

                status_text = f"""
ğŸ“Š <b>Bç«™æ”¶è—å¤¹è®¢é˜…çŠ¶æ€</b>

ğŸ”§ <b>é…ç½®ä¿¡æ¯ï¼š</b>
â€¢ æ£€æŸ¥é—´éš”: {self.fav_manager.poll_interval} åˆ†é’Ÿ
â€¢ ä¸‹è½½ç›®å½•: {self.fav_manager.subscription_download_path}
â€¢ ä»£ç†è®¾ç½®: {'å·²é…ç½®' if self.fav_manager.proxy_host else 'æœªé…ç½®'}
â€¢ Cookies: {'å·²é…ç½®' if self.fav_manager.cookies_path else 'æœªé…ç½®'}

ğŸ“š <b>è®¢é˜…ç»Ÿè®¡ï¼š</b>
â€¢ è®¢é˜…æ•°é‡: {len(subscriptions)}
â€¢ åå°ä»»åŠ¡: {'ğŸŸ¢ è¿è¡Œä¸­' if task_running else 'ğŸ”´ å·²åœæ­¢'}

ğŸ“‹ <b>è®¢é˜…åˆ—è¡¨ï¼š</b>
"""

                if subscriptions:
                    for sub_info in subscriptions[:5]:  # åªæ˜¾ç¤ºå‰5ä¸ª
                        fav_id = sub_info['fav_id']
                        title = sub_info['title']
                        download_count = sub_info['download_count']
                        status_text += f"â€¢ {title} (ID: {fav_id}) - å·²ä¸‹è½½: {download_count}\n"

                    if len(subscriptions) > 5:
                        status_text += f"... è¿˜æœ‰ {len(subscriptions) - 5} ä¸ªè®¢é˜…\n"
                else:
                    status_text += "æš‚æ— è®¢é˜…\n"

                status_text += f"\nğŸ’¡ ä½¿ç”¨ <code>/favsub list</code> æŸ¥çœ‹å®Œæ•´åˆ—è¡¨"

                await update.message.reply_text(status_text, parse_mode="HTML")

            elif command == "list":
                # æŸ¥çœ‹è®¢é˜…åˆ—è¡¨
                subscriptions = self.fav_manager.get_subscriptions_list()

                if not subscriptions:
                    await update.message.reply_text("ğŸ“š æš‚æ— è®¢é˜…çš„æ”¶è—å¤¹")
                    return

                list_text = "ğŸ“š <b>å·²è®¢é˜…çš„æ”¶è—å¤¹ï¼š</b>\n\n"

                for sub_info in subscriptions:
                    fav_id = sub_info['fav_id']
                    title = sub_info['title']
                    video_count = sub_info['video_count']
                    added_time = sub_info['added_time']
                    last_check = sub_info['last_check']
                    download_count = sub_info['download_count']

                    # æ ¼å¼åŒ–æ—¶é—´
                    import time
                    added_str = time.strftime('%Y-%m-%d %H:%M', time.localtime(added_time))
                    if last_check > 0:
                        last_check_str = time.strftime('%Y-%m-%d %H:%M', time.localtime(last_check))
                    else:
                        last_check_str = "æœªæ£€æŸ¥"

                    list_text += f"""
ğŸ”¸ <b>{title}</b>
   â€¢ ID: <code>{fav_id}</code>
   â€¢ è§†é¢‘æ•°: {video_count}
   â€¢ å·²ä¸‹è½½: {download_count}
   â€¢ è®¢é˜…æ—¶é—´: {added_str}
   â€¢ æœ€åæ£€æŸ¥: {last_check_str}

"""

                list_text += f"\nğŸ’¡ ä½¿ç”¨ <code>/favsub remove æ”¶è—å¤¹ID</code> å–æ¶ˆè®¢é˜…"
                list_text += f"\nğŸ’¡ ä½¿ç”¨ <code>/favsub download æ”¶è—å¤¹ID</code> æ‰‹åŠ¨ä¸‹è½½"

                await update.message.reply_text(list_text, parse_mode="HTML")

            elif command == "remove" and len(args) > 1:
                # å–æ¶ˆè®¢é˜…
                fav_id = args[1]
                result = self.fav_manager.remove_subscription(fav_id)

                if result["success"]:
                    success_text = f"""
âœ… <b>å–æ¶ˆè®¢é˜…æˆåŠŸï¼</b>

ğŸ“š å·²å–æ¶ˆè®¢é˜…æ”¶è—å¤¹ï¼š
â€¢ ID: <code>{result['fav_id']}</code>
â€¢ æ ‡é¢˜: {result['title']}
                    """
                    await update.message.reply_text(success_text, parse_mode="HTML")
                else:
                    await update.message.reply_text(f"âŒ {result['error']}")

            elif command == "download" and len(args) > 1:
                # æ‰‹åŠ¨ä¸‹è½½
                fav_id = args[1]
                status_msg = await update.message.reply_text("ğŸ”„ å¼€å§‹æ‰‹åŠ¨ä¸‹è½½æ”¶è—å¤¹...")

                result = await self.fav_manager.manual_download(fav_id)

                if result["success"]:
                    success_text = f"""
âœ… <b>æ‰‹åŠ¨ä¸‹è½½å®Œæˆï¼</b>

ğŸ“š <b>æ”¶è—å¤¹ä¿¡æ¯ï¼š</b>
â€¢ ID: <code>{result['fav_id']}</code>
â€¢ æ ‡é¢˜: {result['title']}
â€¢ ä¸‹è½½è·¯å¾„: {result['download_path']}
â€¢ æ–‡ä»¶æ•°é‡: {result['file_count']}
                    """
                    await status_msg.edit_text(success_text, parse_mode="HTML")
                else:
                    await status_msg.edit_text(f"âŒ ä¸‹è½½å¤±è´¥: {result['error']}")

            else:
                # æ·»åŠ è®¢é˜…
                fav_id = command
                status_msg = await update.message.reply_text("ğŸ” æ­£åœ¨éªŒè¯æ”¶è—å¤¹...")

                # ä½¿ç”¨è®¢é˜…ç®¡ç†å™¨æ·»åŠ è®¢é˜…
                result = await self.fav_manager.add_subscription(fav_id, update.message.from_user.id)

                if result["success"]:
                    success_text = f"""
âœ… <b>è®¢é˜…æˆåŠŸï¼</b>

ğŸ“š <b>æ”¶è—å¤¹ä¿¡æ¯ï¼š</b>
â€¢ ID: <code>{result['fav_id']}</code>
â€¢ æ ‡é¢˜: {result['title']}
â€¢ è§†é¢‘æ•°é‡: {result['video_count']}
â€¢ URL: {result['url']}

â° <b>è‡ªåŠ¨ä¸‹è½½ï¼š</b>
ç³»ç»Ÿå°†æ¯{self.fav_manager.poll_interval}åˆ†é’Ÿæ£€æŸ¥ä¸€æ¬¡æ–°è§†é¢‘å¹¶è‡ªåŠ¨ä¸‹è½½
                    """
                    await status_msg.edit_text(success_text, parse_mode="HTML")
                else:
                    await status_msg.edit_text(f"âŒ {result['error']}")

        except Exception as e:
            logger.error(f"favsubå‘½ä»¤å¤„ç†å¤±è´¥: {e}")
            await update.message.reply_text(f"âŒ å‘½ä»¤å¤„ç†å¤±è´¥: {e}")

    async def handle_qbittorrent_links(self, update: Update, context: ContextTypes.DEFAULT_TYPE, url: str, status_message):
        """ä¸“é—¨å¤„ç†qBittorrentç›¸å…³çš„é“¾æ¥ï¼ˆç£åŠ›é“¾æ¥å’Œç§å­æ–‡ä»¶ï¼‰"""
        try:
            # æ£€æŸ¥æ˜¯å¦ä¸ºç£åŠ›é“¾æ¥æˆ–ç§å­æ–‡ä»¶
            if self._is_magnet_link(url) or url.endswith(".torrent"):
                logger.info(f"ğŸ”— æ£€æµ‹åˆ°ç£åŠ›é“¾æ¥æˆ–ç§å­æ–‡ä»¶: {url[:50]}...")
                await status_message.edit_text("ğŸ”— æ­£åœ¨æ·»åŠ åˆ° qBittorrent...", parse_mode=None)

                # å°è¯•æ·»åŠ åˆ° qBittorrent
                success = await self.add_magnet_to_qb(url)

                if success:
                    await status_message.edit_text(
                        "âœ… **ç£åŠ›é“¾æ¥/ç§å­æ–‡ä»¶å·²æˆåŠŸæ·»åŠ åˆ° qBittorrentï¼**\n\n"
                        "ğŸ“ ä»»åŠ¡å·²æ·»åŠ åˆ°ä¸‹è½½é˜Ÿåˆ—\n"
                        "ğŸ” æ‚¨å¯ä»¥åœ¨ qBittorrent ä¸­æŸ¥çœ‹ä¸‹è½½è¿›åº¦\n"
                        "ğŸ’¡ æç¤ºï¼šä¸‹è½½å®Œæˆåæ–‡ä»¶ä¼šä¿å­˜åˆ°é…ç½®çš„ä¸‹è½½ç›®å½•"
                    )
                else:
                    await status_message.edit_text(
                        "âŒ **æ·»åŠ ç£åŠ›é“¾æ¥/ç§å­æ–‡ä»¶å¤±è´¥**\n\n"
                        "å¯èƒ½çš„åŸå› ï¼š\n"
                        "â€¢ qBittorrent æœªè¿æ¥æˆ–æœªé…ç½®\n"
                        "â€¢ é“¾æ¥æ ¼å¼æ— æ•ˆ\n"
                        "â€¢ qBittorrent æœåŠ¡å¼‚å¸¸\n\n"
                        "è¯·æ£€æŸ¥ qBittorrent é…ç½®å’Œè¿æ¥çŠ¶æ€"
                    )
                return True  # è¡¨ç¤ºå·²å¤„ç†

            # æ£€æŸ¥æ˜¯å¦ä¸ºåª’ä½“æ¶ˆæ¯ï¼Œä»åª’ä½“æ¶ˆæ¯æ–‡æœ¬ä¸­æå–ç£åŠ›é“¾æ¥
            message = update.message
            if message.photo or message.video or message.document or message.audio:
                if message.caption:
                    caption_text = message.caption
                    logger.info(f"ğŸ” æ£€æµ‹åˆ°åª’ä½“æ¶ˆæ¯ï¼Œæ–‡æœ¬å†…å®¹: {caption_text}")

                    # ä»åª’ä½“æ¶ˆæ¯æ–‡æœ¬ä¸­æå–ç£åŠ›é“¾æ¥
                    import re
                    magnet_match = re.search(r'magnet:\?xt=urn:btih:[a-fA-F0-9]{32,40}[^\s]*', caption_text)
                    if magnet_match:
                        magnet_url = magnet_match.group(0)
                        logger.info(f"ğŸ”§ ä»åª’ä½“æ¶ˆæ¯æ–‡æœ¬ä¸­æå–ç£åŠ›é“¾æ¥: {caption_text} -> {magnet_url}")
                        await status_message.edit_text("ğŸ”— æ­£åœ¨æ·»åŠ åˆ° qBittorrent...", parse_mode=None)

                        # å°è¯•æ·»åŠ åˆ° qBittorrent
                        success = await self.add_magnet_to_qb(magnet_url)

                        if success:
                            await status_message.edit_text(
                                "âœ… **ç£åŠ›é“¾æ¥å·²æˆåŠŸæ·»åŠ åˆ° qBittorrentï¼**\n\n"
                                "ğŸ“ ä»»åŠ¡å·²æ·»åŠ åˆ°ä¸‹è½½é˜Ÿåˆ—\n"
                                "ğŸ” æ‚¨å¯ä»¥åœ¨ qBittorrent ä¸­æŸ¥çœ‹ä¸‹è½½è¿›åº¦\n"
                                "ğŸ’¡ æç¤ºï¼šä¸‹è½½å®Œæˆåæ–‡ä»¶ä¼šä¿å­˜åˆ°é…ç½®çš„ä¸‹è½½ç›®å½•"
                            )
                        else:
                            await status_message.edit_text(
                                "âŒ **æ·»åŠ ç£åŠ›é“¾æ¥å¤±è´¥**\n\n"
                                "å¯èƒ½çš„åŸå› ï¼š\n"
                                "â€¢ qBittorrent æœªè¿æ¥æˆ–æœªé…ç½®\n"
                                "â€¢ é“¾æ¥æ ¼å¼æ— æ•ˆ\n"
                                "â€¢ qBittorrent æœåŠ¡å¼‚å¸¸\n\n"
                                "è¯·æ£€æŸ¥ qBittorrent é…ç½®å’Œè¿æ¥çŠ¶æ€"
                            )
                        return True  # è¡¨ç¤ºå·²å¤„ç†

                    # å°è¯•æå–ç§å­æ–‡ä»¶é“¾æ¥
                    torrent_match = re.search(r'https?://[^\s]*\.torrent[^\s]*', caption_text)
                    if torrent_match:
                        torrent_url = torrent_match.group(0)
                        logger.info(f"ğŸ”§ ä»åª’ä½“æ¶ˆæ¯æ–‡æœ¬ä¸­æå–ç§å­æ–‡ä»¶é“¾æ¥: {caption_text} -> {torrent_url}")
                        await status_message.edit_text("ğŸ”— æ­£åœ¨æ·»åŠ åˆ° qBittorrent...", parse_mode=None)

                        # å°è¯•æ·»åŠ åˆ° qBittorrent
                        success = await self.add_magnet_to_qb(torrent_url)

                        if success:
                            await status_message.edit_text(
                                "âœ… **ç§å­æ–‡ä»¶å·²æˆåŠŸæ·»åŠ åˆ° qBittorrentï¼**\n\n"
                                "ğŸ“ ä»»åŠ¡å·²æ·»åŠ åˆ°ä¸‹è½½é˜Ÿåˆ—\n"
                                "ğŸ” æ‚¨å¯ä»¥åœ¨ qBittorrent ä¸­æŸ¥çœ‹ä¸‹è½½è¿›åº¦\n"
                                "ğŸ’¡ æç¤ºï¼šä¸‹è½½å®Œæˆåæ–‡ä»¶ä¼šä¿å­˜åˆ°é…ç½®çš„ä¸‹è½½ç›®å½•"
                            )
                        else:
                            await status_message.edit_text(
                                "âŒ **æ·»åŠ ç§å­æ–‡ä»¶å¤±è´¥**\n\n"
                                "å¯èƒ½çš„åŸå› ï¼š\n"
                                "â€¢ qBittorrent æœªè¿æ¥æˆ–æœªé…ç½®\n"
                                "â€¢ é“¾æ¥æ ¼å¼æ— æ•ˆ\n"
                                "â€¢ qBittorrent æœåŠ¡å¼‚å¸¸\n\n"
                                "è¯·æ£€æŸ¥ qBittorrent é…ç½®å’Œè¿æ¥çŠ¶æ€"
                            )
                        return True  # è¡¨ç¤ºå·²å¤„ç†

            return False  # è¡¨ç¤ºæœªå¤„ç†ï¼Œç»§ç»­å…¶ä»–æµç¨‹
        except Exception as e:
            logger.error(f"å¤„ç†qBittorrenté“¾æ¥æ—¶å‘ç”Ÿé”™è¯¯: {e}", exc_info=True)
            await status_message.edit_text(f"âŒ å¤„ç†qBittorrenté“¾æ¥æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")
            return True  # è¡¨ç¤ºå·²å¤„ç†ï¼ˆå‡ºé”™ä¹Ÿç®—å¤„ç†äº†ï¼‰

    async def _process_download_async(
        self,
        update: Update,
        context: ContextTypes.DEFAULT_TYPE,
        url: str,
        status_message,
    ):
        """å¼‚æ­¥å¤„ç†ä¸‹è½½ä»»åŠ¡"""
        import os  # å¯¼å…¥osæ¨¡å—ä»¥è§£å†³ä½œç”¨åŸŸé—®é¢˜

        # åœ¨æ–¹æ³•å¼€å§‹æ—¶å®šä¹‰chat_idï¼Œç¡®ä¿åœ¨æ‰€æœ‰å¼‚å¸¸å¤„ç†è·¯å¾„ä¸­éƒ½å¯è®¿é—®
        chat_id = status_message.chat_id

        try:
            # é¦–å…ˆå°è¯•å¤„ç†qBittorrentç›¸å…³é“¾æ¥
            if await self.handle_qbittorrent_links(update, context, url, status_message):
                return  # å¦‚æœæ˜¯qBç›¸å…³é“¾æ¥ï¼Œå¤„ç†å®Œå°±è¿”å›

            # æ£€æŸ¥æ˜¯å¦ä¸ºBç«™è‡ªå®šä¹‰åˆ—è¡¨URL
            is_list, uid, list_id = self.downloader.is_bilibili_list_url(url)
            if is_list:
                logger.info(f"ğŸ”§ æ£€æµ‹åˆ°Bç«™ç”¨æˆ·åˆ—è¡¨URL: ç”¨æˆ·{uid}, åˆ—è¡¨{list_id}")
            # é“¾æ¥æœ‰æ•ˆæ€§æ£€æŸ¥
            platform_name = self.downloader.get_platform_name(url)
            if platform_name == "æœªçŸ¥":
                await status_message.edit_text("ğŸ™ æŠ±æ­‰ï¼Œæš‚ä¸æ”¯æŒæ‚¨å‘é€çš„ç½‘ç«™ã€‚", parse_mode=None)
                return

            # è·å–å¹³å°ä¿¡æ¯ç”¨äºåç»­åˆ¤æ–­
            platform = platform_name.lower()
        except Exception as e:
            logger.error(f"å¤„ç†ä¸‹è½½æ—¶å‘ç”Ÿæ„å¤–é”™è¯¯: {e}", exc_info=True)
            await context.bot.edit_message_text(
                text=f"âŒ å¤„ç†ä¸‹è½½æ—¶å‘ç”Ÿå†…éƒ¨é”™è¯¯ï¼š\n{str(e)}",
                chat_id=chat_id,
                message_id=status_message.message_id,
                parse_mode=None,
            )
            return

        # ç¼“å­˜ä¸Šæ¬¡å‘é€çš„å†…å®¹ï¼Œé¿å…é‡å¤å‘é€
        last_progress_text = {"text": None}

        # --- è¿›åº¦å›è°ƒ ---
        last_update_time = {"time": time.time()}
        last_progress_percent = {"value": 0}
        progress_state = {"last_stage": None, "last_percent": 0, "finished_shown": False}  # è·Ÿè¸ªä¸Šä¸€æ¬¡çš„çŠ¶æ€å’Œæ˜¯å¦å·²æ˜¾ç¤ºå®Œæˆ
        last_progress_text = {"text": ""}  # è·Ÿè¸ªä¸Šä¸€æ¬¡çš„æ–‡æœ¬å†…å®¹

        # åˆ›å»ºå¢å¼ºç‰ˆçš„æ¶ˆæ¯æ›´æ–°å™¨å‡½æ•°ï¼Œæ”¯æŒä¼ é€’ status_message å’Œ context ç»™ single_video_progress_hook
        # å¢åŠ å¯¹Bç«™å¤šPä¸‹è½½çš„æ”¯æŒï¼Œä½†ä¿æŒYouTubeåŠŸèƒ½å®Œå…¨ä¸å˜
        async def message_updater(text_or_dict, bilibili_progress_data=None):
            try:
                logger.info(f"ğŸ” message_updater è¢«è°ƒç”¨ï¼Œå‚æ•°ç±»å‹: {type(text_or_dict)}")
                logger.info(f"ğŸ” message_updater å‚æ•°å†…å®¹: {text_or_dict}")

                # å¦‚æœå·²ç»æ˜¾ç¤ºå®ŒæˆçŠ¶æ€ï¼Œå¿½ç•¥æ‰€æœ‰åç»­è°ƒç”¨
                if progress_state["finished_shown"]:
                    logger.info("ä¸‹è½½å·²å®Œæˆï¼Œå¿½ç•¥message_updateråç»­è°ƒç”¨")
                    return

                # å¤„ç†å­—ç¬¦ä¸²ç±»å‹ï¼Œé¿å…é‡å¤å‘é€ç›¸åŒå†…å®¹
                if isinstance(text_or_dict, str):
                    if text_or_dict == last_progress_text["text"]:
                        logger.info("ğŸ” è·³è¿‡é‡å¤å†…å®¹")
                        return  # è·³è¿‡é‡å¤å†…å®¹
                    last_progress_text["text"] = text_or_dict
                    await status_message.edit_text(text_or_dict, parse_mode=None)
                    return

                # æ£€æŸ¥æ˜¯å¦ä¸ºå­—å…¸ç±»å‹ï¼ˆæ¥è‡ªprogress_hookçš„è¿›åº¦æ•°æ®ï¼‰
                if isinstance(text_or_dict, dict):
                    logger.debug(f"ğŸ” æ£€æµ‹åˆ°å­—å…¸ç±»å‹ï¼ŒçŠ¶æ€: {text_or_dict.get('status')}")

                    # è®°å½•æ–‡ä»¶åï¼ˆç”¨äºæ–‡ä»¶æŸ¥æ‰¾ï¼‰
                    if text_or_dict.get("status") == "finished":
                        filename = text_or_dict.get('filename', '')
                        if filename:
                            # å¦‚æœæä¾›äº†bilibili_progress_dataï¼Œè®°å½•Bç«™ä¸‹è½½çš„æ–‡ä»¶
                            if bilibili_progress_data is not None and isinstance(bilibili_progress_data, dict):
                                if 'downloaded_files' not in bilibili_progress_data:
                                    bilibili_progress_data['downloaded_files'] = []
                                bilibili_progress_data['downloaded_files'].append(filename)
                                logger.info(f"ğŸ“ Bç«™æ–‡ä»¶è®°å½•: {filename}")
                            else:
                                # YouTubeæˆ–å…¶ä»–å¹³å°çš„å¤„ç†ä¿æŒä¸å˜
                                logger.info(f"ğŸ“ æ£€æµ‹åˆ°finishedçŠ¶æ€ï¼Œæ–‡ä»¶å: {filename}")

                    if text_or_dict.get("status") == "finished":
                        # å¯¹äºfinishedçŠ¶æ€ï¼Œä¸è°ƒç”¨update_progressï¼Œé¿å…æ˜¾ç¤ºé”™è¯¯çš„è¿›åº¦ä¿¡æ¯
                        logger.info("ğŸ” æ£€æµ‹åˆ°finishedçŠ¶æ€ï¼Œè·³è¿‡update_progressè°ƒç”¨")
                        return
                    elif text_or_dict.get("status") == "downloading":
                        # è¿™æ˜¯æ¥è‡ªprogress_hookçš„ä¸‹è½½è¿›åº¦æ•°æ®
                        logger.info("ğŸ” æ£€æµ‹åˆ°ä¸‹è½½è¿›åº¦æ•°æ®ï¼Œå‡†å¤‡è°ƒç”¨ update_progress...")
                        # è°ƒç”¨update_progresså‡½æ•°å¤„ç†è¿›åº¦æ•°æ®
                        update_progress(text_or_dict)
                        logger.info("âœ… update_progress è°ƒç”¨å®Œæˆ")

                        # æ³¨æ„ï¼šè¿™é‡Œä¸éœ€è¦å†æ¬¡è°ƒç”¨message_updaterï¼Œå› ä¸ºupdate_progresså·²ç»å¤„ç†äº†æ˜¾ç¤º
                        # å¦‚æœéœ€è¦é¢å¤–çš„æ¶ˆæ¯æ˜¾ç¤ºï¼Œåº”è¯¥åœ¨update_progresså†…éƒ¨å¤„ç†
                    else:
                        # å…¶ä»–å­—å…¸çŠ¶æ€ï¼Œè½¬æ¢ä¸ºæ–‡æœ¬
                        logger.info(f"ğŸ” å…¶ä»–å­—å…¸çŠ¶æ€: {text_or_dict}")
                        dict_text = str(text_or_dict)
                        if dict_text == last_progress_text["text"]:
                            logger.info("ğŸ” è·³è¿‡é‡å¤å­—å…¸å†…å®¹")
                            return  # è·³è¿‡é‡å¤å†…å®¹
                        last_progress_text["text"] = dict_text
                        await status_message.edit_text(dict_text, parse_mode=None)
                else:
                    # æ™®é€šæ–‡æœ¬æ¶ˆæ¯
                    logger.info(f"ğŸ” æ™®é€šæ–‡æœ¬æ¶ˆæ¯: {text_or_dict}")
                    text_str = str(text_or_dict)
                    if text_str == last_progress_text["text"]:
                        logger.info("ğŸ” è·³è¿‡é‡å¤æ–‡æœ¬å†…å®¹")
                        return  # è·³è¿‡é‡å¤å†…å®¹
                    last_progress_text["text"] = text_str
                    await status_message.edit_text(text_str, parse_mode=None)
            except Exception as e:
                logger.error(f"âŒ message_updater å¤„ç†é”™è¯¯: {e}")
                logger.error(f"âŒ å¼‚å¸¸ç±»å‹: {type(e)}")
                import traceback
                logger.error(f"âŒ å¼‚å¸¸å †æ ˆ: {traceback.format_exc()}")
                if "Message is not modified" not in str(e):
                    logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")

        # åˆ›å»ºå¢å¼ºç‰ˆçš„è¿›åº¦å›è°ƒå‡½æ•°ï¼Œæ”¯æŒä¼ é€’ status_message å’Œ context
        def enhanced_progress_callback(progress_data_dict):
            """å¢å¼ºç‰ˆè¿›åº¦å›è°ƒï¼Œæ”¯æŒä¼ é€’ status_message å’Œ context ç»™ single_video_progress_hook"""
            # åˆ›å»º single_video_progress_hook çš„å¢å¼ºç‰ˆæœ¬
            progress_hook = single_video_progress_hook(
                message_updater=None,
                progress_data=progress_data_dict,
                status_message=status_message,
                context=context
            )
            return progress_hook

        # æ›´æ–°çŠ¶æ€æ¶ˆæ¯
        try:
            if message_updater:
                logger.debug(f'message_updater type: {type(message_updater)}, value: {message_updater}')
                if asyncio.iscoroutinefunction(message_updater):
                    await message_updater("ğŸ” æ­£åœ¨åˆ†æé“¾æ¥...")
                else:
                    message_updater("ğŸ” æ­£åœ¨åˆ†æé“¾æ¥...")
        except Exception as e:
            logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")
        # ç›´æ¥å¼€å§‹ä¸‹è½½ï¼Œè·³è¿‡é¢„å…ˆè·å–ä¿¡æ¯ï¼ˆé¿å…ç”¨æˆ·ç­‰å¾…ï¼‰
        try:
            if message_updater:
                logger.debug(f'message_updater type: {type(message_updater)}, value: {message_updater}')
                if asyncio.iscoroutinefunction(message_updater):
                    await message_updater("ğŸš€ æ­£åœ¨å¯åŠ¨ä¸‹è½½...")
                else:
                    message_updater("ğŸš€ æ­£åœ¨å¯åŠ¨ä¸‹è½½...")
        except Exception as e:
            logger.warning(f"æ›´æ–°çŠ¶æ€æ¶ˆæ¯å¤±è´¥: {e}")
        # è·å–å½“å‰äº‹ä»¶å¾ªç¯
        loop = asyncio.get_running_loop()

        # ç”Ÿæˆä»»åŠ¡ID
        task_id = f"{update.effective_user.id}_{int(time.time())}"

        # æ·»åŠ  progress_data æ”¯æŒï¼ˆå‚è€ƒ main.v0.3.pyï¼‰
        progress_data = {
            'filename': '',
            'total_bytes': 0,
            'downloaded_bytes': 0,
            'speed': 0,
            'status': 'downloading',
            'final_filename': '',
            'last_update': 0,
            'progress': 0.0
        }

        # QQéŸ³ä¹ä½¿ç”¨è‡ªå·±çš„è¯¦ç»†è¿›åº¦æ˜¾ç¤ºï¼Œä¸ä½¿ç”¨å…¨å±€è¿›åº¦ç®¡ç†å™¨
        def update_progress(d):
            logger.debug(f"update_progress è¢«è°ƒç”¨: {type(d)}, å†…å®¹: {d}")

            # ğŸ¯ å…³é”®ä¿®å¤ï¼šæ£€æŸ¥ä»»åŠ¡æ˜¯å¦è¢«å–æ¶ˆ
            if task_id in self.download_tasks:
                task_info = self.download_tasks[task_id]
                if task_info.get('cancelled', False):
                    logger.info(f"ğŸš« æ£€æµ‹åˆ°ä»»åŠ¡å·²å–æ¶ˆï¼Œä¸­æ–­ä¸‹è½½: {task_id}")
                    # æŠ›å‡ºå¼‚å¸¸æ¥ä¸­æ–­ yt-dlp ä¸‹è½½
                    raise KeyboardInterrupt("ä¸‹è½½å·²è¢«ç”¨æˆ·å–æ¶ˆ")

            # æ”¯æŒå­—ç¬¦ä¸²ç±»å‹ï¼Œç›´æ¥å‘åˆ°Telegram
            if isinstance(d, str):
                try:
                    logger.info(f"ğŸ” [DEBUG] å‡†å¤‡å‘é€å­—ç¬¦ä¸²åˆ°TG: status_message={status_message}, loop={loop}")
                    if status_message is None:
                        logger.warning(f"âš ï¸ [DEBUG] status_message æ˜¯ Noneï¼Œè·³è¿‡å‘é€")
                        return
                    if loop is None:
                        logger.warning(f"âš ï¸ [DEBUG] loop æ˜¯ Noneï¼Œè·³è¿‡å‘é€")
                        return

                    logger.info(f"ğŸš€ å³å°†å‘é€æ¶ˆæ¯åˆ°TG: {d}")
                    asyncio.run_coroutine_threadsafe(
                        status_message.edit_text(d, parse_mode=None),
                        loop
                    )
                    logger.info(f"âœ… [DEBUG] å­—ç¬¦ä¸²æ¶ˆæ¯å‘é€æˆåŠŸ")
                except Exception as e:
                    logger.warning(f"å‘é€å­—ç¬¦ä¸²è¿›åº¦åˆ°TGå¤±è´¥: {e}")
                return
            # æ·»åŠ ç±»å‹æ£€æŸ¥ï¼Œç¡®ä¿dæ˜¯å­—å…¸ç±»å‹
            if not isinstance(d, dict):
                logger.warning(f"update_progressæ¥æ”¶åˆ°éå­—å…¸ç±»å‹å‚æ•°: {type(d)}, å†…å®¹: {d}")
                return

            # æ›´æ–° progress_dataï¼ˆå‚è€ƒ main.v0.3.pyï¼‰
            try:
                if d['status'] == 'downloading':
                    raw_filename = d.get('filename', '')
                    display_filename = os.path.basename(raw_filename) if raw_filename else 'video.mp4'
                    progress_data.update({
                        'filename': display_filename,
                        'total_bytes': d.get('total_bytes') or d.get('total_bytes_estimate', 0),
                        'downloaded_bytes': d.get('downloaded_bytes', 0),
                        'speed': d.get('speed', 0),
                        'status': 'downloading',
                        'progress': (d.get('downloaded_bytes', 0) / (d.get('total_bytes') or d.get('total_bytes_estimate', 1))) * 100 if (d.get('total_bytes') or d.get('total_bytes_estimate', 0)) > 0 else 0.0
                    })
                elif d['status'] == 'finished':
                    final_filename = d.get('filename', '')
                    display_filename = os.path.basename(final_filename) if final_filename else 'video.mp4'
                    progress_data.update({
                        'filename': display_filename,
                        'status': 'finished',
                        'final_filename': final_filename,
                        'progress': 100.0
                    })
            except Exception as e:
                logger.error(f"æ›´æ–° progress_data é”™è¯¯: {str(e)}")

            now = time.time()
            # ä½¿ç”¨ main.v0.3.py çš„æ–¹å¼ï¼šæ¯1ç§’æ›´æ–°ä¸€æ¬¡
            if now - last_update_time['time'] < 1.0:
                return
            # å¤„ç†Bç«™åˆé›†ä¸‹è½½è¿›åº¦
            if d.get('status') == 'downloading' and d.get('bv'):
                # Bç«™åˆé›†ä¸‹è½½è¿›åº¦
                last_update_time['time'] = now
                bv = d.get('bv', '')
                filename = d.get('filename', '')
                template = d.get('template', '')
                index = d.get('index', 0)
                total = d.get('total', 0)

                progress_text = (
                    f"ğŸš€ **æ­£åœ¨ä¸‹è½½ç¬¬{index}ä¸ª**: `{bv}` - `{filename}`\n"
                    f"ğŸ“ **æ–‡ä»¶åæ¨¡æ¿**: `{template}`\n"
                    f"ğŸ“Š **è¿›åº¦**: {index}/{total}"
                )

                async def do_update():
                    try:
                        await asyncio.wait_for(
                            context.bot.edit_message_text(
                                text=progress_text,
                                chat_id=status_message.chat_id,
                                message_id=status_message.message_id,
                                parse_mode=None
                            ),
                            timeout=10.0  # å¢åŠ åˆ°10ç§’è¶…æ—¶ï¼Œå‡å°‘è¶…æ—¶é”™è¯¯
                        )
                        logger.info(f"Bç«™åˆé›†è¿›åº¦æ›´æ–°: ç¬¬{index}/{total}ä¸ª")
                    except asyncio.TimeoutError:
                        logger.warning(f"Bç«™åˆé›†è¿›åº¦æ›´æ–°è¶…æ—¶: ç¬¬{index}/{total}ä¸ª")
                    except Exception as e:
                        if "Message is not modified" not in str(e):
                            logger.warning(f"æ›´æ–°Bç«™åˆé›†è¿›åº¦å¤±è´¥: {e}")

                asyncio.run_coroutine_threadsafe(do_update(), loop)
                return

            # å¤„ç†Bç«™åˆé›†ä¸‹è½½å®Œæˆ/å¤±è´¥
            if d.get('status') in ['finished', 'error'] and d.get('bv'):
                # Bç«™åˆé›†ä¸‹è½½å®Œæˆ/å¤±è´¥
                last_update_time['time'] = now
                bv = d.get('bv', '')
                filename = d.get('filename', '')
                index = d.get('index', 0)
                total = d.get('total', 0)
                status_emoji = "âœ…" if d.get('status') == 'finished' else "âŒ"
                status_text = "ä¸‹è½½æˆåŠŸ" if d.get('status') == 'finished' else "ä¸‹è½½å¤±è´¥"

                progress_text = (
                    f"{status_emoji} **ç¬¬{index}ä¸ª{status_text}**: `{filename}`\n"
                    f"ğŸ“Š **è¿›åº¦**: {index}/{total}"
                )

                async def do_update():
                    try:
                        await asyncio.wait_for(
                            context.bot.edit_message_text(
                                text=progress_text,
                                chat_id=status_message.chat_id,
                                message_id=status_message.message_id,
                                parse_mode=None
                            ),
                            timeout=10.0  # å¢åŠ åˆ°10ç§’è¶…æ—¶ï¼Œå‡å°‘è¶…æ—¶é”™è¯¯
                        )
                        logger.info(f"Bç«™åˆé›†çŠ¶æ€æ›´æ–°: ç¬¬{index}ä¸ª{status_text}")
                    except asyncio.TimeoutError:
                        logger.warning(f"Bç«™åˆé›†çŠ¶æ€æ›´æ–°è¶…æ—¶: ç¬¬{index}ä¸ª{status_text}")
                    except Exception as e:
                        if "Message is not modified" not in str(e):
                            logger.warning(f"æ›´æ–°Bç«™åˆé›†çŠ¶æ€å¤±è´¥: {e}")

                asyncio.run_coroutine_threadsafe(do_update(), loop)
                return

            # å¤„ç†ä¸‹è½½å®ŒæˆçŠ¶æ€ - ç›´æ¥æ˜¾ç¤ºå®Œæˆä¿¡æ¯å¹¶è¿”å›ï¼ˆå‚è€ƒ main.v0.3.pyï¼‰
            elif d.get('status') == 'finished':
                logger.info("yt-dlpä¸‹è½½å®Œæˆï¼Œæ˜¾ç¤ºå®Œæˆä¿¡æ¯")

                # è·å–è¿›åº¦ä¿¡æ¯
                if progress_data and isinstance(progress_data, dict):
                    filename = progress_data.get('filename', 'video.mp4')
                    total_bytes = progress_data.get('total_bytes', 0)
                    downloaded_bytes = progress_data.get('downloaded_bytes', 0)
                else:
                    filename = 'video.mp4'
                    total_bytes = 0
                    downloaded_bytes = 0

                # ç›‘æ§æ–‡ä»¶åˆå¹¶çŠ¶æ€
                actual_filename = d.get('filename', filename)
                if actual_filename.endswith('.part'):
                    logger.warning(f"âš ï¸ æ–‡ä»¶åˆå¹¶å¯èƒ½å¤±è´¥: {actual_filename}")
                else:
                    logger.info(f"âœ… æ–‡ä»¶ä¸‹è½½å¹¶åˆå¹¶æˆåŠŸ: {actual_filename}")

                # æ˜¾ç¤ºå®Œæˆä¿¡æ¯
                display_filename = _clean_filename_for_display_local(filename)
                progress_bar = _create_progress_bar_local(100.0)
                size_mb = total_bytes / (1024 * 1024) if total_bytes > 0 else downloaded_bytes / (1024 * 1024)

                completion_text = (
                    f"ğŸ“ æ–‡ä»¶ï¼š{display_filename}\n"
                    f"ğŸ’¾ å¤§å°ï¼š{size_mb:.2f}MB\n"
                    f"âš¡ é€Ÿåº¦ï¼šå®Œæˆ\n"
                    f"â³ é¢„è®¡å‰©ä½™ï¼š0ç§’\n"
                    f"ğŸ“Š è¿›åº¦ï¼š{progress_bar} (100.0%)"
                )

                async def do_update():
                    try:
                        await status_message.edit_text(completion_text, parse_mode=None)
                        logger.info("æ˜¾ç¤ºä¸‹è½½å®Œæˆè¿›åº¦ä¿¡æ¯")
                    except Exception as e:
                        logger.warning(f"æ˜¾ç¤ºå®Œæˆè¿›åº¦ä¿¡æ¯å¤±è´¥: {e}")

                asyncio.run_coroutine_threadsafe(do_update(), loop)
                return

            if d.get('status') == 'downloading':
                logger.debug(f"æ”¶åˆ°ä¸‹è½½è¿›åº¦å›è°ƒ: {d}")
                last_update_time['time'] = now

                total_bytes = d.get('total_bytes') or d.get('total_bytes_estimate', 0)
                downloaded_bytes = d.get('downloaded_bytes', 0)
                speed_bytes_s = d.get('speed', 0)
                eta_seconds = d.get('eta', 0)
                filename = d.get('filename', '') or "æ­£åœ¨ä¸‹è½½..."

                # ä½¿ç”¨ main.v0.3.py çš„ç®€å•é€»è¾‘
                if total_bytes > 0:
                    progress = (downloaded_bytes / total_bytes) * 100
                    progress_bar = _create_progress_bar_local(progress)
                    size_mb = total_bytes / (1024 * 1024)
                    speed_mb = (speed_bytes_s or 0) / (1024 * 1024)

                    # è®¡ç®—é¢„è®¡å‰©ä½™æ—¶é—´
                    eta_text = ""
                    if speed_bytes_s and total_bytes and downloaded_bytes < total_bytes:
                        remaining = total_bytes - downloaded_bytes
                        eta = int(remaining / speed_bytes_s)
                        mins, secs = divmod(eta, 60)
                        if mins > 0:
                            eta_text = f"{mins}åˆ†{secs}ç§’"
                        else:
                            eta_text = f"{secs}ç§’"
                    elif speed_bytes_s:
                        eta_text = "è®¡ç®—ä¸­"
                    else:
                        eta_text = "æœªçŸ¥"

                    # ç¡®ä¿æ–‡ä»¶åä¸åŒ…å«è·¯å¾„
                    display_filename = os.path.basename(filename) if filename else 'video.mp4'
                    display_filename = _clean_filename_for_display_local(display_filename)
                    downloaded_mb = downloaded_bytes / (1024 * 1024)
                    progress_text = (
                        f"ğŸ“¥ ä¸‹è½½ä¸­\n"
                        f"ğŸ“ æ–‡ä»¶å: {display_filename}\n"
                        f"ğŸ’¾ å¤§å°: {downloaded_mb:.2f}MB / {size_mb:.2f}MB\n"
                        f"âš¡ é€Ÿåº¦: {speed_mb:.2f}MB/s\n"
                        f"â³ é¢„è®¡å‰©ä½™: {eta_text}\n"
                        f"ğŸ“Š è¿›åº¦: {progress_bar} {progress:.1f}%"
                    )

                    async def do_update():
                        try:
                            await status_message.edit_text(progress_text, parse_mode=None)
                        except Exception as e:
                            if "Message is not modified" not in str(e):
                                logger.warning(f"æ›´æ–°è¿›åº¦å¤±è´¥: {e}")

                    asyncio.run_coroutine_threadsafe(do_update(), loop)
                else:
                    # æ²¡æœ‰æ€»å¤§å°ä¿¡æ¯æ—¶çš„å¤„ç†
                    downloaded_mb = downloaded_bytes / (1024 * 1024) if downloaded_bytes > 0 else 0
                    speed_mb = (speed_bytes_s or 0) / (1024 * 1024)
                    # ç¡®ä¿æ–‡ä»¶åä¸åŒ…å«è·¯å¾„
                    display_filename = os.path.basename(filename) if filename else 'video.mp4'
                    display_filename = _clean_filename_for_display_local(display_filename)
                    progress_text = (
                        f"ğŸ“¥ ä¸‹è½½ä¸­\n"
                        f"ğŸ“ æ–‡ä»¶å: {display_filename}\n"
                        f"ğŸ’¾ å¤§å°: {downloaded_mb:.2f}MB\n"
                        f"âš¡ é€Ÿåº¦: {speed_mb:.2f}MB/s\n"
                        f"â³ é¢„è®¡å‰©ä½™: æœªçŸ¥\n"
                        f"ğŸ“Š è¿›åº¦: ä¸‹è½½ä¸­..."
                    )

                    async def do_update():
                        try:
                            await status_message.edit_text(progress_text, parse_mode=None)
                        except Exception as e:
                            if "Message is not modified" not in str(e):
                                logger.warning(f"æ›´æ–°è¿›åº¦å¤±è´¥: {e}")

                    asyncio.run_coroutine_threadsafe(do_update(), loop)

        # --- æ‰§è¡Œä¸‹è½½ ---
        # æ£€æŸ¥æ˜¯å¦ä¸ºYouTube Music URLï¼Œå¦‚æœæ˜¯åˆ™ä½¿ç”¨ä¸“é—¨çš„ä¸‹è½½å™¨
        if self.downloader.is_youtube_music_url(url) and YouTubeMusicDownloader:
            logger.info(f"ğŸµ æ£€æµ‹åˆ°YouTube Music URLï¼Œä½¿ç”¨ä¸“é—¨çš„ä¸‹è½½å™¨: {url}")
            
            # åˆ›å»ºYouTube Musicä¸‹è½½ä»»åŠ¡
            try:
                youtube_music_downloader = YouTubeMusicDownloader()
                
                # æ£€æŸ¥æ˜¯å¦ä¸ºæ’­æ”¾åˆ—è¡¨
                if 'list=' in url:
                    logger.info("ğŸµ æ£€æµ‹åˆ°YouTube Musicæ’­æ”¾åˆ—è¡¨ï¼Œå¼€å§‹ä¸‹è½½...")
                    download_task = asyncio.create_task(
                        youtube_music_downloader.download_playlist(
                            url, 
                            progress_callback=update_progress
                        )
                    )
                else:
                    logger.info("ğŸµ æ£€æµ‹åˆ°YouTube Musicå•æ›²ï¼Œå¼€å§‹ä¸‹è½½...")
                    download_task = asyncio.create_task(
                        youtube_music_downloader.download_track(
                            url, 
                            progress_callback=update_progress
                        )
                    )
            except Exception as e:
                logger.error(f"âŒ YouTube Musicä¸‹è½½å™¨åˆå§‹åŒ–å¤±è´¥: {e}")
                # å›é€€åˆ°é€šç”¨ä¸‹è½½å™¨
                download_task = asyncio.create_task(
                    self.downloader.download_video(
                        url, update_progress, self.bilibili_auto_playlist, status_message, None, context
                    )
                )
        else:
            # åˆ›å»ºæ™®é€šä¸‹è½½ä»»åŠ¡ï¼Œä½¿ç”¨å¢å¼ºç‰ˆçš„è¿›åº¦å›è°ƒ
            download_task = asyncio.create_task(
                self.downloader.download_video(
                    url, update_progress, self.bilibili_auto_playlist, status_message, None, context
                )
            )

        # æ·»åŠ åˆ°ä»»åŠ¡ç®¡ç†å™¨
        await self.add_download_task(task_id, download_task, update.effective_user.id, status_message)

        try:
            # ç­‰å¾…ä¸‹è½½å®Œæˆ
            result = await download_task
        except asyncio.CancelledError:
            logger.info(f"ğŸš« ä¸‹è½½ä»»åŠ¡è¢«å–æ¶ˆ: {task_id}")
            await status_message.edit_text("ğŸš« ä¸‹è½½ä»»åŠ¡å·²å–æ¶ˆ", parse_mode=None)
            return
        except Exception as e:
            logger.error(f"âŒ ä¸‹è½½ä»»åŠ¡æ‰§è¡Œå¼‚å¸¸: {e}")
            await status_message.edit_text(f"âŒ ä¸‹è½½å¤±è´¥: {str(e)}")
            return
        finally:
            # ä»ä»»åŠ¡ç®¡ç†å™¨ä¸­ç§»é™¤ä»»åŠ¡
            await self.remove_download_task(task_id)
            # ğŸ”¥ å…³é”®ä¿®å¤ï¼šä¸‹è½½å®Œæˆåç«‹å³é”æ­»è¿›åº¦å›è°ƒï¼Œé˜²æ­¢åç»­å›è°ƒè¦†ç›–å®Œæˆä¿¡æ¯
            progress_state["finished_shown"] = True
            logger.info("ğŸ”’ ä¸‹è½½ä»»åŠ¡å®Œæˆï¼Œé”æ­»è¿›åº¦å›è°ƒ")

        # æ£€æŸ¥resultæ˜¯å¦ä¸ºNone
        if not result:
            logger.error("âŒ ä¸‹è½½ä»»åŠ¡è¿”å›Noneç»“æœ")
            await status_message.edit_text("âŒ ä¸‹è½½å¤±è´¥: æœªçŸ¥é”™è¯¯", parse_mode=None)
            return

        # å…¼å®¹ä¸åŒçš„è¿”å›æ ¼å¼ï¼šæœ‰äº›è¿”å›"success"ï¼Œæœ‰äº›è¿”å›"status"
        if result.get("success") or result.get("status") == "success":
            # æ·»åŠ è°ƒè¯•æ—¥å¿—
            logger.info(f"ä¸‹è½½å®Œæˆï¼Œç»“æœ: {result}")
            logger.info(f"is_playlist: {result.get('is_playlist')}")
            logger.info(f"platform: {result.get('platform')}")
            logger.info(f"video_type: {result.get('video_type')}")

            # ç§»é™¤UGCåˆé›†çš„ç‰¹æ®Šè·³è¿‡é€»è¾‘ï¼Œè®©æ‰€æœ‰ç»“æœéƒ½é€šè¿‡ç»Ÿä¸€çš„æ¶ˆæ¯å¤„ç†

            # æ£€æŸ¥æ˜¯å¦ä¸ºBç«™åˆé›†ä¸‹è½½
            platform_value = result.get("platform", "")
            logger.info(f"Platformå€¼: '{platform_value}'")
            logger.info(f"æ˜¯å¦åŒ…å«Bilibili: {'bilibili' in platform_value.lower()}")

            # æ›´å®½æ¾çš„Bç«™æ£€æµ‹æ¡ä»¶
            is_bilibili_playlist = (
                (result.get("is_playlist") and "bilibili" in platform_value.lower()) or
                (result.get("video_type") == "playlist" and "bilibili" in platform_value.lower()) or
                (result.get("video_type") == "user_all_videos" and "bilibili" in platform_value.lower()) or
                (result.get("is_playlist") and platform_value.lower() == "bilibili") or
                (result.get("is_playlist") and "bilibili" in str(result).lower()) or
                (result.get("download_path", "").startswith("/downloads/Bilibili") and result.get("is_playlist"))
            )

            # æ£€æŸ¥æ˜¯å¦ä¸ºBç«™UPä¸»æ‰€æœ‰è§†é¢‘ä¸‹è½½ï¼ˆç±»ä¼¼YouTubeé¢‘é“ï¼‰
            is_bilibili_channel = (
                result.get("is_channel") and "bilibili" in platform_value.lower() and
                result.get("video_type") == "user_all_videos"
            )

            logger.info(f"æ˜¯å¦ä¸ºBç«™æ’­æ”¾åˆ—è¡¨: {is_bilibili_playlist}")

            if is_bilibili_playlist:
                # æ£€æŸ¥æ˜¯å¦ä¸ºUPä¸»æ‰€æœ‰åˆé›†ä¸‹è½½
                if result.get("video_type") == "user_all_collections":
                    # UPä¸»æ‰€æœ‰åˆé›†ä¸‹è½½å®Œæˆ
                    uid = result.get("uid", "æœªçŸ¥")
                    total_collections = result.get("total_collections", 0)
                    downloaded_collections = result.get("downloaded_collections", 0)
                    file_count = result.get("file_count", 0)
                    total_size_mb = result.get("total_size_mb", 0)
                    download_path = result.get("download_path", "")
                    collections = result.get("collections", [])

                    # æ„å»ºæˆåŠŸæ¶ˆæ¯
                    success_text = f"""ğŸ¬ Bç«™UPä¸»æ‰€æœ‰åˆé›†ä¸‹è½½å®Œæˆ

ğŸ“º UPä¸»ID: {uid}
ğŸ“Š åˆé›†ç»Ÿè®¡: {downloaded_collections}/{total_collections} ä¸ªåˆé›†
ğŸ“ æ€»æ–‡ä»¶æ•°: {file_count} ä¸ª
ğŸ’¾ æ€»å¤§å°: {total_size_mb:.2f}MB
ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}

å·²ä¸‹è½½çš„åˆé›†:
"""

                    # æ·»åŠ æ¯ä¸ªåˆé›†çš„è¯¦ç»†ä¿¡æ¯
                    for i, collection in enumerate(collections, 1):
                        collection_title = collection.get('title', f'åˆé›†{i}')
                        collection_type = collection.get('type', 'unknown')
                        collection_files = collection.get('file_count', 0)
                        collection_size = collection.get('size_mb', 0)

                        type_emoji = "ğŸ“º" if collection_type == "season" else "ğŸ“"
                        success_text += f"    {i}. {type_emoji} {collection_title} ({collection_files} ä¸ªæ–‡ä»¶, {collection_size:.1f}MB)\n"

                    try:
                        await status_message.edit_text(
                            success_text,
                            parse_mode=None,
                            timeout=10.0
                        )
                        logger.info("UPä¸»æ‰€æœ‰åˆé›†ä¸‹è½½å®Œæˆæ¶ˆæ¯å‘é€æˆåŠŸ")
                    except Exception as e:
                        if "Flood control" in str(e):
                            logger.warning("UPä¸»åˆé›†ä¸‹è½½å®Œæˆæ¶ˆæ¯é‡åˆ°Flood controlï¼Œç­‰å¾…5ç§’åé‡è¯•...")
                            await asyncio.sleep(5)
                            try:
                                await status_message.edit_text(success_text, parse_mode=None)
                            except Exception as retry_error:
                                logger.error(f"é‡è¯•å‘é€UPä¸»åˆé›†å®Œæˆæ¶ˆæ¯å¤±è´¥: {retry_error}")
                        else:
                            logger.error(f"å‘é€UPä¸»åˆé›†å®Œæˆæ¶ˆæ¯å¤±è´¥: {e}")
                    return

                # Bç«™è‡ªå®šä¹‰åˆ—è¡¨ä¸‹è½½å®Œæˆï¼Œç›´æ¥ä½¿ç”¨è¿”å›çš„ç»“æœï¼Œä¸è¿›è¡Œç›®å½•éå†
                # å‚è€ƒ main.mp.py çš„é€»è¾‘
                file_count = result.get("file_count", 0)
                total_size_mb = result.get("total_size_mb", 0)
                episode_count = result.get("episode_count", 0)
                download_path = result.get("download_path", "")

                # è·å–åˆ†è¾¨ç‡ä¿¡æ¯ï¼Œä¼˜å…ˆä»filesä¸­æå–
                resolution_display = result.get("resolution", "æœªçŸ¥")
                files = result.get("files", [])
                if files and (not resolution_display or resolution_display == "æœªçŸ¥" or resolution_display == ""):
                    # ä»filesä¸­æå–åˆ†è¾¨ç‡ä¿¡æ¯
                    resolutions = set()
                    for file_info in files:
                        file_resolution = file_info.get("resolution", "")
                        if file_resolution and file_resolution != "æœªçŸ¥":
                            resolutions.add(file_resolution)

                    if resolutions:
                        resolution_display = ', '.join(sorted(resolutions))
                        logger.info(f"âœ… ä»filesä¸­æå–åˆ°åˆ†è¾¨ç‡: {resolution_display}")
                    else:
                        logger.debug("ğŸ“Š filesä¸­æ²¡æœ‰æ‰¾åˆ°åˆ†è¾¨ç‡ä¿¡æ¯ï¼Œä½¿ç”¨é»˜è®¤å€¼")
                        resolution_display = "æœªçŸ¥"  # ç¡®ä¿è¿”å›"æœªçŸ¥"è€Œä¸æ˜¯ç©ºå­—ç¬¦ä¸²

                logger.debug(f"ğŸ“Š æœ€ç»ˆä½¿ç”¨çš„åˆ†è¾¨ç‡: {resolution_display}")

                # ä»result.filesä¸­è·å–æ–‡ä»¶ååˆ—è¡¨
                filename_display = ""
                files = result.get("files", [])
                if files:
                    # æ„å»ºæ–‡ä»¶ååˆ—è¡¨
                    filename_lines = []
                    for i, file_info in enumerate(files, 1):
                        filename = file_info.get("filename", f"æ–‡ä»¶{i}")
                        filename_lines.append(f"  {i:02d}. {filename}")
                    filename_display = '\n'.join(filename_lines)
                    logger.info(f"âœ… ä»result.filesè·å–åˆ° {len(files)} ä¸ªæ–‡ä»¶å")
                else:
                    # å›é€€æ–¹æ¡ˆï¼šä½¿ç”¨result.filename
                    filename_display = result.get("filename", "")
                    logger.warning("âš ï¸ result.filesä¸ºç©ºï¼Œä½¿ç”¨result.filename")

                title = "ğŸ¬ è§†é¢‘ä¸‹è½½å®Œæˆ"
                escaped_title = (title)

                # åŠ¨æ€å¤„ç†æ–‡ä»¶åæ˜¾ç¤ºï¼Œæœ€å¤§åŒ–åˆ©ç”¨TGæ¶ˆæ¯ç©ºé—´
                filename_display = self.downloader._optimize_filename_display_for_telegram(
                    filename_display, file_count, total_size_mb, resolution_display, download_path
                )

                # ä½¿ç”¨æ™®é€šæ–‡æœ¬æ ¼å¼ï¼Œä¸éœ€è¦è½¬ä¹‰
                escaped_filename = filename_display
                escaped_resolution = resolution_display
                escaped_download_path = download_path

                # æ™®é€šæ ¼å¼ï¼Œä¸éœ€è¦è½¬ä¹‰å°æ•°ç‚¹
                total_size_str = f"{total_size_mb:.2f}"
                episode_count_str = str(episode_count)

                # è·å–PARTæ–‡ä»¶ç»Ÿè®¡ä¿¡æ¯
                success_count = result.get("success_count", file_count)  # ä½¿ç”¨file_countä½œä¸ºé»˜è®¤å€¼
                part_count = result.get("part_count", 0)

                # æ„å»ºç»Ÿè®¡ä¿¡æ¯
                stats_text = f"âœ… **æˆåŠŸ**: `{success_count} ä¸ª`"
                if part_count > 0:
                    stats_text += f"\nâš ï¸ **æœªå®Œæˆ**: `{part_count} ä¸ª`"
                    stats_text += f"\nğŸ’¡ **æç¤º**: å‘ç°æœªå®Œæˆæ–‡ä»¶ï¼Œå¯èƒ½éœ€è¦é‡æ–°ä¸‹è½½"

                # æ·»åŠ æ¸…æ™°åº¦æ ‡è¯†åˆ°åˆ†è¾¨ç‡
                def add_quality_label(resolution_str):
                    """æ ¹æ®åˆ†è¾¨ç‡æ·»åŠ æ¸…æ™°åº¦æ ‡è¯†"""
                    if not resolution_str or resolution_str == "æœªçŸ¥":
                        return resolution_str

                    # è§£æåˆ†è¾¨ç‡
                    try:
                        # å¤„ç†å¤šä¸ªåˆ†è¾¨ç‡çš„æƒ…å†µï¼ˆç”¨é€—å·åˆ†éš”ï¼‰
                        resolutions = [r.strip() for r in resolution_str.split(',')]
                        labeled_resolutions = []

                        for res in resolutions:
                            if 'x' in res.lower():
                                # æå–å®½åº¦å’Œé«˜åº¦
                                parts = res.lower().split('x')
                                if len(parts) == 2:
                                    try:
                                        # æå–æ•°å­—éƒ¨åˆ†ï¼Œå¿½ç•¥æ‹¬å·å’Œå…¶ä»–æ–‡æœ¬
                                        width_str = parts[0].strip()
                                        height_str = parts[1].strip()

                                        # ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æå–æ•°å­—
                                        import re
                                        width_match = re.search(r'(\d+)', width_str)
                                        height_match = re.search(r'(\d+)', height_str)

                                        if width_match and height_match:
                                            width = int(width_match.group(1))
                                            height = int(height_match.group(1))

                                            # æ ¹æ®åˆ†è¾¨ç‡æ·»åŠ æ¸…æ™°åº¦æ ‡è¯†
                                            if width >= 3840 or height >= 2160:
                                                quality = "4K"
                                            elif width >= 2560 or height >= 1440:
                                                quality = "2K"
                                            elif width >= 1920 or height >= 1080:
                                                quality = "1080P"
                                            elif width >= 1280 or height >= 720:
                                                quality = "720P"
                                            elif width >= 854 or height >= 480:
                                                quality = "480P"
                                            else:
                                                quality = "æ ‡æ¸…"

                                            # æ£€æŸ¥æ˜¯å¦å·²ç»åŒ…å«è´¨é‡æ ‡è¯†ï¼Œé¿å…é‡å¤æ·»åŠ 
                                            quality_patterns = [r'\(8K\)', r'\(4K\)', r'\(2K\)', r'\(1080[Pp]\)', r'\(720[Pp]\)', r'\(480[Pp]\)', r'\(360[Pp]\)', r'\(\d+[Pp]\)', r'\(æ ‡æ¸…\)']
                                            has_quality = any(re.search(pattern, res) for pattern in quality_patterns)
                                            if not has_quality:
                                                labeled_resolutions.append(f"{res} ({quality})")
                                            else:
                                                labeled_resolutions.append(res)
                                        else:
                                            labeled_resolutions.append(res)
                                    except (ValueError, AttributeError):
                                        # å¦‚æœæ— æ³•è§£ææ•°å­—ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹å­—ç¬¦ä¸²
                                        labeled_resolutions.append(res)
                                else:
                                    labeled_resolutions.append(res)
                            else:
                                # æ£€æŸ¥æ˜¯å¦æ˜¯çº¯æ•°å­—åˆ†è¾¨ç‡ï¼ˆå¦‚"1080", "720"ç­‰ï¼‰
                                try:
                                    import re
                                    height_match = re.search(r'(\d+)', res)
                                    if height_match:
                                        height = int(height_match.group(1))

                                        # æ ¹æ®é«˜åº¦æ·»åŠ æ¸…æ™°åº¦æ ‡è¯†
                                        if height >= 2160:
                                            quality = "4K"
                                        elif height >= 1440:
                                            quality = "2K"
                                        elif height >= 1080:
                                            quality = "1080P"
                                        elif height >= 720:
                                            quality = "720P"
                                        elif height >= 480:
                                            quality = "480P"
                                        else:
                                            quality = "æ ‡æ¸…"

                                        # å¦‚æœåŸå­—ç¬¦ä¸²å·²ç»åŒ…å«è´¨é‡æ ‡è¯†ï¼Œå°±ä¸é‡å¤æ·»åŠ 
                                        # ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æ£€æŸ¥æ˜¯å¦å·²æœ‰è´¨é‡æ ‡è¯†
                                        import re
                                        quality_patterns = [
                                            r'\(8K\)', r'\(4K\)', r'\(2K\)', r'\(1080[Pp]\)', r'\(720[Pp]\)', r'\(480[Pp]\)', r'\(360[Pp]\)', r'\(\d+[Pp]\)',
                                            r'8K$', r'4K$', r'2K$', r'1080[Pp]$', r'720[Pp]$', r'480[Pp]$', r'360[Pp]$', r'\d+[Pp]$'
                                        ]
                                        has_quality = any(re.search(pattern, res) for pattern in quality_patterns)
                                        if not has_quality:
                                            labeled_resolutions.append(f"{res} ({quality})")
                                        else:
                                            labeled_resolutions.append(res)
                                    else:
                                        labeled_resolutions.append(res)
                                except (ValueError, AttributeError):
                                    labeled_resolutions.append(res)

                        return ', '.join(labeled_resolutions)
                    except Exception as e:
                        logger.warning(f"è§£æåˆ†è¾¨ç‡æ—¶å‡ºé”™: {e}")
                        return resolution_str

                # æ·»åŠ æ¸…æ™°åº¦æ ‡è¯†
                resolution_with_quality = add_quality_label(resolution_display)
                escaped_resolution_with_quality = resolution_with_quality

                success_text = (
                    f"{escaped_title}\n\n"
                    f"ğŸ“ **æ–‡ä»¶å**:\n{escaped_filename}\n\n"
                    f"ğŸ’¾ **æ–‡ä»¶å¤§å°**: `{total_size_str} MB`\n"
                    f"ğŸ“Š **ä¸‹è½½ç»Ÿè®¡**:\n{stats_text}\n"
                    f"ğŸ–¼ï¸ **åˆ†è¾¨ç‡**: `{escaped_resolution_with_quality}`\n"
                    f"ğŸ“‚ **ä¿å­˜ä½ç½®**: `{escaped_download_path}`"
                )

                try:
                    await status_message.edit_text(
                        text=success_text, parse_mode=None
                    )
                except Exception as e:
                    if "Flood control" in str(e):
                        logger.warning(
                            "Bç«™åˆé›†ä¸‹è½½å®Œæˆæ¶ˆæ¯é‡åˆ°Flood controlï¼Œç­‰å¾…5ç§’åé‡è¯•..."
                        )
                        await asyncio.sleep(5)
                        try:
                            await status_message.edit_text(
                                text=success_text, parse_mode=None
                            )
                        except Exception as retry_error:
                            logger.error(
                                f"é‡è¯•å‘é€Bç«™åˆé›†å®Œæˆæ¶ˆæ¯å¤±è´¥: {retry_error}"
                            )
                    else:
                        logger.error(f"å‘é€Bç«™åˆé›†å®Œæˆæ¶ˆæ¯å¤±è´¥: {e}")
            # æ£€æŸ¥æ˜¯å¦ä¸ºBç«™UPä¸»é¢‘é“ä¸‹è½½
            elif is_bilibili_channel:
                # Bç«™UPä¸»æ‰€æœ‰è§†é¢‘ä¸‹è½½å®Œæˆï¼ˆç±»ä¼¼YouTubeé¢‘é“ï¼‰
                title = "ğŸ“º Bç«™UPä¸»æ‰€æœ‰è§†é¢‘ä¸‹è½½å®Œæˆ"
                channel_title = result.get("channel_title", "æœªçŸ¥UPä¸»")
                total_videos = result.get("total_videos", 0)
                downloaded_videos = result.get("downloaded_videos", 0)
                failed_videos = result.get("failed_videos", 0)
                success_rate = result.get("success_rate", 0)
                total_size_mb = result.get("total_size_mb", 0)
                download_path = result.get("download_path", "")

                # æ ¼å¼åŒ–æ€»å¤§å°æ˜¾ç¤º
                if total_size_mb >= 1024:
                    total_size_str = f"{total_size_mb / 1024:.2f}GB"
                else:
                    total_size_str = f"{total_size_mb:.2f}MB"

                # è·å–æ’­æ”¾åˆ—è¡¨ä¿¡æ¯
                playlists = result.get("playlists_downloaded", [])
                playlist_stats = result.get("playlist_stats", [])

                success_text = f"""ğŸ“º **Bç«™UPä¸»æ’­æ”¾åˆ—è¡¨ä¸‹è½½å®Œæˆ**

ğŸ“º **UPä¸»**: `{(channel_title)}`
ğŸ“Š **æ’­æ”¾åˆ—è¡¨æ•°é‡**: `{(str(len(playlists)))}` ä¸ª

**å·²ä¸‹è½½çš„æ’­æ”¾åˆ—è¡¨**:

"""

                # æ·»åŠ æ¯ä¸ªæ’­æ”¾åˆ—è¡¨çš„è¯¦ç»†ä¿¡æ¯
                for i, stat in enumerate(playlist_stats, 1):
                    playlist_title = stat.get("title", f"æ’­æ”¾åˆ—è¡¨{i}")
                    video_count = stat.get("video_count", 0)

                    success_text += f"    {i}. {playlist_title} ({video_count} é›†)\n"

                success_text += f"""
ğŸ“Š ä¸‹è½½ç»Ÿè®¡:
æ€»è®¡: {total_videos} ä¸ª
âœ… æˆåŠŸ: {downloaded_videos} ä¸ª
âŒ å¤±è´¥: {failed_videos} ä¸ª

ğŸ’¾ æ–‡ä»¶æ€»å¤§å°: {total_size_str}
ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}"""

                try:
                    await status_message.edit_text(
                        success_text,
                        parse_mode=None,
                        timeout=10.0
                    )
                    logger.info("Bç«™UPä¸»æ‰€æœ‰è§†é¢‘ä¸‹è½½å®Œæˆæ¶ˆæ¯å‘é€æˆåŠŸ")
                except Exception as e:
                    if "Flood control" in str(e):
                        logger.warning("Bç«™UPä¸»ä¸‹è½½å®Œæˆæ¶ˆæ¯é‡åˆ°Flood controlï¼Œç­‰å¾…5ç§’åé‡è¯•...")
                        await asyncio.sleep(5)
                        try:
                            await status_message.edit_text(success_text, parse_mode=None)
                        except Exception as retry_error:
                            logger.error(f"é‡è¯•å‘é€Bç«™UPä¸»å®Œæˆæ¶ˆæ¯å¤±è´¥: {retry_error}")
                    else:
                        logger.error(f"å‘é€Bç«™UPä¸»å®Œæˆæ¶ˆæ¯å¤±è´¥: {e}")
                return

            # æ£€æŸ¥æ˜¯å¦ä¸ºæ’­æ”¾åˆ—è¡¨æˆ–é¢‘é“ä¸‹è½½
            elif result.get("is_playlist") or result.get("is_channel") or result.get("downloaded_files"):
                # æ’­æ”¾åˆ—è¡¨æˆ–é¢‘é“ä¸‹è½½å®Œæˆ
                if result.get("is_channel"):
                    title = "ğŸ“º YouTubeé¢‘é“æ’­æ”¾åˆ—è¡¨ä¸‹è½½å®Œæˆ"
                    channel_title = result.get("channel_title", "æœªçŸ¥é¢‘é“")
                    playlists = result.get("playlists_downloaded", [])
                    playlist_stats = result.get("playlist_stats", [])
                    download_path = result.get("download_path", "")

                    # è®¡ç®—æ€»æ–‡ä»¶å¤§å°å’ŒPARTæ–‡ä»¶ç»Ÿè®¡
                    total_size_mb = sum(stat.get('total_size_mb', 0) for stat in playlist_stats)
                    total_size_gb = total_size_mb / 1024

                    # è®¡ç®—æ€»çš„æˆåŠŸå’Œæœªå®Œæˆæ–‡ä»¶æ•°é‡
                    total_success_count = sum(stat.get('success_count', stat.get('video_count', 0)) for stat in playlist_stats)
                    total_part_count = sum(stat.get('part_count', 0) for stat in playlist_stats)

                    # è®¡ç®—æ€»è®¡æ•°é‡å’Œå¤±è´¥æ•°é‡
                    total_video_count = sum(stat.get('video_count', 0) for stat in playlist_stats)
                    total_failed_count = total_video_count - total_success_count



                    # æ ¼å¼åŒ–æ€»å¤§å°æ˜¾ç¤º - åªæ˜¾ç¤ºä¸€ä¸ªå•ä½
                    if total_size_gb >= 1.0:
                        total_size_str = f"{total_size_gb:.2f}GB"
                    else:
                        total_size_str = f"{total_size_mb:.2f}MB"

                    success_text = (
                        f"{(title)}\n\n"
                        f"ğŸ“º é¢‘é“: {(channel_title)}\n"
                        f"ğŸ“Š æ’­æ”¾åˆ—è¡¨æ•°é‡: {(str(len(playlists)))}\n\n"
                        f"å·²ä¸‹è½½çš„æ’­æ”¾åˆ—è¡¨:\n\n"
                    )

                    # ä½¿ç”¨playlist_statsæ¥æ˜¾ç¤ºé›†æ•°ä¿¡æ¯
                    for i, stat in enumerate(playlist_stats, 1):
                        playlist_title = stat.get("title", f"æ’­æ”¾åˆ—è¡¨{i}")
                        video_count = stat.get("video_count", 0)
                        success_text += f"    {(str(i))}\\. {(playlist_title)} \\({(str(video_count))} é›†\\)\n"

                    # æ„å»ºä¸‹è½½ç»Ÿè®¡ä¿¡æ¯ï¼ˆç§»é™¤æˆåŠŸç‡ï¼Œç®€åŒ–æ ¼å¼ï¼‰
                    stats_text = f"æ€»è®¡: {total_video_count} ä¸ª\nâœ… æˆåŠŸ: {total_success_count} ä¸ª\nâŒ å¤±è´¥: {total_failed_count} ä¸ª"

                    if total_part_count > 0:
                        stats_text += f"\nâš ï¸ æœªå®Œæˆ: {total_part_count} ä¸ª"

                    # æ·»åŠ ç»Ÿè®¡ä¿¡æ¯ã€æ€»å¤§å°å’Œä¿å­˜ä½ç½®ï¼ˆåœ¨æ–‡ä»¶æ€»å¤§å°å‰åŠ ç©ºè¡Œï¼‰
                    success_text += (
                        f"\nğŸ“Š ä¸‹è½½ç»Ÿè®¡:\n{stats_text}\n\n"
                        f"ğŸ’¾ æ–‡ä»¶æ€»å¤§å°: {(total_size_str)}\n"
                        f"ğŸ“‚ ä¿å­˜ä½ç½®: {(download_path)}"
                    )
                else:
                    # æ£€æŸ¥æ˜¯å¦ä¸ºXæ’­æ”¾åˆ—è¡¨
                    platform = result.get("platform", "")
                    if platform == "X" and result.get("is_playlist"):
                        # Xæ’­æ”¾åˆ—è¡¨ä¸‹è½½å®Œæˆ
                        title = "ğŸ¬ Xæ’­æ”¾åˆ—è¡¨ä¸‹è½½å®Œæˆ"
                        file_count = result.get("file_count", 0)
                        episode_count = result.get("episode_count", 0)
                        total_size_mb = result.get("total_size_mb", 0)
                        resolution = result.get("resolution", "æœªçŸ¥")
                        download_path = result.get("download_path", "")
                        filename_display = result.get("filename", "")

                        success_text = (
                            f"{title}\n\n"
                            f"ğŸ“ æ–‡ä»¶å:\n{filename_display}\n\n"
                            f"ğŸ’¾ æ–‡ä»¶å¤§å°: {total_size_mb:.2f} MB\n"
                            f"ğŸ“Š é›†æ•°: {episode_count} é›†\n"
                            f"ğŸ–¼ï¸ åˆ†è¾¨ç‡: {resolution}\n"
                            f"ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}"
                        )
                    else:
                        # YouTubeæ’­æ”¾åˆ—è¡¨ä¸‹è½½å®Œæˆ
                        # æ£€æŸ¥æ˜¯å¦æœ‰è¯¦ç»†çš„æ–‡ä»¶ä¿¡æ¯
                        downloaded_files = result.get("downloaded_files", [])
                        if downloaded_files:
                            # æœ‰è¯¦ç»†æ–‡ä»¶ä¿¡æ¯ï¼Œä½¿ç”¨å¢å¼ºæ˜¾ç¤º
                            title = "ğŸ¬ è§†é¢‘ä¸‹è½½å®Œæˆ"
                            playlist_title = result.get("playlist_title", "YouTubeæ’­æ”¾åˆ—è¡¨")
                            video_count = result.get("video_count", len(downloaded_files))
                            total_size_mb = result.get("total_size_mb", 0)
                            resolution = result.get("resolution", "æœªçŸ¥")
                            download_path = result.get("download_path", "")

                            # æ„å»ºæ–‡ä»¶åæ˜¾ç¤ºåˆ—è¡¨
                            filename_lines = []
                            for i, file_info in enumerate(downloaded_files, 1):
                                filename = file_info.get("filename", f"æ–‡ä»¶{i}")
                                filename_lines.append(f"  {i:02d}. {filename}")
                            filename_display = '\n'.join(filename_lines)

                            # åŠ¨æ€å¤„ç†æ–‡ä»¶åæ˜¾ç¤ºï¼Œæœ€å¤§åŒ–åˆ©ç”¨TGæ¶ˆæ¯ç©ºé—´
                            filename_display = self.downloader._optimize_filename_display_for_telegram(
                                filename_display, video_count, total_size_mb, resolution, download_path
                            )

                            # è·å–PARTæ–‡ä»¶ç»Ÿè®¡ä¿¡æ¯
                            success_count = result.get("success_count", video_count)
                            part_count = result.get("part_count", 0)

                            # æ„å»ºç»Ÿè®¡ä¿¡æ¯
                            stats_text = f"âœ… **æˆåŠŸ**: `{success_count} ä¸ª`"
                            if part_count > 0:
                                stats_text += f"\nâš ï¸ **æœªå®Œæˆ**: `{part_count} ä¸ª`"
                                stats_text += f"\nğŸ’¡ **æç¤º**: å‘ç°æœªå®Œæˆæ–‡ä»¶ï¼Œå¯èƒ½éœ€è¦é‡æ–°ä¸‹è½½"

                            # ä½¿ç”¨æ™®é€šæ–‡æœ¬æ ¼å¼ï¼Œä¸éœ€è¦è½¬ä¹‰
                            escaped_title = title
                            escaped_filename = filename_display
                            escaped_resolution = resolution
                            escaped_download_path = download_path
                            size_str = f"{total_size_mb:.2f}"

                            success_text = (
                                f"{escaped_title}\n\n"
                                f"ğŸ“ **æ–‡ä»¶å**:\n{escaped_filename}\n\n"
                                f"ğŸ’¾ **æ–‡ä»¶å¤§å°**: `{size_str} MB`\n"
                                f"ğŸ“Š **ä¸‹è½½ç»Ÿè®¡**:\n{stats_text}\n"
                                f"ğŸ–¼ï¸ **åˆ†è¾¨ç‡**: `{escaped_resolution}`\n"
                                f"ğŸ“‚ **ä¿å­˜ä½ç½®**: `{escaped_download_path}`"
                            )
                        else:
                            # æ²¡æœ‰è¯¦ç»†æ–‡ä»¶ä¿¡æ¯ï¼Œä½¿ç”¨ç®€å•æ˜¾ç¤º
                            title = "ğŸ“‹ YouTubeæ’­æ”¾åˆ—è¡¨ä¸‹è½½å®Œæˆ"
                            playlist_title = result.get("playlist_title", "æœªçŸ¥æ’­æ”¾åˆ—è¡¨")
                            video_count = result.get("video_count", 0)
                            download_path = result.get("download_path", "")

                            # æ£€æŸ¥æ˜¯å¦å·²ç»ä¸‹è½½è¿‡
                            if result.get("already_downloaded", False):
                                title = "ğŸ“‹ YouTubeæ’­æ”¾åˆ—è¡¨å·²å­˜åœ¨"
                                completion_rate = result.get("completion_rate", 100)
                                completion_str = f"{completion_rate:.1f}".replace('.', r'\.')

                                success_text = (
                                    f"{(title)}\n\n"
                                    f"ğŸ“‹ **æ’­æ”¾åˆ—è¡¨**: `{(playlist_title)}`\n"
                                    f"ğŸ“‚ **ä¿å­˜ä½ç½®**: `{(download_path)}`\n"
                                    f"ğŸ“Š **è§†é¢‘æ•°é‡**: `{(str(video_count))}`\n"
                                    f"âœ… **å®Œæˆåº¦**: `{completion_str}%`\n"
                                    f"ğŸ’¡ **çŠ¶æ€**: æœ¬åœ°æ–‡ä»¶å·²å­˜åœ¨ï¼Œæ— éœ€é‡å¤ä¸‹è½½"
                                )
                            else:
                                # æ£€æŸ¥æ˜¯å¦ä¸ºé›¶æ–‡ä»¶æƒ…å†µï¼ˆæ‰€æœ‰è§†é¢‘ä¸å¯ç”¨ï¼‰
                                if video_count == 0:
                                    title = "âš ï¸ YouTubeæ’­æ”¾åˆ—è¡¨æ— å¯ç”¨è§†é¢‘"
                                    success_text = (
                                        f"{(title)}\n\n"
                                        f"ğŸ“‹ **æ’­æ”¾åˆ—è¡¨**: `{(playlist_title)}`\n"
                                        f"ğŸ“‚ **ä¿å­˜ä½ç½®**: `{(download_path)}`\n"
                                        f"âŒ **çŠ¶æ€**: æ’­æ”¾åˆ—è¡¨ä¸­çš„æ‰€æœ‰è§†é¢‘éƒ½ä¸å¯ç”¨\n"
                                        f"ğŸ’¡ **å¯èƒ½åŸå› **: è§†é¢‘è¢«åˆ é™¤ã€è´¦å·è¢«ç»ˆæ­¢æˆ–åœ°åŒºé™åˆ¶"
                                    )
                                else:
                                    # å°è¯•ä»ä¸‹è½½ç›®å½•è·å–æ–‡ä»¶å
                                    filename_display = ""
                                    try:
                                        from pathlib import Path
                                        download_dir = Path(download_path)

                                        # å¦‚æœæœ‰æ’­æ”¾åˆ—è¡¨æ ‡é¢˜ï¼ŒæŸ¥æ‰¾å¯¹åº”çš„å­ç›®å½•
                                        if playlist_title and playlist_title != "æœªçŸ¥æ’­æ”¾åˆ—è¡¨":
                                            playlist_dir = download_dir / playlist_title
                                            if playlist_dir.exists():
                                                # éå†æ’­æ”¾åˆ—è¡¨ç›®å½•ä¸­çš„æ–‡ä»¶
                                                video_files = []
                                                for file_path in playlist_dir.glob("*"):
                                                    if file_path.is_file() and file_path.suffix.lower() in ['.mp4', '.mkv', '.webm', '.avi', '.mov']:
                                                        video_files.append(file_path)

                                                if video_files:
                                                    # æ„å»ºæ–‡ä»¶ååˆ—è¡¨
                                                    filename_lines = []
                                                    for i, file_path in enumerate(sorted(video_files), 1):
                                                        filename_lines.append(f"  {i:02d}. {file_path.name}")
                                                    filename_display = '\n'.join(filename_lines)
                                                    logger.info(f"âœ… ä»æ’­æ”¾åˆ—è¡¨ç›®å½•æ‰¾åˆ° {len(video_files)} ä¸ªæ–‡ä»¶")
                                        else:
                                            # å¦‚æœæ²¡æœ‰æ’­æ”¾åˆ—è¡¨æ ‡é¢˜ï¼Œéå†æ ¹ç›®å½•
                                            video_files = []
                                            for file_path in download_dir.glob("*"):
                                                if file_path.is_file() and file_path.suffix.lower() in ['.mp4', '.mkv', '.webm', '.avi', '.mov']:
                                                    video_files.append(file_path)

                                            if video_files:
                                                # æ„å»ºæ–‡ä»¶ååˆ—è¡¨
                                                filename_lines = []
                                                for i, file_path in enumerate(sorted(video_files), 1):
                                                    filename_lines.append(f"  {i:02d}. {file_path.name}")
                                                filename_display = '\n'.join(filename_lines)
                                                logger.info(f"âœ… ä»æ ¹ç›®å½•æ‰¾åˆ° {len(video_files)} ä¸ªæ–‡ä»¶")

                                        # å¦‚æœä»ç„¶æ²¡æœ‰æ‰¾åˆ°æ–‡ä»¶ï¼Œå°è¯•é€’å½’éå†
                                        if not filename_display:
                                            logger.warning("âš ï¸ æœªæ‰¾åˆ°æ–‡ä»¶ï¼Œå°è¯•é€’å½’éå†æ‰€æœ‰å­ç›®å½•")
                                            video_files = []
                                            for file_path in download_dir.rglob("*"):
                                                if file_path.is_file() and file_path.suffix.lower() in ['.mp4', '.mkv', '.webm', '.avi', '.mov']:
                                                    video_files.append(file_path)

                                            if video_files:
                                                # æ„å»ºæ–‡ä»¶ååˆ—è¡¨
                                                filename_lines = []
                                                for i, file_path in enumerate(sorted(video_files), 1):
                                                    filename_lines.append(f"  {i:02d}. {file_path.name}")
                                                filename_display = '\n'.join(filename_lines)
                                                logger.info(f"âœ… é€’å½’æ‰¾åˆ° {len(video_files)} ä¸ªæ–‡ä»¶")

                                    except Exception as e:
                                        logger.error(f"è·å–æ–‡ä»¶åæ—¶å‡ºé”™: {e}")

                                    # æ„å»ºæˆåŠŸæ¶ˆæ¯
                                    if filename_display:
                                        success_text = (
                                            f"{title}\n\n"
                                            f"ğŸ“ æ–‡ä»¶å:\n{filename_display}\n\n"
                                            f"ğŸ“‹ æ’­æ”¾åˆ—è¡¨: {playlist_title}\n"
                                            f"ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}\n"
                                            f"ğŸ“Š è§†é¢‘æ•°é‡: {video_count}"
                                        )
                                    else:
                                        success_text = (
                                            f"{title}\n\n"
                                            f"ğŸ“‹ æ’­æ”¾åˆ—è¡¨: {playlist_title}\n"
                                            f"ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}\n"
                                            f"ğŸ“Š è§†é¢‘æ•°é‡: {video_count}"
                                        )

                try:
                    await status_message.edit_text(
                        text=success_text, parse_mode=None
                    )
                except Exception as e:
                    if "Flood control" in str(e):
                        logger.warning(
                            "æ’­æ”¾åˆ—è¡¨ä¸‹è½½å®Œæˆæ¶ˆæ¯é‡åˆ°Flood controlï¼Œç­‰å¾…5ç§’åé‡è¯•..."
                        )
                        await asyncio.sleep(5)
                        try:
                            await status_message.edit_text(
                                text=success_text, parse_mode=None
                            )
                        except Exception as retry_error:
                            logger.error(
                                f"é‡è¯•å‘é€æ’­æ”¾åˆ—è¡¨å®Œæˆæ¶ˆæ¯å¤±è´¥: {retry_error}"
                            )
                    else:
                        logger.error(f"å‘é€æ’­æ”¾åˆ—è¡¨å®Œæˆæ¶ˆæ¯å¤±è´¥: {e}")
            else:
                # å•æ–‡ä»¶ä¸‹è½½ï¼Œä½¿ç”¨åŸæœ‰é€»è¾‘
                # æ ¹æ®ç»“æœæ„å»ºæˆåŠŸæ¶ˆæ¯
                resolution = result.get("resolution", "æœªçŸ¥")
                
                # ä¿®å¤å°çº¢ä¹¦å›¾ç‰‡ä¸‹è½½å®Œæˆæ¶ˆæ¯æ˜¾ç¤ºé—®é¢˜
                # å°çº¢ä¹¦ä¸‹è½½å™¨è¿”å›çš„ç»“æœä¸­æ²¡æœ‰resolutionå­—æ®µï¼Œåªæœ‰content_typeå­—æ®µ
                # åªåœ¨ç¡®å®æ˜¯å°çº¢ä¹¦å¹³å°æ—¶æ‰æ‰§è¡Œå›¾ç‰‡æ£€æµ‹é€»è¾‘
                if platform.lower() == 'xiaohongshu' or result.get('platform') == 'Xiaohongshu':
                    logger.info(f"ğŸ” [_process_download_async] æ£€æŸ¥å°çº¢ä¹¦å›¾ç‰‡ - content_type: {result.get('content_type')}, resolution: {resolution}")
                if result.get('content_type') == 'image' and resolution == 'æœªçŸ¥':
                    resolution = 'å›¾ç‰‡'
                    logger.info(f"âœ… [_process_download_async] å°çº¢ä¹¦å›¾ç‰‡æ£€æµ‹æˆåŠŸï¼Œè®¾ç½®resolutionä¸º: {resolution}")
                else:
                    logger.info(f"ğŸ” [_process_download_async] éå°çº¢ä¹¦å¹³å°ï¼Œè·³è¿‡å›¾ç‰‡æ£€æµ‹ - platform: {platform}, content_type: {result.get('content_type')}")
                    
                abr = result.get("abr")

                # æ ¹æ®åˆ†è¾¨ç‡åˆ¤æ–­æ˜¯è§†é¢‘è¿˜æ˜¯éŸ³é¢‘
                if resolution and resolution != "æœªçŸ¥" and resolution == "å›¾ç‰‡":
                    # å›¾ç‰‡ç±»å‹
                    title = "ğŸ–¼ï¸ å›¾ç‰‡ä¸‹è½½å®Œæˆ"
                    size_str = f"{result['total_size_mb']:.2f}"
                    files_count = result.get("files_count", 1)
                    file_formats = result.get("file_formats", [])
                    format_str = ", ".join(file_formats) if file_formats else "æœªçŸ¥æ ¼å¼"

                    # æ„å»ºæ–‡ä»¶ååˆ—è¡¨
                    files_info = result.get("files", [])
                    filenames_text = ""
                    if files_info:
                        if len(files_info) <= 5:
                            # æ–‡ä»¶æ•°é‡è¾ƒå°‘ï¼Œæ˜¾ç¤ºæ‰€æœ‰æ–‡ä»¶å
                            filenames_text = "\nğŸ“ **æ–‡ä»¶å**:\n"
                            for i, file_info in enumerate(files_info, 1):
                                # ä»pathä¸­æå–æ–‡ä»¶å
                                file_path = file_info.get('path', f'å›¾ç‰‡{i}')
                                filename = os.path.basename(file_path) if file_path else f'å›¾ç‰‡{i}'
                                filenames_text += f"  `{i}. {filename}`\n"
                        else:
                            # æ–‡ä»¶æ•°é‡è¾ƒå¤šï¼Œåªæ˜¾ç¤ºå‰3ä¸ªå’Œå1ä¸ª
                            filenames_text = "\nğŸ“ **æ–‡ä»¶å**:\n"
                            for i in range(min(3, len(files_info))):
                                file_path = files_info[i].get('path', f'å›¾ç‰‡{i+1}')
                                filename = os.path.basename(file_path) if file_path else f'å›¾ç‰‡{i+1}'
                                filenames_text += f"  `{i+1}. {filename}`\n"
                            if len(files_info) > 3:
                                filenames_text += f"  `... ç­‰ {len(files_info) - 3} ä¸ªæ–‡ä»¶`\n"
                                if len(files_info) > 4:
                                    last_file = files_info[-1]
                                    last_file_path = last_file.get('path', f'å›¾ç‰‡{len(files_info)}')
                                    last_filename = os.path.basename(last_file_path) if last_file_path else f'å›¾ç‰‡{len(files_info)}'
                                    filenames_text += f"  `{len(files_info)}. {last_filename}`\n"
                    elif result.get('filename'):
                        # å¦‚æœæ²¡æœ‰filesä¿¡æ¯ä½†æœ‰å•ä¸ªfilename
                        filenames_text = f"\nğŸ“ **æ–‡ä»¶å**: `{result['filename']}`\n"

                    success_text = (
                        f"{title}\n\n"
                        f"ğŸ–¼ï¸ **å›¾ç‰‡æ•°é‡**: `{files_count} å¼ `\n"
                        f"ğŸ’¾ **æ–‡ä»¶å¤§å°**: `{size_str} MB`\n"
                        f"ğŸ“„ **æ–‡ä»¶æ ¼å¼**: `{format_str}`{filenames_text}"
                        f"ğŸ“‚ **ä¿å­˜ä½ç½®**: `{result['download_path']}`"
                    )

                    # å‘é€å›¾ç‰‡å®Œæˆæ¶ˆæ¯ï¼Œæ›¿æ¢è¿›åº¦æ¶ˆæ¯
                    logger.info(f"ğŸ“¤ [_process_download_async] å‡†å¤‡å‘é€å°çº¢ä¹¦å›¾ç‰‡å®Œæˆæ¶ˆæ¯ï¼Œæ¶ˆæ¯é•¿åº¦: {len(success_text)}")
                    
                    # ç­‰å¾…ä¸€æ®µæ—¶é—´ï¼Œç¡®ä¿xiaohongshu_downloaderçš„è¿›åº¦æ¶ˆæ¯è¢«å¤„ç†å®Œæ¯•
                    logger.info("â³ ç­‰å¾…è¿›åº¦æ¶ˆæ¯å¤„ç†å®Œæˆï¼Œç„¶åå‘é€æ±‡æ€»ä¿¡æ¯...")
                    await asyncio.sleep(2.0)  # ç­‰å¾…2ç§’
                    
                    try:
                        await status_message.edit_text(success_text, parse_mode=None)
                        logger.info("âœ… [_process_download_async] å°çº¢ä¹¦å›¾ç‰‡ä¸‹è½½å®Œæˆæ¶ˆæ¯å‘é€æˆåŠŸ")
                    except Exception as e:
                        if "Flood control" in str(e):
                            logger.warning("âš ï¸ [_process_download_async] å›¾ç‰‡ä¸‹è½½å®Œæˆæ¶ˆæ¯é‡åˆ°Flood controlï¼Œç­‰å¾…5ç§’åé‡è¯•...")
                            await asyncio.sleep(5)
                            try:
                                await status_message.edit_text(success_text, parse_mode=None)
                                logger.info("âœ… [_process_download_async] é‡è¯•å‘é€å›¾ç‰‡ä¸‹è½½å®Œæˆæ¶ˆæ¯æˆåŠŸ")
                            except Exception as retry_error:
                                logger.error(f"âŒ [_process_download_async] é‡è¯•å‘é€å›¾ç‰‡ä¸‹è½½å®Œæˆæ¶ˆæ¯å¤±è´¥: {retry_error}")
                        else:
                            logger.error(f"âŒ [_process_download_async] å‘é€å›¾ç‰‡ä¸‹è½½å®Œæˆæ¶ˆæ¯å¤±è´¥: {e}")
                    
                    # å›¾ç‰‡ä¸‹è½½å®Œæˆï¼Œè¿›åº¦æ¶ˆæ¯å·²è¢«å®Œæˆæ¶ˆæ¯æ›¿æ¢ï¼Œç›´æ¥è¿”å›
                    logger.info("ğŸ”š [_process_download_async] å°çº¢ä¹¦å›¾ç‰‡ä¸‹è½½å¤„ç†å®Œæˆï¼Œç›´æ¥è¿”å›")
                    return
                elif resolution and resolution != "æœªçŸ¥" and "x" in resolution:
                    # æœ‰åˆ†è¾¨ç‡ä¿¡æ¯ï¼Œè¯´æ˜æ˜¯è§†é¢‘
                    # è§£æåˆ†è¾¨ç‡å¹¶æ·»åŠ è´¨é‡æ ‡è¯†
                    try:
                        width_str, height_str = resolution.split("x")
                        # ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼æå–æ•°å­—éƒ¨åˆ†ï¼Œå¿½ç•¥æ‹¬å·å’Œå…¶ä»–æ–‡æœ¬
                        import re
                        width_match = re.search(r'(\d+)', width_str.strip())
                        height_match = re.search(r'(\d+)', height_str.strip())

                        if width_match and height_match:
                            width = int(width_match.group(1))
                            height = int(height_match.group(1))
                        else:
                            # å¦‚æœæ— æ³•æå–æ•°å­—ï¼Œè·³è¿‡è´¨é‡æ ‡è¯†
                            raise ValueError("æ— æ³•æå–åˆ†è¾¨ç‡æ•°å­—")

                        # æ ¹æ®é«˜åº¦åˆ¤æ–­è´¨é‡
                        if height >= 4320:
                            quality = "8K"
                        elif height >= 2160:
                            quality = "4K"
                        elif height >= 1440:
                            quality = "2K"
                        elif height >= 1080:
                            quality = "1080p"
                        elif height >= 720:
                            quality = "720p"
                        elif height >= 480:
                            quality = "480p"
                        else:
                            quality = f"{height}p"

                        quality_info = f" ({quality})"
                    except (ValueError, TypeError):
                        quality_info = ""

                    # æ„å»ºå®Œæ•´çš„titleï¼Œç„¶åä¸€æ¬¡æ€§è½¬ä¹‰
                    title = "ğŸ¬ è§†é¢‘ä¸‹è½½å®Œæˆ"
                    escaped_title = (title)
                    # å°†è´¨é‡æ ‡è¯†æ·»åŠ åˆ°åˆ†è¾¨ç‡åé¢
                    resolution_with_quality = f"{resolution}{quality_info}"
                    size_str = f"{result['size_mb']:.2f}"
                    success_text = (
                        f"{escaped_title}\n\n"
                        f"ğŸ“ æ–‡ä»¶å: {result['filename']}\n"
                        f"ğŸ’¾ æ–‡ä»¶å¤§å°: {result['size_mb']:.2f} MB\n"
                        f"ğŸ“º åˆ†è¾¨ç‡: {resolution_with_quality}\n"
                        f"ğŸ“‚ ä¿å­˜ä½ç½®: {result['download_path']}"
                    )
                    
                    # å‘é€è§†é¢‘å®Œæˆæ¶ˆæ¯
                    try:
                        await status_message.edit_text(success_text, parse_mode=None)
                        logger.info("æ˜¾ç¤ºè§†é¢‘ä¸‹è½½å®Œæˆä¿¡æ¯")
                    except Exception as e:
                        if "Flood control" in str(e):
                            logger.warning("è§†é¢‘ä¸‹è½½å®Œæˆæ¶ˆæ¯é‡åˆ°Flood controlï¼Œç­‰å¾…5ç§’åé‡è¯•...")
                            await asyncio.sleep(5)
                            try:
                                await status_message.edit_text(success_text, parse_mode=None)
                                logger.info("é‡è¯•å‘é€è§†é¢‘ä¸‹è½½å®Œæˆæ¶ˆæ¯æˆåŠŸ")
                            except Exception as retry_error:
                                logger.error(f"é‡è¯•å‘é€è§†é¢‘ä¸‹è½½å®Œæˆæ¶ˆæ¯å¤±è´¥: {retry_error}")
                        else:
                            logger.error(f"å‘é€è§†é¢‘ä¸‹è½½å®Œæˆæ¶ˆæ¯å¤±è´¥: {e}")
                    return
                
                # ä½¿ç”¨ç®€å•æ ¼å¼æ˜¾ç¤ºå®Œæˆä¿¡æ¯ï¼ˆåªæ˜¾ç¤ºä¸€æ¬¡ï¼‰
                # æ³¨æ„ï¼šå°çº¢ä¹¦å›¾ç‰‡ä¸‹è½½å·²åœ¨ä¸Šé¢çš„åˆ†æ”¯ä¸­å¤„ç†å¹¶è¿”å›ï¼Œä¸ä¼šæ‰§è¡Œåˆ°è¿™é‡Œ
                try:
                    # è·å–è¿›åº¦ä¿¡æ¯ç”¨äºæ˜¾ç¤º
                    display_filename = _clean_filename_for_display_local(result.get('filename', progress_data.get('filename', 'video.mp4') if progress_data and isinstance(progress_data, dict) else 'video.mp4'))
                    resolution = result.get('resolution', 'æœªçŸ¥')
                    platform = result.get('platform', 'æœªçŸ¥')
                    size_mb = result.get('size_mb', 0)
                    
                    # æ·»åŠ è°ƒè¯•æ—¥å¿—
                    logger.info(f"ğŸ” [_process_download_async] è¿›å…¥é€šç”¨å¤„ç†é€»è¾‘ - content_type: {result.get('content_type')}, resolution: {resolution}, platform: {platform}")

                    # è·å–åˆ†è¾¨ç‡è´¨é‡æ ‡è¯†ï¼ˆé¿å…é‡å¤æ·»åŠ ï¼‰
                    quality_suffix = self._get_resolution_quality(resolution)
                    # å¦‚æœresolutionå·²ç»åŒ…å«è´¨é‡æ ‡è¯†ï¼Œåˆ™ä¸æ·»åŠ quality_suffix
                    if quality_suffix and quality_suffix.strip() in resolution:
                        quality_suffix = ""
                    
                    # æ„å»ºæœ€ç»ˆçš„åˆ†è¾¨ç‡æ˜¾ç¤ºï¼ˆé¿å…é‡å¤ï¼‰
                    final_resolution = resolution + quality_suffix

                    # è·å–ä¸‹è½½è·¯å¾„
                    download_path = result.get('download_path', 'æœªçŸ¥è·¯å¾„')

                    # æ£€æŸ¥æ˜¯å¦ä¸ºç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½
                    if platform.lower() == 'netease':
                        # ç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½å®Œæˆ
                        if result.get('playlist_name'):
                            # æ­Œå•ä¸‹è½½ - ä½¿ç”¨æ™®é€šæ–‡æœ¬æ ¼å¼
                            title = "ğŸµ ç½‘æ˜“äº‘éŸ³ä¹æ­Œå•ä¸‹è½½å®Œæˆ"
                            
                            playlist_name = result.get('playlist_name', 'æœªçŸ¥æ­Œå•')
                            creator = result.get('creator', 'æœªçŸ¥åˆ›å»ºè€…')
                            total_songs = result.get('total_songs', 0)
                            downloaded_songs = result.get('downloaded_songs', 0)
                            failed_songs = result.get('failed_songs', 0)
                            total_size = result.get('total_size_mb', 0)
                            download_path = result.get('download_path', 'æœªçŸ¥è·¯å¾„')
                            quality = result.get('quality', 'æœªçŸ¥')
                            
                            # è·å–éŸ³è´¨è¯¦ç»†ä¿¡æ¯
                            quality_info = self._get_netease_quality_info(quality)
                            
                            success_text = (
                                f"{title}\n\n"
                                f"ğŸ“‹ æ­Œå•åç§°: {playlist_name}\n"
                                f"ğŸµ æ­Œæ›²æ•°é‡: {total_songs} é¦–\n"
                                f"âœ… æˆåŠŸä¸‹è½½: {downloaded_songs} é¦–\n"
                                f"âŒ å¤±è´¥æ•°é‡: {failed_songs} é¦–\n"
                                f"ğŸ’¾ æ€»å¤§å°: {total_size:.1f} MB\n"
                                f"ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}"
                            )
                            
                            # å¦‚æœæœ‰å¤±è´¥çš„æ­Œæ›²ï¼Œæ·»åŠ å¤±è´¥è¯¦æƒ…
                            failed_details = result.get('failed_details', [])
                            if failed_details:
                                success_text += "\n\nâŒ ä¸‹è½½å¤±è´¥çš„æ­Œæ›²:"
                                for i, failed in enumerate(failed_details[:5], 1):  # åªæ˜¾ç¤ºå‰5ä¸ªå¤±è´¥çš„
                                    song_name = failed.get('song', {}).get('name', 'æœªçŸ¥æ­Œæ›²')
                                    error = failed.get('error', 'æœªçŸ¥é”™è¯¯')
                                    success_text += f"\n{i}. {song_name}: {error}"
                                if len(failed_details) > 5:
                                    success_text += f"\n... è¿˜æœ‰ {len(failed_details) - 5} é¦–æ­Œæ›²ä¸‹è½½å¤±è´¥"
                            
                        elif result.get('album_name'):
                            # ä¸“è¾‘ä¸‹è½½ - ä½¿ç”¨æ–°çš„æ ¼å¼
                            title = "ğŸµ ç½‘æ˜“äº‘éŸ³ä¹ä¸“è¾‘ä¸‹è½½å®Œæˆ"
                            
                            album_name = result.get('album_name', 'æœªçŸ¥ä¸“è¾‘')
                            total_songs = result.get('total_songs', 0)
                            downloaded_songs = result.get('downloaded_songs', 0)
                            total_size = result.get('total_size_mb', 0)
                            download_path = result.get('download_path', 'æœªçŸ¥è·¯å¾„')
                            quality = result.get('quality', 'æœªçŸ¥')

                            # è·å–éŸ³è´¨è¯¦ç»†ä¿¡æ¯ï¼ˆæ–‡ä»¶æ ¼å¼å’Œç ç‡ï¼‰
                            quality_info = self._get_netease_quality_info(quality)
                            
                            # è·å–æ­Œæ›²åˆ—è¡¨ç”¨äºæå–è‰ºæœ¯å®¶å’Œæ–‡ä»¶æ ¼å¼
                            songs = result.get('songs', [])
                            logger.info(f"ğŸ” è·å–åˆ°çš„songsåˆ—è¡¨é•¿åº¦: {len(songs)}")
                            if songs:
                                logger.info(f"ğŸ” ç¬¬ä¸€é¦–æ­Œæ›²ä¿¡æ¯: {songs[0]}")
                            
                            # å°è¯•ä»æ­Œæ›²åˆ—è¡¨æˆ–ä¸‹è½½è·¯å¾„æå–è‰ºæœ¯å®¶ä¿¡æ¯
                            artist_name = self._extract_artist_from_path(download_path, album_name, songs)
                            
                            # æ£€æµ‹æ–‡ä»¶æ ¼å¼ï¼ˆä»æ­Œæ›²åˆ—è¡¨ä¸­æå–ï¼‰
                            file_formats = set()
                            for song in songs:
                                song_name = song.get('song_name', '')
                                if song_name.endswith('.mp3'):
                                    file_formats.add('MP3')
                                elif song_name.endswith('.flac'):
                                    file_formats.add('FLAC')
                                elif song_name.endswith('.ape'):
                                    file_formats.add('APE')
                                elif song_name.endswith('.wav'):
                                    file_formats.add('WAV')
                                elif song_name.endswith('.m4a'):
                                    file_formats.add('M4A')
                            
                            # å¦‚æœæ²¡æœ‰æ£€æµ‹åˆ°æ ¼å¼ï¼Œä½¿ç”¨é»˜è®¤æ ¼å¼
                            if not file_formats:
                                # ä¸è¦å¼ºåˆ¶ä½¿ç”¨éŸ³è´¨è®¾ç½®æ¨æ–­çš„æ ¼å¼ï¼Œè€Œæ˜¯ä½¿ç”¨å®é™…æ£€æµ‹åˆ°çš„æ ¼å¼
                                # å¦‚æœç¡®å®æ²¡æœ‰æ£€æµ‹åˆ°ä»»ä½•æ ¼å¼ï¼Œæ‰ä½¿ç”¨é»˜è®¤MP3
                                file_formats.add('MP3')
                            
                            format_display = 'ã€'.join(sorted(file_formats))
                            
                            success_text = (
                                f"{title}\n\n"
                                f"ğŸ“€ ä¸“è¾‘åç§°: {album_name}\n\n"
                                f"ğŸ¤ è‰ºæœ¯å®¶ï¼š{artist_name}\n"
                                f"ğŸ¼ æ›²ç›®æ•°é‡: {total_songs} é¦–\n"
                                f"ğŸšï¸ éŸ³é¢‘è´¨é‡: {quality_info['name']}\n"
                                f"ğŸ’¾ æ€»å¤§å°: {total_size:.2f} MB\n"
                                f"ğŸ“Š ç ç‡: {quality_info['bitrate']}\n"
                                f"ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}"
                            )

                            # æ˜¾ç¤ºæ­Œæ›²åˆ—è¡¨ï¼ˆç›´æ¥ä»ç›®å½•è·å–å®é™…æ–‡ä»¶ä¿¡æ¯ï¼‰
                            try:
                                import os
                                album_dir = download_path
                                if os.path.exists(album_dir):
                                    files = []
                                    for file in os.listdir(album_dir):
                                        if file.lower().endswith(('.mp3', '.flac', '.ape', '.wav', '.m4a')):
                                            file_path = os.path.join(album_dir, file)
                                            file_size = os.path.getsize(file_path)
                                            files.append({'name': file, 'size': file_size})
                                    
                                    # æŒ‰æ–‡ä»¶åæ’åº
                                    files.sort(key=lambda x: x['name'])
                                    
                                    if files:
                                        success_text += "\n\nğŸµ æ­Œæ›²åˆ—è¡¨:\n\n"
                                        for i, file_info in enumerate(files, 1):
                                            filename = file_info['name']
                                            file_size_mb = file_info['size'] / (1024 * 1024)
                                            
                                            # æ£€æŸ¥æ–‡ä»¶åæ˜¯å¦å·²ç»åŒ…å«åºå·
                                            import re
                                            has_numbering = re.match(r'^\s*\d+\.\s*', filename)
                                            
                                            if has_numbering:
                                                # æ–‡ä»¶åå·²æœ‰åºå·ï¼Œç›´æ¥æ˜¾ç¤º
                                                success_text += f"{filename} ({file_size_mb:.1f}MB)\n"
                                            else:
                                                # æ–‡ä»¶åæ²¡æœ‰åºå·ï¼Œæ·»åŠ åºå·
                                                success_text += f"{i:02d}. {filename} ({file_size_mb:.1f}MB)\n"
                                            
                                            logger.info(f"ğŸ” å®é™…æ–‡ä»¶: {filename} - {file_size_mb:.1f}MB")
                                    else:
                                        success_text += "\n\nğŸµ æ­Œæ›²åˆ—è¡¨: æœªæ‰¾åˆ°éŸ³é¢‘æ–‡ä»¶\n"
                                else:
                                    # å¦‚æœç›®å½•ä¸å­˜åœ¨ï¼Œä½¿ç”¨åŸæ¥çš„songsåˆ—è¡¨
                                    if songs:
                                        success_text += "\n\nğŸµ æ­Œæ›²åˆ—è¡¨:\n\n"
                                        for i, song in enumerate(songs, 1):
                                            song_name = song.get('song_name', 'æœªçŸ¥æ­Œæ›²')
                                            song_size = song.get('size_mb', 0)
                                            
                                            # ç¡®ä¿æ–‡ä»¶ååŒ…å«æ‰©å±•åï¼ˆä»…ç”¨äºæ˜¾ç¤ºï¼‰
                                            if not any(song_name.lower().endswith(ext) for ext in ['.mp3', '.flac', '.ape', '.wav', '.m4a']):
                                                actual_format = song.get('file_format', '').lower()
                                                if actual_format:
                                                    song_name += f'.{actual_format}'
                                                else:
                                                    song_name += '.mp3'
                                            
                                            success_text += f"{i}. {song_name} ({song_size:.1f}MB)\n"
                            except Exception as e:
                                logger.error(f"âŒ è·å–æ–‡ä»¶åˆ—è¡¨å¤±è´¥: {e}")
                                # ä½¿ç”¨åŸæ¥çš„songsåˆ—è¡¨ä½œä¸ºåå¤‡
                                if songs:
                                    success_text += "\n\nğŸµ æ­Œæ›²åˆ—è¡¨:\n\n"
                                    for i, song in enumerate(songs, 1):
                                        song_name = song.get('song_name', 'æœªçŸ¥æ­Œæ›²')
                                        song_size = song.get('size_mb', 0)
                                        success_text += f"{i}. {song_name} ({song_size:.1f}MB)\n"
                        else:
                            # å•æ›²ä¸‹è½½
                            title = "ğŸµ ç½‘æ˜“äº‘éŸ³ä¹å•æ›²ä¸‹è½½å®Œæˆ"

                            song_title = result.get('song_title', 'æœªçŸ¥æ­Œæ›²')
                            song_artist = result.get('song_artist', 'æœªçŸ¥æ­Œæ‰‹')
                            filename = result.get('filename', 'éŸ³ä¹æ–‡ä»¶')
                            size_mb = result.get('size_mb', 0)
                            download_path = result.get('download_path', 'æœªçŸ¥è·¯å¾„')
                            quality_name = result.get('quality_name', 'æœªçŸ¥')
                            bitrate = result.get('bitrate', 'æœªçŸ¥')
                            duration = result.get('duration', 'æœªçŸ¥')
                            file_format = result.get('file_format', 'MP3')

                            # æ„å»ºéŸ³ä¹åç§°
                            music_name = f"{song_title} - {song_artist}" if song_title and song_artist else filename
                            
                            success_text = (
                                f"{title}\n\n"
                                f"ğŸµ éŸ³ä¹: {music_name}\n"
                                f"ğŸ’¾ å¤§å°: {size_mb:.2f}MB\n"
                                f"ğŸ–¼ï¸ ç ç‡: {bitrate}\n"
                                f"ğŸšï¸ éŸ³è´¨: {quality_name}\n"
                                f"â±ï¸ æ—¶é•¿: {duration}\n"
                                f"ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}"
                            )
                        
                        # å‘é€ç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½å®Œæˆæ¶ˆæ¯
                        try:
                            await status_message.edit_text(success_text, parse_mode=None)
                            logger.info("ç½‘æ˜“äº‘éŸ³ä¹ä¸‹è½½å®Œæˆæ¶ˆæ¯å‘é€æˆåŠŸ")
                        except Exception as e:
                            logger.error(f"å‘é€ç½‘æ˜“äº‘éŸ³ä¹å®Œæˆæ¶ˆæ¯å¤±è´¥: {e}")
                        return

                    # æ£€æŸ¥æ˜¯å¦ä¸ºQQéŸ³ä¹ä¸‹è½½
                    elif platform.lower() == 'qqmusic' or result.get('platform') == 'QQMusic':
                        # QQéŸ³ä¹ä¸‹è½½å®Œæˆ
                        if result.get('album_name'):
                            # ä¸“è¾‘ä¸‹è½½ - å‚è€ƒç½‘æ˜“äº‘éŸ³ä¹æ ¼å¼
                            title = "ğŸµ QQéŸ³ä¹ä¸“è¾‘ä¸‹è½½å®Œæˆ"
                            
                            album_name = result.get('album_name', 'æœªçŸ¥ä¸“è¾‘')
                            singer_name = result.get('singer_name', 'æœªçŸ¥æ­Œæ‰‹')
                            total_songs = result.get('total_songs', 0)
                            downloaded_songs = result.get('downloaded_songs', 0)
                            failed_songs = result.get('failed_songs', 0)
                            download_path = result.get('download_path', 'æœªçŸ¥è·¯å¾„')
                            
                            # è·å–éŸ³è´¨ä¿¡æ¯ï¼ˆä»ä¸‹è½½çš„æ­Œæ›²åˆ—è¡¨ä¸­æå–ï¼‰
                            downloaded_list = result.get('downloaded_list', [])
                            quality_info = {'name': 'æœªçŸ¥', 'bitrate': 'æœªçŸ¥'}
                            file_formats = set()
                            
                            if downloaded_list:
                                # ä»ç¬¬ä¸€é¦–æ­Œæ›²è·å–éŸ³è´¨ä¿¡æ¯
                                first_song = downloaded_list[0]
                                quality = first_song.get('quality', 'æœªçŸ¥éŸ³è´¨')
                                format_type = first_song.get('format', 'æœªçŸ¥æ ¼å¼')
                                
                                # è®¾ç½®éŸ³è´¨ä¿¡æ¯
                                if 'flac' in quality.lower() or 'æ— æŸ' in quality:
                                    quality_info = {'name': 'FLACæ— æŸ', 'bitrate': '16bit/44khz/1058kbps'}
                                    file_formats.add('FLAC')
                                elif 'ape' in quality.lower():
                                    quality_info = {'name': 'APEæ— æŸ', 'bitrate': '16bit/44khz/1058kbps'}
                                    file_formats.add('APE')
                                elif '320' in quality:
                                    quality_info = {'name': 'MP3é«˜å“è´¨', 'bitrate': '320kbps'}
                                    file_formats.add('MP3')
                                elif '128' in quality:
                                    quality_info = {'name': 'MP3æ ‡å‡†', 'bitrate': '128kbps'}
                                    file_formats.add('MP3')
                                else:
                                    quality_info = {'name': quality, 'bitrate': 'æœªçŸ¥'}
                                    file_formats.add(format_type.upper())
                            
                            # è®¡ç®—æ€»å¤§å°
                            total_size_mb = 0
                            try:
                                import os
                                if os.path.exists(download_path):
                                    for file in os.listdir(download_path):
                                        file_path = os.path.join(download_path, file)
                                        if os.path.isfile(file_path):
                                            total_size_mb += os.path.getsize(file_path) / (1024 * 1024)
                            except Exception as e:
                                logger.warning(f"è®¡ç®—æ€»å¤§å°å¤±è´¥: {e}")
                            
                            success_text = (
                                f"{title}\n\n"
                                f"ğŸ“€ ä¸“è¾‘åç§°: {album_name}\n\n"
                                f"ğŸ¤ è‰ºæœ¯å®¶ï¼š{singer_name}\n"
                                f"ğŸ¼ æ›²ç›®æ•°é‡: {total_songs} é¦–\n"
                                f"ğŸšï¸ éŸ³é¢‘è´¨é‡: {quality_info['name']}\n"
                                f"ğŸ’¾ æ€»å¤§å°: {total_size_mb:.2f} MB\n"
                                f"ğŸ“Š ç ç‡: {quality_info['bitrate']}\n"
                                f"ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}"
                            )
                            
                            # æ˜¾ç¤ºæ­Œæ›²åˆ—è¡¨ï¼ˆä»å®é™…æ–‡ä»¶è·å–ï¼‰
                            try:
                                import os
                                album_dir = download_path
                                if os.path.exists(album_dir):
                                    files = []
                                    for file in os.listdir(album_dir):
                                        if file.lower().endswith(('.mp3', '.flac', '.ape', '.wav', '.m4a')):
                                            file_path = os.path.join(album_dir, file)
                                            file_size = os.path.getsize(file_path)
                                            files.append({'name': file, 'size': file_size})
                                    
                                    # æŒ‰æ–‡ä»¶åæ’åº
                                    files.sort(key=lambda x: x['name'])
                                    
                                    if files:
                                        success_text += "\n\nğŸµ æ­Œæ›²åˆ—è¡¨:\n\n"
                                        for i, file_info in enumerate(files, 1):
                                            filename = file_info['name']
                                            file_size_mb = file_info['size'] / (1024 * 1024)
                                            
                                            # æ£€æŸ¥æ–‡ä»¶åæ˜¯å¦å·²ç»åŒ…å«åºå·
                                            import re
                                            has_numbering = re.match(r'^\s*\d+\.\s*', filename)
                                            
                                            if has_numbering:
                                                # æ–‡ä»¶åå·²æœ‰åºå·ï¼Œç›´æ¥æ˜¾ç¤º
                                                success_text += f"{filename} ({file_size_mb:.1f}MB)\n"
                                            else:
                                                # æ–‡ä»¶åæ²¡æœ‰åºå·ï¼Œæ·»åŠ åºå·
                                                success_text += f"{i:02d}. {filename} ({file_size_mb:.1f}MB)\n"
                                    else:
                                        success_text += "\n\nğŸµ æ­Œæ›²åˆ—è¡¨: æœªæ‰¾åˆ°éŸ³é¢‘æ–‡ä»¶\n"
                                else:
                                    success_text += "\n\nğŸµ æ­Œæ›²åˆ—è¡¨: ä¸‹è½½ç›®å½•ä¸å­˜åœ¨\n"
                            except Exception as e:
                                logger.warning(f"è·å–æ­Œæ›²åˆ—è¡¨å¤±è´¥: {e}")
                                success_text += "\n\nğŸµ æ­Œæ›²åˆ—è¡¨: è·å–å¤±è´¥\n"
                            
                        elif result.get('playlist_name'):
                            # æ­Œå•ä¸‹è½½ - å‚è€ƒç½‘æ˜“äº‘éŸ³ä¹æ ¼å¼
                            title = "ğŸµ QQéŸ³ä¹æ­Œå•ä¸‹è½½å®Œæˆ"
                            
                            playlist_name = result.get('playlist_name', 'æœªçŸ¥æ­Œå•')
                            total_songs = result.get('total_songs', 0)
                            downloaded_songs = result.get('downloaded_songs', 0)
                            failed_songs = result.get('failed_songs', 0)
                            total_size = result.get('total_size_mb', 0)
                            download_path = result.get('download_path', 'æœªçŸ¥è·¯å¾„')
                            quality = result.get('quality', 'æœªçŸ¥')
                            
                            # è·å–éŸ³è´¨è¯¦ç»†ä¿¡æ¯
                            quality_info = self._get_qqmusic_quality_info(quality)
                            
                            success_text = (
                                f"{title}\n\n"
                                f"ğŸ“‹ æ­Œå•åç§°: {playlist_name}\n"
                                f"ğŸµ æ­Œæ›²æ•°é‡: {total_songs} é¦–\n"
                                f"âœ… æˆåŠŸä¸‹è½½: {downloaded_songs} é¦–\n"
                                f"âŒ å¤±è´¥æ•°é‡: {failed_songs} é¦–\n"
                                f"ğŸ’¾ æ€»å¤§å°: {total_size:.1f} MB\n"
                                f"ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}"
                            )
                            
                            # å¦‚æœæœ‰å¤±è´¥çš„æ­Œæ›²ï¼Œæ·»åŠ å¤±è´¥è¯¦æƒ…
                            failed_list = result.get('failed_list', [])
                            if failed_list:
                                success_text += "\n\nâŒ ä¸‹è½½å¤±è´¥çš„æ­Œæ›²:"
                                for failed in failed_list[:5]:  # åªæ˜¾ç¤ºå‰5ä¸ªå¤±è´¥çš„
                                    song_name = failed.get('song_name', 'æœªçŸ¥æ­Œæ›²')
                                    singer_name = failed.get('singer_name', 'æœªçŸ¥æ­Œæ‰‹')
                                    error = failed.get('error', 'æœªçŸ¥é”™è¯¯')
                                    success_text += f"\nâ€¢ {singer_name} - {song_name}: {error}"
                                
                                if len(failed_list) > 5:
                                    success_text += f"\nâ€¢ ... è¿˜æœ‰ {len(failed_list) - 5} é¦–æ­Œæ›²ä¸‹è½½å¤±è´¥"
                        
                        else:
                            # å•é¦–æ­Œæ›²ä¸‹è½½
                            title = "ğŸµ QQéŸ³ä¹ä¸‹è½½å®Œæˆ"
                            
                            song_title = result.get('song_title', 'æœªçŸ¥æ­Œæ›²')
                            song_artist = result.get('song_artist', 'æœªçŸ¥æ­Œæ‰‹')
                            album = result.get('album', 'æœªçŸ¥ä¸“è¾‘')
                            quality = result.get('quality', 'æœªçŸ¥éŸ³è´¨')
                            format_type = result.get('format', 'æœªçŸ¥æ ¼å¼')
                            file_path = result.get('file_path', 'æœªçŸ¥è·¯å¾„')
                            
                            # è®¡ç®—æ–‡ä»¶å¤§å°ï¼ˆMBï¼‰
                            size_text = "æœªçŸ¥"
                            try:
                                import os as _os
                                if file_path and _os.path.exists(file_path):
                                    _size_bytes = _os.path.getsize(file_path)
                                    size_text = f"{_size_bytes / (1024 * 1024):.2f} MB"
                            except Exception:
                                pass
                            
                            # è®¡ç®—æ—¶é•¿ï¼ˆä¼˜å…ˆä½¿ç”¨ç»“æœä¸­çš„æ—¶é•¿ï¼›å¦åˆ™å°è¯•ç”¨ mutagen è¯»å–ï¼‰
                            duration_seconds = result.get('duration') or 0
                            if not duration_seconds or duration_seconds <= 0:
                                try:
                                    from mutagen import File as _MutagenFile
                                    _audio = _MutagenFile(file_path) if file_path else None
                                    if _audio and getattr(_audio, 'info', None) and getattr(_audio.info, 'length', None):
                                        duration_seconds = int(_audio.info.length)
                                except Exception:
                                    pass
                            if duration_seconds and duration_seconds > 0:
                                _mins, _secs = divmod(int(duration_seconds), 60)
                                duration_text = f"{_mins:02d}:{_secs:02d}"
                            else:
                                duration_text = "æœªçŸ¥"
                            
                            success_text = (
                                f"{title}\n\n"
                                f"ğŸµ æ­Œæ›²: {song_title}\n"
                                f"ğŸ¤ è‰ºæœ¯å®¶: {song_artist}\n"
                                f"ğŸ“€ ä¸“è¾‘: {album}\n"
                                f"ğŸšï¸ éŸ³è´¨: {quality}\n"
                                f"ğŸ“ æ ¼å¼: {format_type}\n"
                                f"ğŸ’¾ å¤§å°: {size_text}\n"
                                f"â±ï¸ æ—¶é•¿: {duration_text}\n"
                                f"ğŸ“‚ ä¿å­˜ä½ç½®: {file_path}"
                            )
                        
                        try:
                            await status_message.edit_text(success_text, parse_mode=None)
                            logger.info("ğŸ“± å‘é€QQéŸ³ä¹ä¸‹è½½å®Œæˆæ¶ˆæ¯")
                        except Exception as e:
                            logger.error(f"å‘é€QQéŸ³ä¹å®Œæˆæ¶ˆæ¯å¤±è´¥: {e}")
                        return

                    # æ£€æŸ¥æ˜¯å¦ä¸º Apple Music ä¸‹è½½
                    elif platform.lower() == 'applemusic' or result.get('platform') == 'AppleMusic':
                        # Apple Music ä¸‹è½½å®Œæˆ
                        # æ·»åŠ è°ƒè¯•æ—¥å¿—
                        logger.info(f"ğŸ” Apple Musicä¸‹è½½ç»“æœ: {result}")
                        logger.info(f"ğŸ” music_type: {result.get('music_type')}")
                        logger.info(f"ğŸ” platform: {platform}")
                        logger.info(f"ğŸ” result platform: {result.get('platform')}")
                        
                        # ğŸ”§ ç´§æ€¥è°ƒè¯•ï¼šæ£€æŸ¥resultä¸­çš„total_size_mb
                        logger.info(f"ğŸš¨ ç´§æ€¥è°ƒè¯•ï¼šæ£€æŸ¥resultä¸­çš„total_size_mb")
                        logger.info(f"  - resultåŒ…å«total_size_mb: {'total_size_mb' in result}")
                        logger.info(f"  - result.get('total_size_mb'): {result.get('total_size_mb')}")
                        logger.info(f"  - result.get('total_size'): {result.get('total_size')}")
                        logger.info(f"  - resultçš„æ‰€æœ‰å­—æ®µ: {list(result.keys())}")
                        
                        # ä¿®å¤ï¼šç›´æ¥ä»¥URLæ£€æµ‹ä¸ºå‡†ï¼ŒURLæ£€æµ‹æœ€å‡†ç¡®
                        url = result.get('url', '')
                        is_album = 'album' in url
                        is_song = 'song' in url
                        
                        logger.info(f"ğŸ” URLæ£€æµ‹ç»“æœ: album={is_album}, song={is_song}")
                        logger.info(f"ğŸ” åŸå§‹URL: {url}")
                        
                        if is_album:
                            # ä¸“è¾‘ä¸‹è½½
                            title = "ğŸµ Apple Musicä¸“è¾‘ä¸‹è½½å®Œæˆ"
                            escaped_title = (title)

                            # ä¿®å¤ï¼šé‡æ–°ç»Ÿè®¡ä¸“è¾‘ç›®å½•ä¸­çš„æ–‡ä»¶
                            download_path = result.get('download_path', '/downloads/AppleMusic')
                            amd_downloads_dir = os.path.join(download_path, "AM-DL downloads")
                            
                            # è·å–ä¸“è¾‘ä¿¡æ¯ - ä»curlè„šæœ¬è·å–
                            music_info = result.get('music_info', {})
                            album_name = music_info.get('album', 'æœªçŸ¥ä¸“è¾‘')
                            artist = music_info.get('artist', 'æœªçŸ¥è‰ºæœ¯å®¶')
                            
                            logger.info(f"ğŸ” curlè„šæœ¬è·å–çš„éŸ³ä¹ä¿¡æ¯: è‰ºæœ¯å®¶='{artist}', ä¸“è¾‘='{album_name}'")
                            
                            # å¦‚æœcurlè„šæœ¬æ— æ³•è·å–ä¸“è¾‘ä¿¡æ¯ï¼Œè®°å½•è­¦å‘Š
                            if album_name == 'æœªçŸ¥ä¸“è¾‘' or artist == 'æœªçŸ¥è‰ºæœ¯å®¶':
                                logger.warning("âš ï¸ curlè„šæœ¬æ— æ³•è·å–ä¸“è¾‘ä¿¡æ¯ï¼Œè¿™ä¸åº”è¯¥å‘ç”Ÿ")
                                logger.warning("âš ï¸ è¯·æ£€æŸ¥curlè„šæœ¬çš„HTMLè§£ææ˜¯å¦æ­£ç¡®")
                            
                            # åªéå†ä¸“è¾‘ç›®å½•ï¼Œè€Œä¸æ˜¯æ•´ä¸ªä¸‹è½½ç›®å½•
                            files_info = []
                            total_size = 0
                            
                            if os.path.exists(amd_downloads_dir):
                                # æŸ¥æ‰¾è‰ºæœ¯å®¶ç›®å½•
                                artist_dir = None
                                all_items = os.listdir(amd_downloads_dir)
                                for item in all_items:
                                    item_path = os.path.join(amd_downloads_dir, item)
                                    if os.path.isdir(item_path) and item == artist:
                                        artist_dir = item_path
                                        break
                                
                                if artist_dir:
                                    # æŸ¥æ‰¾ä¸“è¾‘ç›®å½• - æ”¹ä¸ºåŒ…å«åŒ¹é…ï¼Œæ›´çµæ´»
                                    album_dir = None
                                    artist_items = os.listdir(artist_dir)
                                    for item in artist_items:
                                        item_path = os.path.join(artist_dir, item)
                                        if os.path.isdir(item_path) and album_name in item:
                                            album_dir = item_path
                                            logger.info(f"âœ… æ‰¾åˆ°ä¸“è¾‘ç›®å½•ï¼ˆåŒ…å«åŒ¹é…ï¼‰: '{item}' åŒ…å« '{album_name}'")
                                            break
                                    
                                    if album_dir:
                                        # åªéå†ä¸“è¾‘ç›®å½•ä¸­çš„æ–‡ä»¶
                                        album_files = os.listdir(album_dir)
                                        logger.info(f"ğŸ” éå†ä¸“è¾‘ç›®å½•: {album_dir}ï¼Œæ‰¾åˆ° {len(album_files)} ä¸ªæ–‡ä»¶")
                                        
                                        for file in album_files:
                                            if file.lower().endswith(('.m4a', '.flac', '.aac', '.mp3')):
                                                file_path = os.path.join(album_dir, file)
                                                file_size = os.path.getsize(file_path)
                                                total_size += file_size
                                                
                                                files_info.append({
                                                    'name': file,
                                                    'path': file,
                                                    'size': file_size
                                                })
                                        
                                        logger.info(f"âœ… ä¸“è¾‘ç›®å½•ä¸­æ‰¾åˆ° {len(files_info)} ä¸ªéŸ³é¢‘æ–‡ä»¶")
                                    else:
                                        logger.warning(f"âš ï¸ æœªæ‰¾åˆ°åŒ…å«ä¸“è¾‘åç§°çš„ç›®å½•: '{album_name}'")
                                        logger.info(f"ğŸ” è‰ºæœ¯å®¶ç›®å½• '{artist}' ä¸­çš„å­ç›®å½•: {artist_items}")
                                        # å°è¯•æ¨¡ç³ŠåŒ¹é…
                                        for item in artist_items:
                                            item_path = os.path.join(artist_dir, item)
                                            if os.path.isdir(item_path):
                                                logger.info(f"ğŸ” æ£€æŸ¥ç›®å½•: '{item}' vs '{album_name}'")
                                                # å¦‚æœä¸“è¾‘åç§°åœ¨ç›®å½•åä¸­ï¼Œæˆ–è€…ç›®å½•ååœ¨ä¸“è¾‘åç§°ä¸­
                                                if album_name in item or item in album_name:
                                                    album_dir = item_path
                                                    logger.info(f"âœ… æ¨¡ç³ŠåŒ¹é…æˆåŠŸ: '{item}' ä¸ '{album_name}' ç›¸å…³")
                                                    break
                                        
                                        if album_dir:
                                            # æ¨¡ç³ŠåŒ¹é…æˆåŠŸï¼Œç»§ç»­å¤„ç†
                                            album_files = os.listdir(album_dir)
                                            logger.info(f"ğŸ” éå†æ¨¡ç³ŠåŒ¹é…çš„ä¸“è¾‘ç›®å½•: {album_dir}")
                                            
                                            for file in album_files:
                                                if file.lower().endswith(('.m4a', '.flac', '.aac', '.mp3')):
                                                    file_path = os.path.join(album_dir, file)
                                                    file_size = os.path.getsize(file_path)
                                                    total_size += file_size
                                                    
                                                    files_info.append({
                                                        'name': file,
                                                        'path': file,
                                                        'size': file_size
                                                    })
                                            
                                            logger.info(f"âœ… æ¨¡ç³ŠåŒ¹é…ç›®å½•ä¸­æ‰¾åˆ° {len(files_info)} ä¸ªéŸ³é¢‘æ–‡ä»¶")
                                        else:
                                            logger.error(f"âŒ æ— æ³•æ‰¾åˆ°ä¸“è¾‘ç›®å½•ï¼Œè¯·æ£€æŸ¥curlè„šæœ¬çš„HTMLè§£ææ˜¯å¦æ­£ç¡®")
                                            return {
                                                'success': False,
                                                'error': f'æ— æ³•æ‰¾åˆ°ä¸“è¾‘ç›®å½•: {album_name}'
                                            }
                                else:
                                    logger.warning(f"âš ï¸ æœªæ‰¾åˆ°è‰ºæœ¯å®¶ç›®å½•: '{artist}'")
                                    logger.error(f"âŒ æ— æ³•æ‰¾åˆ°è‰ºæœ¯å®¶ç›®å½•ï¼Œè¯·æ£€æŸ¥curlè„šæœ¬çš„HTMLè§£ææ˜¯å¦æ­£ç¡®")
                                    return {
                                        'success': False,
                                        'error': f'æ— æ³•æ‰¾åˆ°è‰ºæœ¯å®¶ç›®å½•: {artist}'
                                    }
                            
                            # è®¡ç®—æ€»å¤§å°ï¼ˆMBï¼‰
                            # ä¿®å¤ï¼šä¼˜å…ˆä½¿ç”¨resultä¸­çš„total_size_mbï¼Œé¿å…é‡å¤ç»Ÿè®¡
                            if 'result' in locals() and result and result.get('total_size_mb'):
                                total_size_mb = result.get('total_size_mb')
                                logger.info(f"ğŸ”§ ä¸“è¾‘ä¸‹è½½ï¼šä½¿ç”¨resultä¸­çš„total_size_mb: {total_size_mb:.2f} MB")
                            elif total_size > 0:
                                if total_size > 1000:  # å¦‚æœå¤§äº1000ï¼Œå¯èƒ½æ˜¯bytesï¼Œéœ€è¦è½¬æ¢
                                    total_size_mb = total_size / (1024 * 1024)
                                    logger.info(f"ğŸ”§ ä¸“è¾‘ä¸‹è½½ï¼šæ£€æµ‹åˆ°total_sizeä¸ºbytesï¼Œè½¬æ¢ä¸ºMB: {total_size} bytes -> {total_size_mb:.2f} MB")
                                else:  # å¦‚æœå°äº1000ï¼Œå·²ç»æ˜¯MBå•ä½
                                    total_size_mb = total_size
                                    logger.info(f"ğŸ”§ ä¸“è¾‘ä¸‹è½½ï¼štotal_sizeå·²ç»æ˜¯MBå•ä½: {total_size_mb:.2f} MB")
                            else:
                                total_size_mb = 0
                            files_count = len(files_info)
                            
                            # è®¡ç®—æ›²ç›®æ•°é‡ï¼ˆæ’é™¤å°é¢å’Œæ­Œè¯æ–‡ä»¶ï¼‰
                            track_count = files_count
                            
                            # ç¼–ç åˆ¤æ–­ - ä½¿ç”¨ffprobeå‡†ç¡®æ£€æµ‹éŸ³é¢‘ç¼–ç æ ¼å¼
                            def detect_audio_codec(file_path):
                                """ä½¿ç”¨ffprobeæ£€æµ‹éŸ³é¢‘æ–‡ä»¶çš„ç¼–ç æ ¼å¼"""
                                try:
                                    import subprocess
                                    import json
                                    
                                    # ä½¿ç”¨ffprobeè·å–éŸ³é¢‘ä¿¡æ¯
                                    cmd = [
                                        'ffprobe', '-loglevel', 'quiet', '-print_format', 'json',
                                        '-show_streams', '-select_streams', 'a:0', file_path
                                    ]
                                    
                                    result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
                                    if result.returncode == 0:
                                        data = json.loads(result.stdout)
                                        if 'streams' in data and len(data['streams']) > 0:
                                            stream = data['streams'][0]
                                            
                                            # è·å–ç¼–ç æ ¼å¼
                                            codec_name = stream.get('codec_name', '').upper()
                                            codec_long_name = stream.get('codec_long_name', '')
                                            
                                            # è·å–å®é™…ç ç‡
                                            bit_rate = stream.get('bit_rate')
                                            if bit_rate:
                                                bit_rate_kbps = int(int(bit_rate) / 1000)
                                            else:
                                                bit_rate_kbps = None
                                            
                                            # è·å–é‡‡æ ·ç‡
                                            sample_rate = stream.get('sample_rate')
                                            
                                            logger.info(f"ğŸ” ffprobeæ£€æµ‹ç»“æœ: {codec_name} - {codec_long_name} - {bit_rate_kbps}kbps - {sample_rate}Hz")
                                            
                                            return {
                                                'codec': codec_name,
                                                'long_name': codec_long_name,
                                                'bitrate_kbps': bit_rate_kbps,
                                                'sample_rate': sample_rate
                                            }
                                except Exception as e:
                                    logger.warning(f"âš ï¸ ffprobeæ£€æµ‹å¤±è´¥: {e}")
                                
                                return None
                            
                            # æ£€æµ‹éŸ³é¢‘æ–‡ä»¶ç¼–ç 
                            m4a_files = [f for f in files_info if f['name'].lower().endswith('.m4a')]
                            aac_files = [f for f in files_info if f['name'].lower().endswith('.aac')]
                            flac_files = [f for f in files_info if f['name'].lower().endswith('.flac')]
                            mp3_files = [f for f in files_info if f['name'].lower().endswith('.mp3')]
                            
                            # ä¼˜å…ˆæ£€æµ‹M4Aæ–‡ä»¶ï¼ˆApple Musicä¸»è¦æ ¼å¼ï¼Œå¯èƒ½æ˜¯AACæˆ–ALACï¼‰
                            detected_codec = None
                            if m4a_files:
                                # æ£€æµ‹ç¬¬ä¸€ä¸ªM4Aæ–‡ä»¶çš„ç¼–ç 
                                first_m4a = m4a_files[0]
                                m4a_path = os.path.join(album_dir, first_m4a['name'])
                                detected_codec = detect_audio_codec(m4a_path)
                                
                                if detected_codec:
                                    if detected_codec['codec'] in ['ALAC', 'AAC']:
                                        audio_quality = detected_codec['codec']
                                    else:
                                        # å¦‚æœffprobeæ£€æµ‹åˆ°å…¶ä»–ç¼–ç ï¼Œæ ¹æ®æ–‡ä»¶å¤§å°æ¨æ–­
                                        if first_m4a['size'] > 8 * 1024 * 1024:  # å¤§äº8MB
                                            audio_quality = "ALAC"
                                        else:
                                            audio_quality = "AAC"
                                else:
                                    # ffprobeæ£€æµ‹å¤±è´¥ï¼Œä½¿ç”¨æ–‡ä»¶å¤§å°æ¨æ–­
                                    if first_m4a['size'] > 8 * 1024 * 1024:
                                        audio_quality = "ALAC"
                                    else:
                                        audio_quality = "AAC"
                            # å…¶ä»–æ ¼å¼ä½œä¸ºå¤‡é€‰ï¼ˆä¸»è¦æ˜¯å…¼å®¹å…¶ä»–å¹³å°ï¼‰
                            elif aac_files:
                                audio_quality = "AAC"
                            elif mp3_files:
                                audio_quality = "MP3"
                            elif flac_files:
                                audio_quality = "FLAC"
                            else:
                                audio_quality = "æœªçŸ¥"
                            
                            # ç ç‡ä¿¡æ¯ - ä½¿ç”¨ffprobeæ£€æµ‹çš„å®é™…ç ç‡ï¼Œæˆ–ä½¿ç”¨é»˜è®¤å€¼ï¼ˆä¸é‡å¤æ˜¾ç¤ºç¼–ç æ ¼å¼ï¼‰
                            if detected_codec and detected_codec['bitrate_kbps']:
                                # ä½¿ç”¨ffprobeæ£€æµ‹çš„å®é™…ç ç‡
                                bitrate = f"{detected_codec['bitrate_kbps']}kbps"
                            else:
                                # ä½¿ç”¨é»˜è®¤ç ç‡
                                if audio_quality == "ALAC":
                                    bitrate = "2304kbps"  # Apple Music ALACæ ‡å‡†ç ç‡
                                elif audio_quality == "AAC":
                                    bitrate = "256kbps"  # Apple Music AACæ ‡å‡†ç ç‡
                                elif audio_quality == "FLAC":
                                    bitrate = "æ— æŸ"  # FLACæ ¼å¼
                                elif audio_quality == "MP3":
                                    bitrate = "320kbps"  # æ ‡å‡†MP3ç ç‡
                                else:
                                    bitrate = "æœªçŸ¥"
                            
                            # æ–‡ä»¶æ ¼å¼æ˜¾ç¤º
                            formats = set()
                            for f in files_info:
                                if f['name'].lower().endswith('.flac'):
                                    formats.add('FLAC')
                                elif f['name'].lower().endswith('.m4a'):
                                    formats.add('M4A')
                                elif f['name'].lower().endswith('.aac'):
                                    formats.add('AAC')
                                elif f['name'].lower().endswith('.mp3'):
                                    formats.add('MP3')
                            format_display = ", ".join(formats) if formats else "æœªçŸ¥"

                            # ç¡®ä¿total_size_mbæœ‰å€¼ï¼Œå¹¶æ·»åŠ è°ƒè¯•ä¿¡æ¯
                            logger.info(f"ğŸ” ä¸“è¾‘ä¸‹è½½ç»Ÿè®¡: total_size={total_size}, files_count={len(files_info)}")

                            size_str = f"{total_size_mb:.2f}"
                            logger.info(f"ğŸ” æ„å»ºsize_str: {total_size_mb:.2f} -> {size_str}")
                            
                            # æ„å»ºæ­Œæ›²åˆ—è¡¨ - ä»ä¸“è¾‘ç›®å½•ä¸­è·å–å®é™…æ–‡ä»¶ä¿¡æ¯
                            song_list = ""
                            if files_info:
                                song_list = "\nğŸµ **æ­Œæ›²åˆ—è¡¨**:\n\n"
                                for i, file_info in enumerate(files_info, 1):
                                    if file_info['name'].lower().endswith(('.m4a', '.flac', '.aac', '.mp3')):
                                        # ä¿æŒåŸå§‹æ–‡ä»¶åï¼ŒåŒ…å«æ­£ç¡®çš„æ‰©å±•å
                                        filename = file_info['name']
                                        size_mb = file_info['size'] / (1024 * 1024)
                                        size_mb_str = f"{size_mb:.1f}".replace('.', r'\.')
                                        song_list += f"{i:02d}. {filename} ({size_mb_str}MB)\n"
                                        
                                        logger.info(f"ğŸ” æ­Œæ›² {i}: {filename} - {size_mb:.1f}MB -> {size_mb_str}MB")
                            
                            # ä½¿ç”¨æ™®é€šæ–‡æœ¬æ ¼å¼ï¼Œä¸éœ€è¦è½¬ä¹‰
                            escaped_album_name = album_name
                            escaped_artist = artist
                            escaped_country = music_info.get('country', 'CN')
                            escaped_track_count = str(track_count)
                            escaped_audio_quality = audio_quality
                            escaped_format_display = format_display
                            escaped_bitrate = bitrate
                            escaped_download_path = download_path
                            
                            # ä¿®æ”¹ä¸ºæ™®é€šæ–‡æœ¬æ ¼å¼ï¼Œä¸ç½‘æ˜“äº‘éŸ³ä¹ä¿æŒä¸€è‡´
                            success_text = (
                                f"ğŸµ **Apple Musicä¸“è¾‘ä¸‹è½½å®Œæˆ**\n\n"
                                f"ğŸ“€ ä¸“è¾‘åç§°: {album_name}\n\n"
                                f"ğŸ¤ è‰ºæœ¯å®¶: {artist}\n"
                                f"ğŸŒ åœ°åŒº: {music_info.get('country', 'CN')}\n"
                                f"ğŸ¼ æ›²ç›®æ•°é‡: {track_count} é¦–\n"
                                f"ğŸšï¸ ç¼–ç : {audio_quality}\n"
                                f"ğŸ’¾ æ€»å¤§å°: {total_size_mb:.2f} MB\n"
                                f"ğŸ¼ æ–‡ä»¶æ ¼å¼: {format_display}\n"
                                f"ğŸ–¼ï¸ ç ç‡: {bitrate}\n"
                                f"ğŸ›ï¸ é‡‡æ ·ç‡: 44.1 kHz\n"
                                f"ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}"
                            )
                            
                            # æ„å»ºæ­Œæ›²åˆ—è¡¨ï¼ˆæ™®é€šæ–‡æœ¬æ ¼å¼ï¼‰
                            if files_info:
                                success_text += "\n\nğŸµ æ­Œæ›²åˆ—è¡¨:\n\n"
                                for i, file_info in enumerate(files_info, 1):
                                    if file_info['name'].lower().endswith(('.m4a', '.flac', '.aac', '.mp3')):
                                        # ä¿æŒåŸå§‹æ–‡ä»¶åï¼ŒåŒ…å«æ­£ç¡®çš„æ‰©å±•å
                                        filename = file_info['name']
                                        size_mb = file_info['size'] / (1024 * 1024)
                                        success_text += f"{i}. {filename} ({size_mb:.1f}MB)\n"

                        elif is_song:
                            # å•æ›²ä¸‹è½½ - ä¿®å¤ï¼šé‡æ–°ç»Ÿè®¡æ–‡ä»¶å¹¶ä¿®å¤æ¶ˆæ¯æ ¼å¼
                            logger.info(f"ğŸ” è¿›å…¥Apple Musicå•æ›²ä¸‹è½½åˆ†æ”¯")
                            title = "ğŸµ Apple Music å•æ›²ä¸‹è½½å®Œæˆ"
                            
                            # ä¿®å¤ï¼šé‡æ–°ç»Ÿè®¡ä¸‹è½½ç›®å½•ä¸­çš„æ–‡ä»¶
                            download_path = result.get('download_path', '/downloads/AppleMusic')
                            amd_downloads_dir = os.path.join(download_path, "AM-DL downloads")
                            
                            files_info = []
                            total_size = 0
                            
                            # ä¿®å¤ï¼šä¼˜å…ˆä»music_infoä¸­è·å–ä¸“è¾‘å’Œè‰ºæœ¯å®¶ä¿¡æ¯ï¼Œç”¨äºæ„å»ºæ­£ç¡®çš„ç›®å½•è·¯å¾„
                            music_info = result.get('music_info', {})
                            artist_name = music_info.get('artist', 'æœªçŸ¥è‰ºæœ¯å®¶')
                            album_name = music_info.get('album', 'æœªçŸ¥ä¸“è¾‘')
                            
                            # æ„å»ºä¸“è¾‘ç›®å½•è·¯å¾„ - æ”¹ä¸ºåŒ…å«åŒ¹é…ï¼Œæ›´çµæ´»
                            album_dir = os.path.join(amd_downloads_dir, artist_name, album_name)
                            
                            if os.path.exists(album_dir):
                                # åªéå†ä¸“è¾‘ç›®å½•ï¼Œè€Œä¸æ˜¯æ•´ä¸ªAM-DL downloadsç›®å½•
                                logger.info(f"ğŸ” éå†ä¸“è¾‘ç›®å½•: {album_dir}")
                                for root, dirs, files in os.walk(album_dir):
                                    for file in files:
                                        if file.lower().endswith(('.m4a', '.flac', '.aac', '.mp3')):
                                            file_path = os.path.join(root, file)
                                            file_size = os.path.getsize(file_path)
                                            total_size += file_size
                                            
                                            # ä»æ–‡ä»¶è·¯å¾„æå–éŸ³ä¹ä¿¡æ¯
                                            relative_path = os.path.relpath(file_path, album_dir)
                                            files_info.append({
                                                'name': file,
                                                'path': relative_path,
                                                'size': file_size
                                            })
                            else:
                                # å¦‚æœä¸“è¾‘ç›®å½•ä¸å­˜åœ¨ï¼Œå°è¯•åŒ…å«åŒ¹é…
                                logger.warning(f"âš ï¸ ä¸“è¾‘ç›®å½•ä¸å­˜åœ¨: {album_dir}ï¼Œå°è¯•åŒ…å«åŒ¹é…")
                                
                                # å…ˆå°è¯•åœ¨è‰ºæœ¯å®¶ç›®å½•ä¸­æŸ¥æ‰¾åŒ…å«ä¸“è¾‘åç§°çš„ç›®å½•
                                artist_dir = os.path.join(amd_downloads_dir, artist_name)
                                if os.path.exists(artist_dir):
                                    artist_items = os.listdir(artist_dir)
                                    logger.info(f"ğŸ” è‰ºæœ¯å®¶ç›®å½• '{artist_name}' ä¸­çš„å­ç›®å½•: {artist_items}")
                                    
                                    # æŸ¥æ‰¾åŒ…å«ä¸“è¾‘åç§°çš„ç›®å½•
                                    for item in artist_items:
                                        item_path = os.path.join(artist_dir, item)
                                        if os.path.isdir(item_path) and album_name in item:
                                            album_dir = item_path
                                            logger.info(f"âœ… æ‰¾åˆ°åŒ…å«åŒ¹é…çš„ä¸“è¾‘ç›®å½•: '{item}' åŒ…å« '{album_name}'")
                                            break
                                    
                                    if album_dir:
                                        # éå†åŒ…å«åŒ¹é…çš„ä¸“è¾‘ç›®å½•
                                        logger.info(f"ğŸ” éå†åŒ…å«åŒ¹é…çš„ä¸“è¾‘ç›®å½•: {album_dir}")
                                        for root, dirs, files in os.walk(album_dir):
                                            for file in files:
                                                if file.lower().endswith(('.m4a', '.flac', '.aac', '.mp3')):
                                                    file_path = os.path.join(root, file)
                                                    file_size = os.path.getsize(file_path)
                                                    total_size += file_size
                                                    
                                                    # ä»æ–‡ä»¶è·¯å¾„æå–éŸ³ä¹ä¿¡æ¯
                                                    relative_path = os.path.relpath(file_path, album_dir)
                                                    files_info.append({
                                                        'name': file,
                                                        'path': relative_path,
                                                        'size': file_size
                                                    })
                                        
                                        logger.info(f"âœ… åŒ…å«åŒ¹é…ç›®å½•ä¸­æ‰¾åˆ° {len(files_info)} ä¸ªéŸ³é¢‘æ–‡ä»¶")
                                
                                # å¦‚æœä»ç„¶æ²¡æœ‰æ‰¾åˆ°ï¼Œå›é€€åˆ°æ•´ä¸ªAM-DL downloadsç›®å½•
                                if not files_info:
                                    logger.warning(f"âš ï¸ åŒ…å«åŒ¹é…ä¹Ÿå¤±è´¥ï¼Œå›é€€åˆ°æ•´ä¸ªç›®å½•éå†")
                                    if os.path.exists(amd_downloads_dir):
                                        for root, dirs, files in os.walk(amd_downloads_dir):
                                            for file in files:
                                                if file.lower().endswith(('.m4a', '.flac', '.aac', '.mp3')):
                                                    file_path = os.path.join(root, file)
                                                    file_size = os.path.getsize(file_path)
                                                    total_size += file_size
                                                    
                                                    # ä»æ–‡ä»¶è·¯å¾„æå–éŸ³ä¹ä¿¡æ¯
                                                    relative_path = os.path.relpath(file_path, amd_downloads_dir)
                                                    files_info.append({
                                                        'name': file,
                                                        'path': relative_path,
                                                        'size': file_size
                                                    })
                            
                            # è®¡ç®—æ€»å¤§å°ï¼ˆMBï¼‰
                            # ä¿®å¤ï¼šä¼˜å…ˆä½¿ç”¨resultä¸­çš„total_size_mbï¼Œé¿å…é‡å¤ç»Ÿè®¡
                            if 'result' in locals() and result and result.get('total_size_mb'):
                                total_size_mb = result.get('total_size_mb')
                                logger.info(f"ğŸ”§ å•æ›²ä¸‹è½½ï¼šä½¿ç”¨resultä¸­çš„total_size_mb: {total_size_mb:.2f} MB")
                            elif total_size > 0:
                                total_size_mb = total_size / (1024 * 1024)
                                logger.info(f"ğŸ”§ å•æ›²ä¸‹è½½ï¼šé‡æ–°ç»Ÿè®¡total_size={total_size} bytes -> {total_size_mb:.2f} MB")
                            else:
                                total_size_mb = 0
                                logger.warning(f"âš ï¸ å•æ›²ä¸‹è½½ï¼štotal_sizeä¸º0ï¼Œå¯èƒ½æ²¡æœ‰æ‰¾åˆ°éŸ³é¢‘æ–‡ä»¶")
                            
                            # ä¿®å¤ï¼šè·å–éŸ³é¢‘æ—¶é•¿
                            def get_audio_duration(file_path):
                                """ä½¿ç”¨ffprobeè·å–éŸ³é¢‘æ–‡ä»¶æ—¶é•¿"""
                                try:
                                    import subprocess
                                    result = subprocess.run([
                                        'ffprobe', '-loglevel', 'quiet', '-show_entries', 'format=duration',
                                        '-of', 'csv=p=0', file_path
                                    ], capture_output=True, text=True, timeout=10)
                                    
                                    if result.returncode == 0 and result.stdout.strip():
                                        duration_seconds = float(result.stdout.strip())
                                        minutes = int(duration_seconds // 60)
                                        seconds = int(duration_seconds % 60)
                                        return f"{minutes}:{seconds:02d}"
                                    else:
                                        return "æœªçŸ¥"
                                except Exception as e:
                                    logger.warning(f"âš ï¸ è·å–éŸ³é¢‘æ—¶é•¿å¤±è´¥: {e}")
                                    return "æœªçŸ¥"
                            
                            # è·å–ç¬¬ä¸€ä¸ªéŸ³é¢‘æ–‡ä»¶çš„æ—¶é•¿
                            duration = "æœªçŸ¥"
                            if files_info:
                                # ä¿®å¤ï¼šæ„å»ºæ­£ç¡®çš„æ–‡ä»¶è·¯å¾„
                                first_file = files_info[0]
                                
                                # å°è¯•å¤šç§è·¯å¾„æ„å»ºæ–¹å¼
                                possible_paths = []
                                
                                # æ–¹å¼1ï¼šä½¿ç”¨å½“å‰album_dirï¼ˆå¦‚æœå­˜åœ¨ï¼‰
                                if 'album_dir' in locals() and album_dir and os.path.exists(album_dir):
                                    possible_paths.append(os.path.join(album_dir, first_file['name']))
                                
                                # æ–¹å¼2ï¼šä½¿ç”¨æ ‡å‡†è·¯å¾„
                                standard_album_dir = os.path.join(amd_downloads_dir, artist_name, album_name)
                                if os.path.exists(standard_album_dir):
                                    possible_paths.append(os.path.join(standard_album_dir, first_file['name']))
                                
                                # æ–¹å¼3ï¼šæ ¹æ®files_infoä¸­çš„pathä¿¡æ¯æ„å»º
                                if first_file.get('path'):
                                    if os.path.isabs(first_file['path']):
                                        # å¦‚æœpathæ˜¯ç»å¯¹è·¯å¾„
                                        possible_paths.append(first_file['path'])
                                    else:
                                        # å¦‚æœpathæ˜¯ç›¸å¯¹è·¯å¾„
                                        possible_paths.append(os.path.join(amd_downloads_dir, first_file['path']))
                                
                                # æ–¹å¼4ï¼šç›´æ¥åœ¨amd_downloads_dirä¸­æŸ¥æ‰¾
                                for root, dirs, files in os.walk(amd_downloads_dir):
                                    if first_file['name'] in files:
                                        possible_paths.append(os.path.join(root, first_file['name']))
                                        break
                                
                                # å°è¯•æ¯ç§è·¯å¾„ï¼Œæ‰¾åˆ°ç¬¬ä¸€ä¸ªå­˜åœ¨çš„æ–‡ä»¶
                                first_file_path = None
                                for path in possible_paths:
                                    if os.path.exists(path):
                                        first_file_path = path
                                        logger.info(f"âœ… æ‰¾åˆ°éŸ³é¢‘æ–‡ä»¶: {first_file_path}")
                                        break
                                
                                if first_file_path:
                                    duration = get_audio_duration(first_file_path)
                                    logger.info(f"ğŸ” è·å–éŸ³é¢‘æ—¶é•¿: {duration}")
                                else:
                                    logger.warning(f"âš ï¸ æ— æ³•æ‰¾åˆ°éŸ³é¢‘æ–‡ä»¶: {first_file['name']}")
                                    logger.warning(f"âš ï¸ å°è¯•çš„è·¯å¾„: {possible_paths}")
                            
                            # éŸ³è´¨åˆ¤æ–­
                            if any(f['name'].lower().endswith('.flac') for f in files_info):
                                audio_quality = "æ— æŸ"
                            elif any(f['name'].lower().endswith('.m4a') for f in files_info):
                                audio_quality = "æ— æŸ" if total_size_mb > 20 else "é«˜è´¨é‡"
                            else:
                                audio_quality = "é«˜è´¨é‡"
                            
                            # æ–‡ä»¶æ ¼å¼æ˜¾ç¤º
                            formats = set()
                            for f in files_info:
                                if f['name'].lower().endswith('.flac'):
                                    formats.add('FLAC')
                                elif f['name'].lower().endswith('.m4a'):
                                    formats.add('M4A')
                                elif f['name'].lower().endswith('.aac'):
                                    formats.add('AAC')
                                elif f['name'].lower().endswith('.mp3'):
                                    formats.add('MP3')
                            
                            format_display = ", ".join(formats) if formats else "æœªçŸ¥"
                            
                            # æ„å»ºæˆåŠŸæ¶ˆæ¯ - ä½¿ç”¨MarkdownV2æ ¼å¼ï¼Œä¸ç½‘æ˜“äº‘éŸ³ä¹ä¿æŒä¸€è‡´
                            # ä¼˜å…ˆä»curlè„šæœ¬è·å–éŸ³ä¹ä¿¡æ¯ï¼Œå¦‚æœæ²¡æœ‰åˆ™ä»æ–‡ä»¶åæå–
                            music_info = result.get('music_info', {})
                            if music_info and music_info.get('title') != 'æœªçŸ¥æ ‡é¢˜':
                                # ä½¿ç”¨curlè„šæœ¬è·å–çš„ä¿¡æ¯
                                music_title = music_info.get('title', 'æœªçŸ¥æ ‡é¢˜')
                                artist = music_info.get('artist', 'æœªçŸ¥è‰ºæœ¯å®¶')
                                album = music_info.get('album', 'æœªçŸ¥ä¸“è¾‘')
                            else:
                                # ä»æ–‡ä»¶åæå–éŸ³ä¹ä¿¡æ¯
                                first_file = files_info[0]
                                file_name = first_file['name']
                                # ç§»é™¤æ–‡ä»¶æ‰©å±•å
                                music_title = file_name.replace('.m4a', '').replace('.flac', '').replace('.aac', '').replace('.mp3', '')
                                artist = 'æœªçŸ¥è‰ºæœ¯å®¶'
                                album = 'æœªçŸ¥ä¸“è¾‘'
                            
                            # éŸ³è´¨åˆ¤æ–­ - ä¿®å¤ï¼šæ˜¾ç¤ºæ­£ç¡®çš„Apple MusicéŸ³è´¨ï¼ˆä¸é‡å¤æ˜¾ç¤ºç¼–ç æ ¼å¼ï¼‰
                            if any(f['name'].lower().endswith('.flac') for f in files_info):
                                audio_quality = "FLAC"
                                bitrate = "æ— æŸ"
                            elif any(f['name'].lower().endswith('.m4a') for f in files_info):
                                audio_quality = "ALAC"  # Apple Musicä½¿ç”¨ALACæ ¼å¼
                                bitrate = "2304kbps"  # Apple Music ALACæ ‡å‡†ç ç‡
                            elif any(f['name'].lower().endswith('.aac') for f in files_info):
                                audio_quality = "AAC"
                                bitrate = "256kbps"  # Apple Music AACæ ‡å‡†ç ç‡
                            else:
                                audio_quality = "MP3"
                                bitrate = "320kbps"  # æ ‡å‡†MP3ç ç‡
                            
                            # ä¿®æ”¹ä¸ºæ™®é€šæ–‡æœ¬æ ¼å¼ï¼Œä¸ä¸“è¾‘ä¸‹è½½ä¿æŒä¸€è‡´
                            success_text = (
                                f"ğŸµ **Apple Music å•æ›²ä¸‹è½½å®Œæˆ**\n\n"
                                f"ğŸµ éŸ³ä¹: {music_title}\n"
                                f"ğŸ¤ è‰ºæœ¯å®¶: {artist}\n"
                                f"ğŸ“€ ä¸“è¾‘: {album}\n"
                                f"ğŸ’¾ å¤§å°: {total_size_mb:.2f}MB\n"
                                f"ğŸ–¼ï¸ ç ç‡: {bitrate}\n"
                                f"ğŸšï¸ ç¼–ç : {audio_quality}\n"
                                f"ğŸ›ï¸ é‡‡æ ·ç‡: 44.1 kHz\n"
                                f"â±ï¸ æ—¶é•¿: {duration}\n"
                                f"ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}"
                            )
                        
                        else:
                            # å…¶ä»–æƒ…å†µï¼ˆæœªçŸ¥ç±»å‹ï¼‰
                            logger.warning(f"âš ï¸ Apple Musicä¸‹è½½ç±»å‹æœªçŸ¥: URL={url}, music_type={result.get('music_type')}")
                            title = "ğŸµ Apple Music ä¸‹è½½å®Œæˆ"
                            escaped_title = (title)
                            
                            # æ„å»ºé€šç”¨æˆåŠŸæ¶ˆæ¯
                            success_text = (
                                f"{escaped_title}\n\n"
                                f"ğŸ”— **é“¾æ¥**: `{(url)}`\n"
                                f"ğŸ“‚ **ä¿å­˜ä½ç½®**: `{(download_path)}`"
                            )

                        try:
                            # ä½¿ç”¨æ™®é€šæ–‡æœ¬æ ¼å¼ï¼Œä¸ç½‘æ˜“äº‘éŸ³ä¹ä¿æŒä¸€è‡´
                            await status_message.edit_text(success_text, parse_mode=None)
                            logger.info("Apple Music ä¸‹è½½å®Œæˆæ¶ˆæ¯å‘é€æˆåŠŸ")
                        except Exception as e:
                            logger.error(f"å‘é€ Apple Music å®Œæˆæ¶ˆæ¯å¤±è´¥: {e}")
                            logger.error(f"é”™è¯¯è¯¦æƒ…: {type(e).__name__}: {str(e)}")
                            
                            # å›é€€æ¶ˆæ¯
                            if is_album:
                                fallback_text = (
                                    f"âœ… Apple Musicä¸“è¾‘ä¸‹è½½å®Œæˆ\n\n"
                                    f"ğŸ“€ ä¸“è¾‘: {album_name}\n"
                                    f"ğŸ¤ è‰ºæœ¯å®¶: {artist}\n"
                                    f"ğŸ¼ æ›²ç›®æ•°é‡: {track_count} é¦–\n"
                                    f"ğŸ’¾ æ€»å¤§å°: {total_size_mb:.2f} MB\n"
                                    f"ğŸ“ ä¸‹è½½å®Œæˆï¼Œå…± {len(files_info)} ä¸ªæ–‡ä»¶\n"
                                    f"ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}"
                                )
                            elif is_song:
                                fallback_text = (
                                    f"âœ… Apple Musicå•æ›²ä¸‹è½½å®Œæˆ\n\n"
                                    f"ğŸµ éŸ³ä¹: {music_info.get('title', 'æœªçŸ¥æ ‡é¢˜')}\n"
                                    f"ğŸ¤ è‰ºæœ¯å®¶: {artist}\n"
                                    f"ğŸ“€ ä¸“è¾‘: {album_name}\n"
                                    f"ğŸ’¾ å¤§å°: {total_size_mb:.2f} MB\n"
                                    f"ğŸ“ ä¸‹è½½å®Œæˆï¼Œå…± {len(files_info)} ä¸ªæ–‡ä»¶\n"
                                    f"ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}"
                                )
                            else:
                                fallback_text = f"âœ… Apple Musicä¸‹è½½å®Œæˆ\nğŸ“ ä¸‹è½½å®Œæˆï¼Œå…± {len(files_info)} ä¸ªæ–‡ä»¶"
                            
                            await status_message.edit_text(fallback_text, parse_mode=None)
                        return

                    # æ£€æŸ¥æ˜¯å¦ä¸ºYouTube Musicä¸‹è½½
                    elif platform.lower() == 'youtubemusic' or result.get('platform') == 'YouTubeMusic':
                        # YouTube Musicä¸‹è½½å®Œæˆ
                        if result.get('album_name'):
                            # ä¸“è¾‘ä¸‹è½½ - å‚è€ƒç½‘æ˜“äº‘éŸ³ä¹æ ¼å¼
                            title = "ğŸµ YouTube Musicä¸“è¾‘ä¸‹è½½å®Œæˆ"
                            
                            album_name = result.get('album_name', 'æœªçŸ¥ä¸“è¾‘')
                            creator = result.get('creator', 'æœªçŸ¥è‰ºæœ¯å®¶')
                            total_songs = result.get('total_songs', 0)
                            downloaded_songs = result.get('downloaded_songs', 0)
                            failed_songs = result.get('failed_songs', 0)
                            total_size = result.get('total_size_mb', 0)
                            download_path = result.get('download_path', 'æœªçŸ¥è·¯å¾„')
                            quality = result.get('quality', 'best')
                            
                            # è·å–éŸ³è´¨ä¿¡æ¯
                            if quality == 'best':
                                quality_info = {'name': 'M4Aæ— æŸ', 'bitrate': 'AAC/256kbps'}
                            else:
                                quality_info = {'name': f'M4A {quality}', 'bitrate': 'Variable'}
                            
                            # è·å–æ­Œæ›²åˆ—è¡¨
                            songs = result.get('songs', [])
                            
                            success_text = (
                                f"{title}\n\n"
                                f"ğŸ“€ ä¸“è¾‘åç§°: {album_name}\n\n"
                                f"ğŸ¤ è‰ºæœ¯å®¶ï¼š{creator}\n"
                                f"ğŸ¼ æ›²ç›®æ•°é‡: {downloaded_songs} é¦–\n"
                                f"ğŸšï¸ éŸ³é¢‘è´¨é‡: {quality_info['name']}\n"
                                f"ğŸ’¾ æ€»å¤§å°: {total_size:.2f} MB\n"
                                f"ğŸ“Š ç ç‡: {quality_info['bitrate']}\n"
                                f"ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}"
                            )
                            
                            # æ˜¾ç¤ºæ­Œæ›²åˆ—è¡¨ï¼ˆé™åˆ¶æ˜¾ç¤ºæ•°é‡ä»¥é¿å…æ¶ˆæ¯è¿‡é•¿ï¼‰
                            if songs:
                                success_text += "\n\nğŸµ æ­Œæ›²åˆ—è¡¨:\n"
                                for i, song in enumerate(songs[:10], 1):  # åªæ˜¾ç¤ºå‰10é¦–
                                    song_title = song.get('title', 'æœªçŸ¥æ­Œæ›²')
                                    file_size_mb = round(song.get('file_size', 0) / (1024 * 1024), 2)
                                    success_text += f"{i:02d}. {song_title}.m4a ({file_size_mb}MB)\n"
                                
                                if len(songs) > 10:
                                    success_text += f"... è¿˜æœ‰ {len(songs) - 10} é¦–æ­Œæ›²"
                            
                            # å¦‚æœæœ‰å¤±è´¥çš„æ­Œæ›²ï¼Œæ·»åŠ å¤±è´¥ä¿¡æ¯
                            if failed_songs > 0:
                                success_text += f"\n\nâŒ ä¸‹è½½å¤±è´¥: {failed_songs} é¦–"
                            
                        elif result.get('playlist_name'):
                            # æ’­æ”¾åˆ—è¡¨ä¸‹è½½ - å‚è€ƒç½‘æ˜“äº‘éŸ³ä¹æ ¼å¼
                            title = "ğŸµ YouTube Musicæ’­æ”¾åˆ—è¡¨ä¸‹è½½å®Œæˆ"
                            
                            playlist_name = result.get('playlist_name', 'æœªçŸ¥æ’­æ”¾åˆ—è¡¨')
                            creator = result.get('creator', 'æœªçŸ¥åˆ›å»ºè€…')
                            total_songs = result.get('total_songs', 0)
                            downloaded_songs = result.get('downloaded_songs', 0)
                            failed_songs = result.get('failed_songs', 0)
                            total_size = result.get('total_size_mb', 0)
                            download_path = result.get('download_path', 'æœªçŸ¥è·¯å¾„')
                            quality = result.get('quality', 'best')
                            
                            # è·å–éŸ³è´¨ä¿¡æ¯
                            if quality == 'best':
                                quality_info = {'name': 'M4Aæ— æŸ', 'bitrate': 'AAC/256kbps'}
                            else:
                                quality_info = {'name': f'M4A {quality}', 'bitrate': 'Variable'}
                            
                            # è·å–æ­Œæ›²åˆ—è¡¨
                            songs = result.get('songs', [])
                            
                            success_text = (
                                f"{title}\n\n"
                                f"ğŸ“‹ æ’­æ”¾åˆ—è¡¨åç§°: {playlist_name}\n"
                                f"ğŸµ æ­Œæ›²æ•°é‡: {total_songs} é¦–\n"
                                f"âœ… æˆåŠŸä¸‹è½½: {downloaded_songs} é¦–\n"
                                f"âŒ å¤±è´¥æ•°é‡: {failed_songs} é¦–\n"
                                f"ğŸ’¾ æ€»å¤§å°: {total_size:.1f} MB\n"
                                f"ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}"
                            )
                            
                            # æ˜¾ç¤ºæ­Œæ›²åˆ—è¡¨ï¼ˆé™åˆ¶æ˜¾ç¤ºæ•°é‡ä»¥é¿å…æ¶ˆæ¯è¿‡é•¿ï¼‰
                            if songs:
                                success_text += "\n\nğŸµ æ­Œæ›²åˆ—è¡¨:\n"
                                for i, song in enumerate(songs[:10], 1):  # åªæ˜¾ç¤ºå‰10é¦–
                                    song_title = song.get('title', 'æœªçŸ¥æ­Œæ›²')
                                    file_size_mb = round(song.get('file_size', 0) / (1024 * 1024), 2)
                                    success_text += f"{i:02d}. {song_title}.m4a ({file_size_mb}MB)\n"
                                
                                if len(songs) > 10:
                                    success_text += f"... è¿˜æœ‰ {len(songs) - 10} é¦–æ­Œæ›²"
                            
                        else:
                            # å•æ›²ä¸‹è½½
                            title = "ğŸµ YouTube Musicå•æ›²ä¸‹è½½å®Œæˆ"
                            
                            song_title = result.get('song_title', 'æœªçŸ¥æ­Œæ›²')
                            song_artist = result.get('song_artist', 'æœªçŸ¥è‰ºæœ¯å®¶')
                            filename = result.get('filename', 'æœªçŸ¥æ–‡ä»¶')
                            size_mb = result.get('size_mb', 0)
                            download_path = result.get('download_path', 'æœªçŸ¥è·¯å¾„')
                            quality = result.get('quality', 'best')
                            format_type = result.get('format', 'M4A')
                            duration = result.get('duration', 0)
                            
                            # è·å–éŸ³è´¨ä¿¡æ¯
                            if quality == 'best':
                                quality_info = {'name': f'{format_type}æ— æŸ', 'bitrate': 'AAC/256kbps'}
                            else:
                                quality_info = {'name': f'{format_type} {quality}', 'bitrate': 'Variable'}
                            
                            # æ ¼å¼åŒ–æ—¶é•¿
                            duration_str = "æœªçŸ¥"
                            if duration > 0:
                                minutes = int(duration // 60)
                                seconds = int(duration % 60)
                                duration_str = f"{minutes:02d}:{seconds:02d}"
                            
                            success_text = (
                                f"{title}\n\n"
                                f"ğŸµ æ­Œæ›²: {song_title}\n"
                                f"ğŸ¤ è‰ºæœ¯å®¶: {song_artist}\n"
                                f"ğŸšï¸ éŸ³è´¨: {quality_info['name']}\n"
                                f"â±ï¸ æ—¶é•¿: {duration_str}\n"
                                f"ğŸ’¾ å¤§å°: {size_mb:.2f} MB\n"
                                f"ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}"
                            )
                        
                        # å‘é€å®Œæˆæ¶ˆæ¯
                        try:
                            await status_message.edit_text(success_text, parse_mode=None)
                            logger.info("YouTube Music ä¸‹è½½å®Œæˆæ¶ˆæ¯å‘é€æˆåŠŸ")
                        except Exception as e:
                            logger.error(f"å‘é€ YouTube Music å®Œæˆæ¶ˆæ¯å¤±è´¥: {e}")
                        return

                    # æ£€æŸ¥æ˜¯å¦ä¸ºBç«™åˆé›†ä¸‹è½½
                    video_type = result.get('video_type', '')
                    count = result.get('count', 0)
                    playlist_title = result.get('playlist_title', '')

                    if video_type == 'playlist' and count > 1 and 'Bilibili' in platform:
                        # Bç«™åˆé›†ä¸‹è½½å®Œæˆï¼Œä½¿ç”¨ç‰¹æ®Šæ ¼å¼
                        # ä½¿ç”¨resultä¸­çš„æ–‡ä»¶ä¿¡æ¯ï¼Œè€Œä¸æ˜¯éå†ç›®å½•
                        import os

                        try:
                            # æ£€æŸ¥resultä¸­æ˜¯å¦æœ‰æ–‡ä»¶ä¿¡æ¯
                            if result.get('is_playlist') and result.get('files'):
                                # ä½¿ç”¨yt-dlpè®°å½•çš„æ–‡ä»¶ä¿¡æ¯
                                file_info_list = result['files']

                                # æ„å»ºæ–‡ä»¶ååˆ—è¡¨
                                file_list = []
                                for i, file_info in enumerate(file_info_list, 1):
                                    filename = file_info['filename']
                                    file_list.append(f"  {i:02d}. {filename}")

                                # ä½¿ç”¨å·²è®¡ç®—çš„æ€»æ–‡ä»¶å¤§å°
                                total_size = result.get('total_size_mb', 0)
                            else:
                                # å›é€€æ–¹æ¡ˆï¼šå¦‚æœresultä¸­æ²¡æœ‰æ–‡ä»¶ä¿¡æ¯ï¼Œä½¿ç”¨ç›®å½•éå†
                                logger.warning("âš ï¸ resultä¸­æ²¡æœ‰æ–‡ä»¶ä¿¡æ¯ï¼Œä½¿ç”¨ç›®å½•éå†å›é€€æ–¹æ¡ˆ")

                                def get_files_from_current_playlist(download_path, result, file_extensions=None):
                                    """åªä»æœ¬æ¬¡ä¸‹è½½çš„æ’­æ”¾åˆ—è¡¨ç›®å½•ä¸­è·å–æ–‡ä»¶"""
                                    if file_extensions is None:
                                        file_extensions = ['.mp4', '.mkv', '.webm', '.avi', '.mov']

                                    download_dir = Path(download_path)
                                    video_files = []

                                    # æ£€æŸ¥æ˜¯å¦ä¸ºæ’­æ”¾åˆ—è¡¨ä¸‹è½½
                                    playlist_title = result.get('playlist_title')
                                    logger.info(f"ğŸ” æ£€æŸ¥æ’­æ”¾åˆ—è¡¨æ ‡é¢˜: {playlist_title}")

                                    if playlist_title:
                                        # å¦‚æœæ˜¯æ’­æ”¾åˆ—è¡¨ï¼Œåªéå†å¯¹åº”çš„å­ç›®å½•
                                        playlist_dir = download_dir / playlist_title
                                        logger.info(f"ğŸ¯ åªéå†æœ¬æ¬¡ä¸‹è½½çš„æ’­æ”¾åˆ—è¡¨ç›®å½•: {playlist_dir}")

                                        if playlist_dir.exists():
                                            # åªéå†æ’­æ”¾åˆ—è¡¨ç›®å½•ä¸­çš„æ–‡ä»¶
                                            for file_path in playlist_dir.glob("*"):
                                                if file_path.is_file() and file_path.suffix.lower() in file_extensions:
                                                    video_files.append(file_path)
                                                    logger.info(f"âœ… æ‰¾åˆ°æ–‡ä»¶: {file_path}")
                                        else:
                                            logger.warning(f"âš ï¸ æ’­æ”¾åˆ—è¡¨ç›®å½•ä¸å­˜åœ¨: {playlist_dir}")
                                            # å›é€€æ–¹æ¡ˆï¼šå°è¯•éå†æ ¹ç›®å½•
                                            logger.info(f"ğŸ”„ å›é€€åˆ°æ ¹ç›®å½•éå†: {download_dir}")
                                            for file_path in download_dir.glob("*"):
                                                if file_path.is_file() and file_path.suffix.lower() in file_extensions:
                                                    video_files.append(file_path)
                                                    logger.info(f"âœ… åœ¨æ ¹ç›®å½•æ‰¾åˆ°æ–‡ä»¶: {file_path}")
                                    else:
                                        # å¦‚æœä¸æ˜¯æ’­æ”¾åˆ—è¡¨ï¼Œåªéå†æ ¹ç›®å½•
                                        logger.info(f"ğŸ¯ å•è§†é¢‘ä¸‹è½½ï¼Œåªéå†æ ¹ç›®å½•: {download_dir}")
                                        for file_path in download_dir.glob("*"):
                                            if file_path.is_file() and file_path.suffix.lower() in file_extensions:
                                                video_files.append(file_path)
                                                logger.info(f"âœ… æ‰¾åˆ°æ–‡ä»¶: {file_path}")

                                    # å¦‚æœä»ç„¶æ²¡æœ‰æ‰¾åˆ°æ–‡ä»¶ï¼Œå°è¯•é€’å½’éå†
                                    if not video_files:
                                        logger.warning("âš ï¸ æœªæ‰¾åˆ°æ–‡ä»¶ï¼Œå°è¯•é€’å½’éå†æ‰€æœ‰å­ç›®å½•")
                                        for file_path in download_dir.rglob("*"):
                                            if file_path.is_file() and file_path.suffix.lower() in file_extensions:
                                                video_files.append(file_path)
                                                logger.info(f"âœ… é€’å½’æ‰¾åˆ°æ–‡ä»¶: {file_path}")

                                    # æŒ‰æ–‡ä»¶åæ’åº
                                    video_files.sort(key=lambda x: x.name)
                                    logger.info(f"ğŸ“Š æ€»å…±æ‰¾åˆ° {len(video_files)} ä¸ªæ–‡ä»¶")

                                    return video_files

                                video_files = get_files_from_current_playlist(download_path, result)

                                # æ„å»ºæ–‡ä»¶ååˆ—è¡¨
                                file_list = []
                                for i, file_path in enumerate(video_files, 1):
                                    filename = file_path.name
                                    file_list.append(f"  {i:02d}. {filename}")

                                # è®¡ç®—æ€»æ–‡ä»¶å¤§å°
                                total_size = sum(f.stat().st_size for f in video_files) / (1024 * 1024)

                            # è·å–åˆ†è¾¨ç‡ä¿¡æ¯
                            if result.get('is_playlist') and result.get('files'):
                                # ä½¿ç”¨resultä¸­çš„åˆ†è¾¨ç‡ä¿¡æ¯
                                resolutions = set()
                                for file_info in file_info_list:
                                    resolution = file_info.get('resolution', 'æœªçŸ¥')
                                    if resolution != 'æœªçŸ¥':
                                        resolutions.add(resolution)
                                resolution_str = ', '.join(sorted(resolutions)) if resolutions else 'æœªçŸ¥'
                            else:
                                # å›é€€æ–¹æ¡ˆï¼šä½¿ç”¨ffprobeæ£€æµ‹åˆ†è¾¨ç‡
                                resolutions = set()
                                for file_path in video_files[:3]:  # åªæ£€æŸ¥å‰3ä¸ªæ–‡ä»¶
                                    try:
                                        import subprocess
                                        result_cmd = subprocess.run([
                                            'ffprobe', '-loglevel', 'quiet', '-select_streams', 'v:0',
                                            '-show_entries', 'stream=width,height', '-of', 'csv=p=0',
                                            str(file_path)
                                        ], capture_output=True, text=True)
                                        if result_cmd.returncode == 0:
                                            width, height = result_cmd.stdout.strip().split(',')
                                            resolutions.add(f"{width}x{height}")
                                    except:
                                        pass
                                resolution_str = ', '.join(sorted(resolutions)) if resolutions else 'æœªçŸ¥'

                            # æ£€æŸ¥æ˜¯å¦æœ‰æ–‡ä»¶åˆ—è¡¨ï¼Œå¦‚æœæ²¡æœ‰åˆ™å°è¯•å…¶ä»–æ–¹å¼è·å–æ–‡ä»¶å
                            if not file_list:
                                logger.warning("âš ï¸ æ–‡ä»¶åˆ—è¡¨ä¸ºç©ºï¼Œå°è¯•å…¶ä»–æ–¹å¼è·å–æ–‡ä»¶å")
                                # å°è¯•ä»resultä¸­è·å–æ–‡ä»¶åä¿¡æ¯
                                if result.get('filename'):
                                    file_list = [f"  {result['filename']}"]
                                elif result.get('files'):
                                    # ä»result.filesä¸­è·å–æ–‡ä»¶å
                                    for i, file_info in enumerate(result['files'], 1):
                                        filename = file_info.get('filename', f'æ–‡ä»¶{i}')
                                        file_list.append(f"  {i:02d}. {filename}")
                                else:
                                    # æœ€åçš„å›é€€æ–¹æ¡ˆï¼šä½¿ç”¨display_filename
                                    if display_filename:
                                        file_list = [f"  {display_filename}"]

                            # æ„å»ºå®Œæˆæ¶ˆæ¯
                            if file_list:
                                completion_text = f"""ğŸ¬ è§†é¢‘ä¸‹è½½å®Œæˆ

ğŸ“ æ–‡ä»¶å:
{chr(10).join(file_list)}

ğŸ’¾ æ–‡ä»¶å¤§å°: {total_size:.2f} MB
ğŸ“Š é›†æ•°: {count} é›†
ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}"""
                            else:
                                # å¦‚æœä»ç„¶æ²¡æœ‰æ–‡ä»¶åï¼Œä½¿ç”¨ç®€åŒ–æ ¼å¼
                                completion_text = f"""ğŸ¬ è§†é¢‘ä¸‹è½½å®Œæˆ

ğŸ’¾ æ–‡ä»¶å¤§å°: {total_size:.2f} MB
ğŸ“Š é›†æ•°: {count} é›†
ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}"""

                        except Exception as e:
                            logger.error(f"æ„å»ºBç«™åˆé›†å®Œæˆä¿¡æ¯æ—¶å‡ºé”™: {e}")
                            # å¦‚æœå‡ºé”™ï¼Œä½¿ç”¨é»˜è®¤æ ¼å¼
                            completion_text = f"""ğŸ¬ è§†é¢‘ä¸‹è½½å®Œæˆ

ğŸ“ æ–‡ä»¶å: {display_filename}
ğŸ’¾ æ–‡ä»¶å¤§å°: {size_mb:.2f} MB
ğŸ“Š é›†æ•°: {count} é›†
ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}"""
                    else:
                        # å•è§†é¢‘ä¸‹è½½å®Œæˆï¼Œæ˜¾ç¤ºå®Œæ•´ä¿¡æ¯åŒ…æ‹¬åˆ†è¾¨ç‡
                        completion_text = f"""ğŸ¬ è§†é¢‘ä¸‹è½½å®Œæˆ

ğŸ“ æ–‡ä»¶å: {display_filename}
ğŸ’¾ æ–‡ä»¶å¤§å°: {size_mb:.2f} MB
ğŸ–¼ï¸ åˆ†è¾¨ç‡: {final_resolution}
ğŸ“‚ ä¿å­˜ä½ç½®: {download_path}"""

                    await status_message.edit_text(completion_text, parse_mode=None)
                    logger.info("æ˜¾ç¤ºä¸‹è½½å®Œæˆä¿¡æ¯")
                except Exception as e:
                    if "Flood control" in str(e):
                        logger.warning(
                            "ä¸‹è½½å®Œæˆæ¶ˆæ¯é‡åˆ°Flood controlï¼Œç­‰å¾…5ç§’åé‡è¯•..."
                        )
                        await asyncio.sleep(5)
                        try:
                            await status_message.edit_text(completion_text, parse_mode=None)
                        except Exception as retry_error:
                            logger.error(
                                f"é‡è¯•å‘é€ä¸‹è½½å®Œæˆæ¶ˆæ¯å¤±è´¥: {retry_error}"
                            )
                    else:
                        logger.error(f"å‘é€ä¸‹è½½å®Œæˆæ¶ˆæ¯å¤±è´¥: {e}")
        else:
            # ç¡®ä¿resultä¸ä¸ºNone
            if result:
                error_msg = result.get("error", "æœªçŸ¥é”™è¯¯")
            else:
                error_msg = "ä¸‹è½½ä»»åŠ¡è¿”å›ç©ºç»“æœ"

            try:
                await status_message.edit_text(
                    f"âŒ ä¸‹è½½å¤±è´¥: `{(error_msg)}`",
                    parse_mode=None,
                )
            except Exception as retry_error:
                logger.error(f"é‡è¯•å‘é€ä¸‹è½½å¤±è´¥æ¶ˆæ¯å¤±è´¥: {retry_error}")
            return


    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """å¤„ç† /start å‘½ä»¤ - æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯"""
        user_id = update.message.from_user.id

        # æƒé™æ£€æŸ¥
        if not self._check_user_permission(user_id):
            await update.message.reply_text("âŒ æ‚¨æ²¡æœ‰æƒé™ä½¿ç”¨æ­¤æœºå™¨äºº")
            return

        welcome_message = (
            "ğŸ¤– <b>æ¬¢è¿ä½¿ç”¨SaveXTubeä¸‹è½½æœºå™¨äººï¼</b>\n\n"
            "ä½ å¯ä»¥å‘é€é“¾æ¥æˆ–ä½¿ç”¨å‘½ä»¤æ“ä½œã€‚\n"
            "è¾“å…¥ /help æŸ¥çœ‹å®Œæ•´åŠŸèƒ½ã€‚"
        )
        await update.message.reply_text(welcome_message, parse_mode="HTML")

    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """å¤„ç† /help å‘½ä»¤ - æ˜¾ç¤ºè¯¦ç»†å¸®åŠ©ä¿¡æ¯"""
        user_id = update.message.from_user.id

        # æƒé™æ£€æŸ¥
        if not self._check_user_permission(user_id):
            await update.message.reply_text("âŒ æ‚¨æ²¡æœ‰æƒé™ä½¿ç”¨æ­¤æœºå™¨äºº")
            return

        help_message = (
            "ğŸ¤– <b>SaveXTube æœºå™¨äººå¸®åŠ©</b>\n\n"

            "ğŸ“º <b>æ”¯æŒçš„å¹³å°ï¼š</b>\n"
            "â€¢ ğŸ¦ X (Twitter)\n"
            "â€¢ ğŸ¬ YouTubeï¼ˆè§†é¢‘/æ’­æ”¾åˆ—è¡¨/é¢‘é“ï¼‰\n"
            "â€¢ ğŸ“º Bilibiliï¼ˆè§†é¢‘/å¤šP/åˆé›†/æ”¶è—å¤¹ï¼‰\n"
            "â€¢ ğŸ” Xvideos / Pornhub\n"
            "â€¢ ğŸ“¸ Instagram / TikTok\n"
            "â€¢ ğŸµ æŠ–éŸ³ / å¿«æ‰‹\n"
            "â€¢ ğŸ“– å°çº¢ä¹¦ / å¾®åš\n"
            "â€¢ ğŸ“° Telegraph / Facebook\n"
            "â€¢ ğŸµ ç½‘æ˜“äº‘éŸ³ä¹ï¼ˆæ­Œæ›²/ä¸“è¾‘/æ­Œå•ï¼‰\n\n"

            "ğŸš€ <b>ä½¿ç”¨æ–¹æ³•ï¼š</b>\n"
            "1. ç›´æ¥å‘é€è§†é¢‘é“¾æ¥å³å¯å¼€å§‹ä¸‹è½½\n"
            "2. æ”¯æŒæ‰¹é‡é“¾æ¥ï¼ˆä¸€æ¬¡å‘é€å¤šä¸ªé“¾æ¥ï¼‰\n"
            "3. æ”¯æŒæ’­æ”¾åˆ—è¡¨ä¸‹è½½\n"
            "4. æ”¯æŒåª’ä½“æ–‡ä»¶è½¬å‘å’Œå¤„ç†\n\n"

            "âš™ï¸ <b>å¯ç”¨å‘½ä»¤ï¼š</b>\n"
            "â€¢ <b>/start</b> - ğŸ æ˜¾ç¤ºæ¬¢è¿ä¿¡æ¯\n"
            "â€¢ <b>/help</b> - ğŸ“– æ˜¾ç¤ºæ­¤å¸®åŠ©ä¿¡æ¯\n"
            "â€¢ <b>/status</b> - ğŸ“Š æŸ¥çœ‹ä¸‹è½½ç»Ÿè®¡å’Œç³»ç»ŸçŠ¶æ€\n"
            "â€¢ <b>/version</b> - ğŸ”§ æŸ¥çœ‹ç‰ˆæœ¬ä¿¡æ¯\n"
            "â€¢ <b>/settings</b> - ğŸ›  åŠŸèƒ½è®¾ç½®é¢æ¿\n"
            "â€¢ <b>/favsub</b> - ğŸ“š Bç«™æ”¶è—å¤¹è®¢é˜…ç®¡ç†\n"
            "â€¢ <b>/cancel</b> - âŒ å–æ¶ˆå½“å‰ä¸‹è½½ä»»åŠ¡\n"
            "â€¢ <b>/cleanup</b> - ğŸ§¹ æ¸…ç†é‡å¤æ–‡ä»¶\n"
            "â€¢ <b>/reboot</b> - ğŸ”„ é‡å¯æœºå™¨äººï¼ˆç®¡ç†å‘˜ï¼‰\n\n"

            "âœ¨ <b>æ ¸å¿ƒç‰¹æ€§ï¼š</b>\n"
            "â€¢ ğŸ”„ å®æ—¶ä¸‹è½½è¿›åº¦æ˜¾ç¤º\n"
            "â€¢ ğŸ¯ æ™ºèƒ½æ ¼å¼é€‰æ‹©å’Œå¤šé‡å¤‡ç”¨æ–¹æ¡ˆ\n"
            "â€¢ ğŸ”§ è‡ªåŠ¨æ ¼å¼è½¬æ¢ï¼ˆwebm â†’ mp4ï¼‰\n"
            "â€¢ ğŸ“ æŒ‰å¹³å°æ™ºèƒ½åˆ†ç±»å­˜å‚¨\n"
            "â€¢ ğŸ”’ æ”¯æŒ NSFW å†…å®¹ä¸‹è½½\n"
            "â€¢ ğŸ†” å”¯ä¸€æ–‡ä»¶åï¼Œé¿å…è¦†ç›–\n"
            "â€¢ ğŸ“‹ æ‰¹é‡ä¸‹è½½ï¼ˆæ’­æ”¾åˆ—è¡¨/é¢‘é“/åˆé›†ï¼‰\n"
            "â€¢ ğŸµ YouTubeéŸ³é¢‘æ¨¡å¼ï¼ˆMP3æå–ï¼‰\n"
            "â€¢ ğŸ’¬ Bç«™å¼¹å¹•ä¸‹è½½\n"
            "â€¢ ğŸ”„ Bç«™æ”¶è—å¤¹è‡ªåŠ¨è®¢é˜…æ›´æ–°\n"
            "â€¢ ğŸ“± è‡ªåŠ¨å‹ç¼©å¤§æ–‡ä»¶é€‚é…Telegram\n"
            "â€¢ ğŸ’¾ æ–­ç‚¹ç»­ä¼ å’Œé”™è¯¯é‡è¯•\n\n"

            "ğŸ›  <b>è®¾ç½®é€‰é¡¹ï¼š</b>\n"
            "â€¢ è‡ªåŠ¨æ’­æ”¾åˆ—è¡¨ä¸‹è½½\n"
            "â€¢ YouTubeè§†é¢‘IDæ ‡ç­¾\n"
            "â€¢ Bç«™å¼¹å¹•ä¸‹è½½\n"
            "â€¢ YouTubeéŸ³é¢‘æ¨¡å¼\n"
            "â€¢ UGCæ’­æ”¾åˆ—è¡¨å¤„ç†\n"
            "â€¢ ç¼©ç•¥å›¾ä¸‹è½½\n"
            "â€¢ å­—å¹•ä¸‹è½½\n\n"

            "ğŸ’¡ <b>ä½¿ç”¨æŠ€å·§ï¼š</b>\n"
            "â€¢ å‘é€æ’­æ”¾åˆ—è¡¨é“¾æ¥å¯æ‰¹é‡ä¸‹è½½\n"
            "â€¢ ä½¿ç”¨ /settings è°ƒæ•´ä¸‹è½½åå¥½\n"
            "â€¢ å¤§æ–‡ä»¶ä¼šè‡ªåŠ¨åˆ†å‰²å‘é€\n"
            "â€¢ æ”¯æŒå¤šç§è§†é¢‘è´¨é‡é€‰æ‹©\n"
            "â€¢ å¯ä»¥è½¬å‘å…¶ä»–èŠå¤©ä¸­çš„åª’ä½“æ–‡ä»¶\n\n"

            "â“ <b>é‡åˆ°é—®é¢˜ï¼Ÿ</b>\n"
            "â€¢ æ£€æŸ¥é“¾æ¥æ˜¯å¦æœ‰æ•ˆ\n"
            "â€¢ ä½¿ç”¨ /status æŸ¥çœ‹ç³»ç»ŸçŠ¶æ€\n"
            "â€¢ æŸäº›åœ°åŒºå†…å®¹å¯èƒ½å—é™\n"
            "â€¢ å¤§æ–‡ä»¶ä¸‹è½½éœ€è¦æ›´å¤šæ—¶é—´"
        )

        await update.message.reply_text(help_message, parse_mode="HTML")

    async def settings_command(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """/settings å‘½ä»¤ï¼Œæ˜¾ç¤ºåŠŸèƒ½è®¾ç½®æŒ‰é’®"""
        user_id = update.message.from_user.id

        # æƒé™æ£€æŸ¥
        if not self._check_user_permission(user_id):
            await update.message.reply_text("âŒ æ‚¨æ²¡æœ‰æƒé™ä½¿ç”¨æ­¤æœºå™¨äºº")
            return

        # Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½æŒ‰é’®
        auto_playlist_current = self.bilibili_auto_playlist
        auto_playlist_text = "âœ… Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå¼€å¯" if auto_playlist_current else "âŒ Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå…³é—­"
        auto_playlist_button = InlineKeyboardButton(auto_playlist_text, callback_data="toggle_autop")

        # æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾æŒ‰é’®
        id_tags_current = self.youtube_id_tags
        id_tags_text = "âœ… æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå¼€å¯" if id_tags_current else "âŒ æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå…³é—­"
        id_tags_button = InlineKeyboardButton(id_tags_text, callback_data="toggle_id_tags")

        # YouTubeéŸ³é¢‘æ¨¡å¼æŒ‰é’®
        audio_mode_current = self.youtube_audio_mode
        audio_mode_text = "âœ… æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå¼€å¯" if audio_mode_current else "âŒ æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå…³é—­"
        audio_mode_button = InlineKeyboardButton(audio_mode_text, callback_data="toggle_audio_mode")

        # Bç«™UGCæ’­æ”¾åˆ—è¡¨è‡ªåŠ¨ä¸‹è½½æŒ‰é’®
        ugc_playlist_current = self.bilibili_ugc_playlist
        ugc_playlist_text = "âœ… Bç«™UGCä¸‹è½½ï¼šå¼€å¯" if ugc_playlist_current else "âŒ Bç«™UGCä¸‹è½½ï¼šå…³é—­"
        ugc_playlist_button = InlineKeyboardButton(ugc_playlist_text, callback_data="toggle_ugc_playlist")

        # Bç«™å¼¹å¹•ä¸‹è½½æŒ‰é’®
        danmaku_current = self.bilibili_danmaku_download
        danmaku_text = "âœ… Bç«™å¼¹å¹•ä¸‹è½½ï¼šå¼€å¯" if danmaku_current else "âŒ Bç«™å¼¹å¹•ä¸‹è½½ï¼šå…³é—­"
        danmaku_button = InlineKeyboardButton(danmaku_text, callback_data="toggle_danmaku")

        # YouTubeå°é¢ä¸‹è½½æŒ‰é’®
        thumbnail_current = self.youtube_thumbnail_download
        thumbnail_text = "âœ… æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå¼€å¯" if thumbnail_current else "âŒ æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå…³é—­"
        thumbnail_button = InlineKeyboardButton(thumbnail_text, callback_data="toggle_thumbnail")

        # YouTubeå­—å¹•ä¸‹è½½æŒ‰é’®
        subtitle_current = self.youtube_subtitle_download
        subtitle_text = "âœ… æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå¼€å¯" if subtitle_current else "âŒ æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå…³é—­"
        subtitle_button = InlineKeyboardButton(subtitle_text, callback_data="toggle_subtitle")

        # YouTubeæ—¶é—´æˆ³å‘½åæŒ‰é’®
        timestamp_current = self.youtube_timestamp_naming
        timestamp_text = "âœ… æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå¼€å¯" if timestamp_current else "âŒ æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå…³é—­"
        timestamp_button = InlineKeyboardButton(timestamp_text, callback_data="toggle_timestamp")

        # Bç«™å°é¢ä¸‹è½½æŒ‰é’®
        bilibili_thumbnail_current = self.bilibili_thumbnail_download
        bilibili_thumbnail_text = "âœ… Bç«™å°é¢ä¸‹è½½ï¼šå¼€å¯" if bilibili_thumbnail_current else "âŒ Bç«™å°é¢ä¸‹è½½ï¼šå…³é—­"
        bilibili_thumbnail_button = InlineKeyboardButton(bilibili_thumbnail_text, callback_data="toggle_bilibili_thumbnail")

        # ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶æŒ‰é’®
        lyrics_merge_current = self.netease_lyrics_merge
        lyrics_merge_text = "âœ… ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå¼€å¯" if lyrics_merge_current else "âŒ ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå…³é—­"
        lyrics_merge_button = InlineKeyboardButton(lyrics_merge_text, callback_data="toggle_lyrics_merge")

        # ç½‘æ˜“äº‘artistä¸‹è½½æŒ‰é’®
        artist_download_current = self.netease_artist_download
        artist_download_text = "âœ… ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå¼€å¯" if artist_download_current else "âŒ ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå…³é—­"
        artist_download_button = InlineKeyboardButton(artist_download_text, callback_data="toggle_artist_download")

        # ç½‘æ˜“äº‘coverä¸‹è½½æŒ‰é’®
        cover_download_current = self.netease_cover_download
        cover_download_text = "âœ… ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå¼€å¯" if cover_download_current else "âŒ ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå…³é—­"
        cover_download_button = InlineKeyboardButton(cover_download_text, callback_data="toggle_cover_download")

        reply_markup = InlineKeyboardMarkup([
            [auto_playlist_button],
            [id_tags_button],
            [audio_mode_button],
            [ugc_playlist_button],
            [danmaku_button],
            [thumbnail_button],
            [subtitle_button],
            [timestamp_button],
            [bilibili_thumbnail_button],
            [lyrics_merge_button],
            [artist_download_button],
            [cover_download_button]
        ])
        await update.message.reply_text("ğŸ›  åŠŸèƒ½è®¾ç½®", reply_markup=reply_markup)

    async def settings_button_handler(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        query = update.callback_query
        user_id = query.from_user.id

        # æƒé™æ£€æŸ¥
        if not self._check_user_permission(user_id):
            await query.answer("âŒ æ‚¨æ²¡æœ‰æƒé™ä½¿ç”¨æ­¤æœºå™¨äºº")
            return

        callback_data = query.data

        if callback_data == "toggle_autop":
            # åˆ‡æ¢å¤šPè‡ªåŠ¨ä¸‹è½½
            current = self.bilibili_auto_playlist
            self.bilibili_auto_playlist = not current
            await self._save_config_async()

            # é‡æ–°ç”Ÿæˆå››ä¸ªæŒ‰é’®
            auto_playlist_text = "âœ… Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå¼€å¯" if not current else "âŒ Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå…³é—­"
            auto_playlist_button = InlineKeyboardButton(auto_playlist_text, callback_data="toggle_autop")

            id_tags_text = "âœ… æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå¼€å¯" if self.youtube_id_tags else "âŒ æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå…³é—­"
            id_tags_button = InlineKeyboardButton(id_tags_text, callback_data="toggle_id_tags")

            audio_mode_text = "âœ… æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå¼€å¯" if self.youtube_audio_mode else "âŒ æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå…³é—­"
            audio_mode_button = InlineKeyboardButton(audio_mode_text, callback_data="toggle_audio_mode")

            ugc_playlist_text = "âœ… Bç«™UGCä¸‹è½½ï¼šå¼€å¯" if self.bilibili_ugc_playlist else "âŒ Bç«™UGCä¸‹è½½ï¼šå…³é—­"
            ugc_playlist_button = InlineKeyboardButton(ugc_playlist_text, callback_data="toggle_ugc_playlist")

            danmaku_text = "âœ… Bç«™å¼¹å¹•ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_danmaku_download else "âŒ Bç«™å¼¹å¹•ä¸‹è½½ï¼šå…³é—­"
            danmaku_button = InlineKeyboardButton(danmaku_text, callback_data="toggle_danmaku")

            thumbnail_text = "âœ… æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.youtube_thumbnail_download else "âŒ æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå…³é—­"
            thumbnail_button = InlineKeyboardButton(thumbnail_text, callback_data="toggle_thumbnail")

            subtitle_text = "âœ… æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå¼€å¯" if self.youtube_subtitle_download else "âŒ æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå…³é—­"
            subtitle_button = InlineKeyboardButton(subtitle_text, callback_data="toggle_subtitle")

            timestamp_text = "âœ… æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå¼€å¯" if self.youtube_timestamp_naming else "âŒ æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå…³é—­"
            timestamp_button = InlineKeyboardButton(timestamp_text, callback_data="toggle_timestamp")

            bilibili_thumbnail_text = "âœ… Bç«™å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_thumbnail_download else "âŒ Bç«™å°é¢ä¸‹è½½ï¼šå…³é—­"
            bilibili_thumbnail_button = InlineKeyboardButton(bilibili_thumbnail_text, callback_data="toggle_bilibili_thumbnail")

            lyrics_merge_text = "âœ… ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå¼€å¯" if self.netease_lyrics_merge else "âŒ ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå…³é—­"
            lyrics_merge_button = InlineKeyboardButton(lyrics_merge_text, callback_data="toggle_lyrics_merge")

            # ç½‘æ˜“äº‘artistä¸‹è½½æŒ‰é’®
            artist_download_text = "âœ… ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå¼€å¯" if self.netease_artist_download else "âŒ ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå…³é—­"
            artist_download_button = InlineKeyboardButton(artist_download_text, callback_data="toggle_artist_download")

            # ç½‘æ˜“äº‘coverä¸‹è½½æŒ‰é’®
            cover_download_text = "âœ… ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå¼€å¯" if self.netease_cover_download else "âŒ ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå…³é—­"
            cover_download_button = InlineKeyboardButton(cover_download_text, callback_data="toggle_cover_download")

            reply_markup = InlineKeyboardMarkup([
                [auto_playlist_button],
                [id_tags_button],
                [audio_mode_button],
                [ugc_playlist_button],
                [danmaku_button],
                [thumbnail_button],
                [subtitle_button],
                [timestamp_button],
                [bilibili_thumbnail_button],
                [lyrics_merge_button],
                [artist_download_button],
                [cover_download_button]
            ])
            await query.edit_message_reply_markup(reply_markup=reply_markup)
            await query.answer("å·²åˆ‡æ¢Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½çŠ¶æ€")

        elif callback_data == "toggle_id_tags":
            # åˆ‡æ¢IDæ ‡ç­¾
            current = self.youtube_id_tags
            self.youtube_id_tags = not current
            await self._save_config_async()

            # é‡æ–°ç”Ÿæˆå››ä¸ªæŒ‰é’®
            auto_playlist_text = "âœ… Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_auto_playlist else "âŒ Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå…³é—­"
            auto_playlist_button = InlineKeyboardButton(auto_playlist_text, callback_data="toggle_autop")

            id_tags_text = "âœ… æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå¼€å¯" if self.youtube_id_tags else "âŒ æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå…³é—­"
            id_tags_button = InlineKeyboardButton(id_tags_text, callback_data="toggle_id_tags")

            audio_mode_text = "âœ… æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå¼€å¯" if self.youtube_audio_mode else "âŒ æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå…³é—­"
            audio_mode_button = InlineKeyboardButton(audio_mode_text, callback_data="toggle_audio_mode")

            ugc_playlist_text = "âœ… Bç«™UGCä¸‹è½½ï¼šå¼€å¯" if self.bilibili_ugc_playlist else "âŒ Bç«™UGCä¸‹è½½ï¼šå…³é—­"
            ugc_playlist_button = InlineKeyboardButton(ugc_playlist_text, callback_data="toggle_ugc_playlist")

            danmaku_text = "âœ… Bç«™å¼¹å¹•ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_danmaku_download else "âŒ Bç«™å¼¹å¹•ä¸‹è½½ï¼šå…³é—­"
            danmaku_button = InlineKeyboardButton(danmaku_text, callback_data="toggle_danmaku")

            thumbnail_text = "âœ… æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.youtube_thumbnail_download else "âŒ æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå…³é—­"
            thumbnail_button = InlineKeyboardButton(thumbnail_text, callback_data="toggle_thumbnail")

            subtitle_text = "âœ… æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå¼€å¯" if self.youtube_subtitle_download else "âŒ æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå…³é—­"
            subtitle_button = InlineKeyboardButton(subtitle_text, callback_data="toggle_subtitle")

            timestamp_text = "âœ… æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå¼€å¯" if self.youtube_timestamp_naming else "âŒ æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå…³é—­"
            timestamp_button = InlineKeyboardButton(timestamp_text, callback_data="toggle_timestamp")

            bilibili_thumbnail_text = "âœ… Bç«™å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_thumbnail_download else "âŒ Bç«™å°é¢ä¸‹è½½ï¼šå…³é—­"
            bilibili_thumbnail_button = InlineKeyboardButton(bilibili_thumbnail_text, callback_data="toggle_bilibili_thumbnail")

            lyrics_merge_text = "âœ… ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå¼€å¯" if self.netease_lyrics_merge else "âŒ ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå…³é—­"
            lyrics_merge_button = InlineKeyboardButton(lyrics_merge_text, callback_data="toggle_lyrics_merge")

            # ç½‘æ˜“äº‘artistä¸‹è½½æŒ‰é’®
            artist_download_text = "âœ… ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå¼€å¯" if self.netease_artist_download else "âŒ ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå…³é—­"
            artist_download_button = InlineKeyboardButton(artist_download_text, callback_data="toggle_artist_download")

            # ç½‘æ˜“äº‘coverä¸‹è½½æŒ‰é’®
            cover_download_text = "âœ… ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå¼€å¯" if self.netease_cover_download else "âŒ ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå…³é—­"
            cover_download_button = InlineKeyboardButton(cover_download_text, callback_data="toggle_cover_download")

            reply_markup = InlineKeyboardMarkup([
                [auto_playlist_button],
                [id_tags_button],
                [audio_mode_button],
                [ugc_playlist_button],
                [danmaku_button],
                [thumbnail_button],
                [subtitle_button],
                [timestamp_button],
                [bilibili_thumbnail_button],
                [lyrics_merge_button],
                [artist_download_button],
                [cover_download_button]
            ])
            await query.edit_message_reply_markup(reply_markup=reply_markup)
            await query.answer("å·²åˆ‡æ¢æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾çŠ¶æ€")

        elif callback_data == "toggle_danmaku":
            # åˆ‡æ¢Bç«™å¼¹å¹•ä¸‹è½½
            current = self.bilibili_danmaku_download
            self.bilibili_danmaku_download = not current
            await self._save_config_async()

            # é‡æ–°ç”Ÿæˆå››ä¸ªæŒ‰é’®
            auto_playlist_text = "âœ… Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_auto_playlist else "âŒ Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå…³é—­"
            auto_playlist_button = InlineKeyboardButton(auto_playlist_text, callback_data="toggle_autop")

            id_tags_text = "âœ… æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå¼€å¯" if self.youtube_id_tags else "âŒ æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå…³é—­"
            id_tags_button = InlineKeyboardButton(id_tags_text, callback_data="toggle_id_tags")

            audio_mode_text = "âœ… æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå¼€å¯" if self.youtube_audio_mode else "âŒ æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå…³é—­"
            audio_mode_button = InlineKeyboardButton(audio_mode_text, callback_data="toggle_audio_mode")

            ugc_playlist_text = "âœ… Bç«™UGCä¸‹è½½ï¼šå¼€å¯" if self.bilibili_ugc_playlist else "âŒ Bç«™UGCä¸‹è½½ï¼šå…³é—­"
            ugc_playlist_button = InlineKeyboardButton(ugc_playlist_text, callback_data="toggle_ugc_playlist")

            danmaku_text = "âœ… Bç«™å¼¹å¹•ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_danmaku_download else "âŒ Bç«™å¼¹å¹•ä¸‹è½½ï¼šå…³é—­"
            danmaku_button = InlineKeyboardButton(danmaku_text, callback_data="toggle_danmaku")

            thumbnail_text = "âœ… æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.youtube_thumbnail_download else "âŒ æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå…³é—­"
            thumbnail_button = InlineKeyboardButton(thumbnail_text, callback_data="toggle_thumbnail")

            subtitle_text = "âœ… æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå¼€å¯" if self.youtube_subtitle_download else "âŒ æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå…³é—­"
            subtitle_button = InlineKeyboardButton(subtitle_text, callback_data="toggle_subtitle")

            timestamp_text = "âœ… æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå¼€å¯" if self.youtube_timestamp_naming else "âŒ æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå…³é—­"
            timestamp_button = InlineKeyboardButton(timestamp_text, callback_data="toggle_timestamp")

            bilibili_thumbnail_text = "âœ… Bç«™å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_thumbnail_download else "âŒ Bç«™å°é¢ä¸‹è½½ï¼šå…³é—­"
            bilibili_thumbnail_button = InlineKeyboardButton(bilibili_thumbnail_text, callback_data="toggle_bilibili_thumbnail")

            # ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶æŒ‰é’®
            lyrics_merge_text = "âœ… ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå¼€å¯" if self.netease_lyrics_merge else "âŒ ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå…³é—­"
            lyrics_merge_button = InlineKeyboardButton(lyrics_merge_text, callback_data="toggle_lyrics_merge")

            # ç½‘æ˜“äº‘artistä¸‹è½½æŒ‰é’®
            artist_download_text = "âœ… ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå¼€å¯" if self.netease_artist_download else "âŒ ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå…³é—­"
            artist_download_button = InlineKeyboardButton(artist_download_text, callback_data="toggle_artist_download")

            # ç½‘æ˜“äº‘coverä¸‹è½½æŒ‰é’®
            cover_download_text = "âœ… ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå¼€å¯" if self.netease_cover_download else "âŒ ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå…³é—­"
            cover_download_button = InlineKeyboardButton(cover_download_text, callback_data="toggle_cover_download")

            reply_markup = InlineKeyboardMarkup([
                [auto_playlist_button],
                [id_tags_button],
                [audio_mode_button],
                [ugc_playlist_button],
                [danmaku_button],
                [thumbnail_button],
                [subtitle_button],
                [timestamp_button],
                [bilibili_thumbnail_button],
                [lyrics_merge_button],
                [artist_download_button],
                [cover_download_button]
            ])
            await query.edit_message_reply_markup(reply_markup=reply_markup)
            await query.answer("å·²åˆ‡æ¢Bç«™å¼¹å¹•ä¸‹è½½çŠ¶æ€")

        elif callback_data == "toggle_audio_mode":
            # åˆ‡æ¢YouTubeéŸ³é¢‘æ¨¡å¼
            current = self.youtube_audio_mode
            self.youtube_audio_mode = not current
            await self._save_config_async()

            # é‡æ–°ç”Ÿæˆå››ä¸ªæŒ‰é’®
            auto_playlist_text = "âœ… Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_auto_playlist else "âŒ Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå…³é—­"
            auto_playlist_button = InlineKeyboardButton(auto_playlist_text, callback_data="toggle_autop")

            id_tags_text = "âœ… æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå¼€å¯" if self.youtube_id_tags else "âŒ æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå…³é—­"
            id_tags_button = InlineKeyboardButton(id_tags_text, callback_data="toggle_id_tags")

            audio_mode_text = "âœ… æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå¼€å¯" if self.youtube_audio_mode else "âŒ æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå…³é—­"
            audio_mode_button = InlineKeyboardButton(audio_mode_text, callback_data="toggle_audio_mode")

            ugc_playlist_text = "âœ… Bç«™UGCä¸‹è½½ï¼šå¼€å¯" if self.bilibili_ugc_playlist else "âŒ Bç«™UGCä¸‹è½½ï¼šå…³é—­"
            ugc_playlist_button = InlineKeyboardButton(ugc_playlist_text, callback_data="toggle_ugc_playlist")

            danmaku_text = "âœ… Bç«™å¼¹å¹•ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_danmaku_download else "âŒ Bç«™å¼¹å¹•ä¸‹è½½ï¼šå…³é—­"
            danmaku_button = InlineKeyboardButton(danmaku_text, callback_data="toggle_danmaku")

            thumbnail_text = "âœ… æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.youtube_thumbnail_download else "âŒ æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå…³é—­"
            thumbnail_button = InlineKeyboardButton(thumbnail_text, callback_data="toggle_thumbnail")

            subtitle_text = "âœ… æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå¼€å¯" if self.youtube_subtitle_download else "âŒ æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå…³é—­"
            subtitle_button = InlineKeyboardButton(subtitle_text, callback_data="toggle_subtitle")

            timestamp_text = "âœ… æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå¼€å¯" if self.youtube_timestamp_naming else "âŒ æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå…³é—­"
            timestamp_button = InlineKeyboardButton(timestamp_text, callback_data="toggle_timestamp")

            bilibili_thumbnail_text = "âœ… Bç«™å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_thumbnail_download else "âŒ Bç«™å°é¢ä¸‹è½½ï¼šå…³é—­"
            bilibili_thumbnail_button = InlineKeyboardButton(bilibili_thumbnail_text, callback_data="toggle_bilibili_thumbnail")

            # ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶æŒ‰é’®
            lyrics_merge_text = "âœ… ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå¼€å¯" if self.netease_lyrics_merge else "âŒ ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå…³é—­"
            lyrics_merge_button = InlineKeyboardButton(lyrics_merge_text, callback_data="toggle_lyrics_merge")

            # ç½‘æ˜“äº‘artistä¸‹è½½æŒ‰é’®
            artist_download_text = "âœ… ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå¼€å¯" if self.netease_artist_download else "âŒ ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå…³é—­"
            artist_download_button = InlineKeyboardButton(artist_download_text, callback_data="toggle_artist_download")

            # ç½‘æ˜“äº‘coverä¸‹è½½æŒ‰é’®
            cover_download_text = "âœ… ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå¼€å¯" if self.netease_cover_download else "âŒ ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå…³é—­"
            cover_download_button = InlineKeyboardButton(cover_download_text, callback_data="toggle_cover_download")

            reply_markup = InlineKeyboardMarkup([
                [auto_playlist_button],
                [id_tags_button],
                [audio_mode_button],
                [ugc_playlist_button],
                [danmaku_button],
                [thumbnail_button],
                [subtitle_button],
                [timestamp_button],
                [bilibili_thumbnail_button],
                [lyrics_merge_button],
                [artist_download_button],
                [cover_download_button]
            ])
            await query.edit_message_reply_markup(reply_markup=reply_markup)
            await query.answer("å·²åˆ‡æ¢æ²¹ç®¡éŸ³é¢‘æ¨¡å¼çŠ¶æ€")
            await query.edit_message_reply_markup(reply_markup=reply_markup)
            await query.answer("å·²åˆ‡æ¢ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶çŠ¶æ€")

        elif callback_data == "toggle_ugc_playlist":
            # åˆ‡æ¢Bç«™UGCæ’­æ”¾åˆ—è¡¨è‡ªåŠ¨ä¸‹è½½
            current = self.bilibili_ugc_playlist
            self.bilibili_ugc_playlist = not current
            await self._save_config_async()

            # é‡æ–°ç”Ÿæˆäº”ä¸ªæŒ‰é’®
            auto_playlist_text = "âœ… Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_auto_playlist else "âŒ Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå…³é—­"
            auto_playlist_button = InlineKeyboardButton(auto_playlist_text, callback_data="toggle_autop")

            id_tags_text = "âœ… æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå¼€å¯" if self.youtube_id_tags else "âŒ æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå…³é—­"
            id_tags_button = InlineKeyboardButton(id_tags_text, callback_data="toggle_id_tags")

            audio_mode_text = "âœ… æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå¼€å¯" if self.youtube_audio_mode else "âŒ æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå…³é—­"
            audio_mode_button = InlineKeyboardButton(audio_mode_text, callback_data="toggle_audio_mode")

            ugc_playlist_text = "âœ… Bç«™UGCä¸‹è½½ï¼šå¼€å¯" if self.bilibili_ugc_playlist else "âŒ Bç«™UGCä¸‹è½½ï¼šå…³é—­"
            ugc_playlist_button = InlineKeyboardButton(ugc_playlist_text, callback_data="toggle_ugc_playlist")

            danmaku_text = "âœ… Bç«™å¼¹å¹•ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_danmaku_download else "âŒ Bç«™å¼¹å¹•ä¸‹è½½ï¼šå…³é—­"
            danmaku_button = InlineKeyboardButton(danmaku_text, callback_data="toggle_danmaku")

            thumbnail_text = "âœ… æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.youtube_thumbnail_download else "âŒ æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå…³é—­"
            thumbnail_button = InlineKeyboardButton(thumbnail_text, callback_data="toggle_thumbnail")

            subtitle_text = "âœ… æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå¼€å¯" if self.youtube_subtitle_download else "âŒ æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå…³é—­"
            subtitle_button = InlineKeyboardButton(subtitle_text, callback_data="toggle_subtitle")

            timestamp_text = "âœ… æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå¼€å¯" if self.youtube_timestamp_naming else "âŒ æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå…³é—­"
            timestamp_button = InlineKeyboardButton(timestamp_text, callback_data="toggle_timestamp")

            bilibili_thumbnail_text = "âœ… Bç«™å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_thumbnail_download else "âŒ Bç«™å°é¢ä¸‹è½½ï¼šå…³é—­"
            bilibili_thumbnail_button = InlineKeyboardButton(bilibili_thumbnail_text, callback_data="toggle_bilibili_thumbnail")

            reply_markup = InlineKeyboardMarkup([
                [auto_playlist_button],
                [id_tags_button],
                [audio_mode_button],
                [ugc_playlist_button],
                [danmaku_button],
                [thumbnail_button],
                [subtitle_button],
                [timestamp_button],
                [bilibili_thumbnail_button]
            ])
            await query.edit_message_reply_markup(reply_markup=reply_markup)
            await query.answer("å·²åˆ‡æ¢Bç«™UGCä¸‹è½½çŠ¶æ€")

            lyrics_merge_text = "âœ… ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå¼€å¯" if self.netease_lyrics_merge else "âŒ ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå…³é—­"
            lyrics_merge_button = InlineKeyboardButton(lyrics_merge_text, callback_data="toggle_lyrics_merge")

            reply_markup = InlineKeyboardMarkup([
                [auto_playlist_button],
                [id_tags_button],
                [audio_mode_button],
                [ugc_playlist_button],
                [danmaku_button],
                [thumbnail_button],
                [subtitle_button],
                [timestamp_button],
                [bilibili_thumbnail_button],
                [lyrics_merge_button]
            ])
            # ç½‘æ˜“äº‘artistä¸‹è½½æŒ‰é’®
            artist_download_text = "âœ… ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå¼€å¯" if self.netease_artist_download else "âŒ ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå…³é—­"
            artist_download_button = InlineKeyboardButton(artist_download_text, callback_data="toggle_artist_download")

            # ç½‘æ˜“äº‘coverä¸‹è½½æŒ‰é’®
            cover_download_text = "âœ… ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå¼€å¯" if self.netease_cover_download else "âŒ ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå…³é—­"
            cover_download_button = InlineKeyboardButton(cover_download_text, callback_data="toggle_cover_download")

            reply_markup = InlineKeyboardMarkup([
                [auto_playlist_button],
                [id_tags_button],
                [audio_mode_button],
                [ugc_playlist_button],
                [danmaku_button],
                [thumbnail_button],
                [subtitle_button],
                [timestamp_button],
                [bilibili_thumbnail_button],
                [lyrics_merge_button],
                [artist_download_button],
                [cover_download_button]
            ])
            await query.edit_message_reply_markup(reply_markup=reply_markup)
            await query.answer("å·²åˆ‡æ¢ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶çŠ¶æ€")

        elif callback_data == "toggle_thumbnail":
            # åˆ‡æ¢YouTubeå°é¢ä¸‹è½½
            current = self.youtube_thumbnail_download
            self.youtube_thumbnail_download = not current
            await self._save_config_async()

            # é‡æ–°ç”Ÿæˆæ‰€æœ‰æŒ‰é’®
            auto_playlist_text = "âœ… Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_auto_playlist else "âŒ Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå…³é—­"
            auto_playlist_button = InlineKeyboardButton(auto_playlist_text, callback_data="toggle_autop")

            id_tags_text = "âœ… æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå¼€å¯" if self.youtube_id_tags else "âŒ æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå…³é—­"
            id_tags_button = InlineKeyboardButton(id_tags_text, callback_data="toggle_id_tags")

            audio_mode_text = "âœ… æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå¼€å¯" if self.youtube_audio_mode else "âŒ æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå…³é—­"
            audio_mode_button = InlineKeyboardButton(audio_mode_text, callback_data="toggle_audio_mode")

            ugc_playlist_text = "âœ… Bç«™UGCä¸‹è½½ï¼šå¼€å¯" if self.bilibili_ugc_playlist else "âŒ Bç«™UGCä¸‹è½½ï¼šå…³é—­"
            ugc_playlist_button = InlineKeyboardButton(ugc_playlist_text, callback_data="toggle_ugc_playlist")

            danmaku_text = "âœ… Bç«™å¼¹å¹•ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_danmaku_download else "âŒ Bç«™å¼¹å¹•ä¸‹è½½ï¼šå…³é—­"
            danmaku_button = InlineKeyboardButton(danmaku_text, callback_data="toggle_danmaku")

            thumbnail_text = "âœ… æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.youtube_thumbnail_download else "âŒ æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå…³é—­"
            thumbnail_button = InlineKeyboardButton(thumbnail_text, callback_data="toggle_thumbnail")

            reply_markup = InlineKeyboardMarkup([
                [auto_playlist_button],
                [id_tags_button],
                [audio_mode_button],
                [ugc_playlist_button],
                [danmaku_button],
                [thumbnail_button]
            ])
            await query.edit_message_reply_markup(reply_markup=reply_markup)
            await query.answer("å·²åˆ‡æ¢æ²¹ç®¡å°é¢ä¸‹è½½çŠ¶æ€")

        elif callback_data == "toggle_subtitle":
            # åˆ‡æ¢YouTubeå­—å¹•ä¸‹è½½
            current = self.youtube_subtitle_download
            self.youtube_subtitle_download = not current
            await self._save_config_async()

            # é‡æ–°ç”Ÿæˆæ‰€æœ‰æŒ‰é’®
            auto_playlist_text = "âœ… Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_auto_playlist else "âŒ Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå…³é—­"
            auto_playlist_button = InlineKeyboardButton(auto_playlist_text, callback_data="toggle_autop")

            id_tags_text = "âœ… æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå¼€å¯" if self.youtube_id_tags else "âŒ æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå…³é—­"
            id_tags_button = InlineKeyboardButton(id_tags_text, callback_data="toggle_id_tags")

            audio_mode_text = "âœ… æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå¼€å¯" if self.youtube_audio_mode else "âŒ æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå…³é—­"
            audio_mode_button = InlineKeyboardButton(audio_mode_text, callback_data="toggle_audio_mode")

            ugc_playlist_text = "âœ… Bç«™UGCä¸‹è½½ï¼šå¼€å¯" if self.bilibili_ugc_playlist else "âŒ Bç«™UGCä¸‹è½½ï¼šå…³é—­"
            ugc_playlist_button = InlineKeyboardButton(ugc_playlist_text, callback_data="toggle_ugc_playlist")

            danmaku_text = "âœ… Bç«™å¼¹å¹•ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_danmaku_download else "âŒ Bç«™å¼¹å¹•ä¸‹è½½ï¼šå…³é—­"
            danmaku_button = InlineKeyboardButton(danmaku_text, callback_data="toggle_danmaku")

            thumbnail_text = "âœ… æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.youtube_thumbnail_download else "âŒ æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå…³é—­"
            thumbnail_button = InlineKeyboardButton(thumbnail_text, callback_data="toggle_thumbnail")

            subtitle_text = "âœ… æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå¼€å¯" if self.youtube_subtitle_download else "âŒ æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå…³é—­"
            subtitle_button = InlineKeyboardButton(subtitle_text, callback_data="toggle_subtitle")

            timestamp_text = "âœ… æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå¼€å¯" if self.youtube_timestamp_naming else "âŒ æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå…³é—­"
            timestamp_button = InlineKeyboardButton(timestamp_text, callback_data="toggle_timestamp")

            bilibili_thumbnail_text = "âœ… Bç«™å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_thumbnail_download else "âŒ Bç«™å°é¢ä¸‹è½½ï¼šå…³é—­"
            bilibili_thumbnail_button = InlineKeyboardButton(bilibili_thumbnail_text, callback_data="toggle_bilibili_thumbnail")

            reply_markup = InlineKeyboardMarkup([
                [auto_playlist_button],
                [id_tags_button],
                [audio_mode_button],
                [ugc_playlist_button],
                [danmaku_button],
                [thumbnail_button],
                [subtitle_button],
                [timestamp_button],
                [bilibili_thumbnail_button]
            ])
            await query.edit_message_reply_markup(reply_markup=reply_markup)
            await query.answer("å·²åˆ‡æ¢æ²¹ç®¡å­—å¹•ä¸‹è½½çŠ¶æ€")

            lyrics_merge_text = "âœ… ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå¼€å¯" if self.netease_lyrics_merge else "âŒ ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå…³é—­"
            lyrics_merge_button = InlineKeyboardButton(lyrics_merge_text, callback_data="toggle_lyrics_merge")

            reply_markup = InlineKeyboardMarkup([
                [auto_playlist_button],
                [id_tags_button],
                [audio_mode_button],
                [ugc_playlist_button],
                [danmaku_button],
                [thumbnail_button],
                [subtitle_button],
                [timestamp_button],
                [bilibili_thumbnail_button],
                [lyrics_merge_button]
            ])
            # ç½‘æ˜“äº‘artistä¸‹è½½æŒ‰é’®
            artist_download_text = "âœ… ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå¼€å¯" if self.netease_artist_download else "âŒ ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå…³é—­"
            artist_download_button = InlineKeyboardButton(artist_download_text, callback_data="toggle_artist_download")

            # ç½‘æ˜“äº‘coverä¸‹è½½æŒ‰é’®
            cover_download_text = "âœ… ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå¼€å¯" if self.netease_cover_download else "âŒ ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå…³é—­"
            cover_download_button = InlineKeyboardButton(cover_download_text, callback_data="toggle_cover_download")

            reply_markup = InlineKeyboardMarkup([
                [auto_playlist_button],
                [id_tags_button],
                [audio_mode_button],
                [ugc_playlist_button],
                [danmaku_button],
                [thumbnail_button],
                [subtitle_button],
                [timestamp_button],
                [bilibili_thumbnail_button],
                [lyrics_merge_button],
                [artist_download_button],
                [cover_download_button]
            ])
            await query.edit_message_reply_markup(reply_markup=reply_markup)
            await query.answer("å·²åˆ‡æ¢ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶çŠ¶æ€")

        elif callback_data == "toggle_timestamp":
            # åˆ‡æ¢YouTubeæ—¶é—´æˆ³å‘½å
            current = self.youtube_timestamp_naming
            self.youtube_timestamp_naming = not current
            await self._save_config_async()

            # é‡æ–°ç”Ÿæˆæ‰€æœ‰æŒ‰é’®
            auto_playlist_text = "âœ… Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_auto_playlist else "âŒ Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå…³é—­"
            auto_playlist_button = InlineKeyboardButton(auto_playlist_text, callback_data="toggle_autop")

            id_tags_text = "âœ… æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå¼€å¯" if self.youtube_id_tags else "âŒ æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå…³é—­"
            id_tags_button = InlineKeyboardButton(id_tags_text, callback_data="toggle_id_tags")

            audio_mode_text = "âœ… æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå¼€å¯" if self.youtube_audio_mode else "âŒ æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå…³é—­"
            audio_mode_button = InlineKeyboardButton(audio_mode_text, callback_data="toggle_audio_mode")

            ugc_playlist_text = "âœ… Bç«™UGCä¸‹è½½ï¼šå¼€å¯" if self.bilibili_ugc_playlist else "âŒ Bç«™UGCä¸‹è½½ï¼šå…³é—­"
            ugc_playlist_button = InlineKeyboardButton(ugc_playlist_text, callback_data="toggle_ugc_playlist")

            danmaku_text = "âœ… Bç«™å¼¹å¹•ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_danmaku_download else "âŒ Bç«™å¼¹å¹•ä¸‹è½½ï¼šå…³é—­"
            danmaku_button = InlineKeyboardButton(danmaku_text, callback_data="toggle_danmaku")

            thumbnail_text = "âœ… æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.youtube_thumbnail_download else "âŒ æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå…³é—­"
            thumbnail_button = InlineKeyboardButton(thumbnail_text, callback_data="toggle_thumbnail")

            subtitle_text = "âœ… æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå¼€å¯" if self.youtube_subtitle_download else "âŒ æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå…³é—­"
            subtitle_button = InlineKeyboardButton(subtitle_text, callback_data="toggle_subtitle")

            timestamp_text = "âœ… æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå¼€å¯" if self.youtube_timestamp_naming else "âŒ æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå…³é—­"
            timestamp_button = InlineKeyboardButton(timestamp_text, callback_data="toggle_timestamp")

            bilibili_thumbnail_text = "âœ… Bç«™å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_thumbnail_download else "âŒ Bç«™å°é¢ä¸‹è½½ï¼šå…³é—­"
            bilibili_thumbnail_button = InlineKeyboardButton(bilibili_thumbnail_text, callback_data="toggle_bilibili_thumbnail")

            reply_markup = InlineKeyboardMarkup([
                [auto_playlist_button],
                [id_tags_button],
                [audio_mode_button],
                [ugc_playlist_button],
                [danmaku_button],
                [thumbnail_button],
                [subtitle_button],
                [timestamp_button],
                [bilibili_thumbnail_button]
            ])
            await query.edit_message_reply_markup(reply_markup=reply_markup)
            await query.answer("å·²åˆ‡æ¢æ²¹ç®¡æ—¶é—´æˆ³å‘½åçŠ¶æ€")

            lyrics_merge_text = "âœ… ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå¼€å¯" if self.netease_lyrics_merge else "âŒ ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå…³é—­"
            lyrics_merge_button = InlineKeyboardButton(lyrics_merge_text, callback_data="toggle_lyrics_merge")

            reply_markup = InlineKeyboardMarkup([
                [auto_playlist_button],
                [id_tags_button],
                [audio_mode_button],
                [ugc_playlist_button],
                [danmaku_button],
                [thumbnail_button],
                [subtitle_button],
                [timestamp_button],
                [bilibili_thumbnail_button],
                [lyrics_merge_button]
            ])
            # ç½‘æ˜“äº‘artistä¸‹è½½æŒ‰é’®
            artist_download_text = "âœ… ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå¼€å¯" if self.netease_artist_download else "âŒ ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå…³é—­"
            artist_download_button = InlineKeyboardButton(artist_download_text, callback_data="toggle_artist_download")

            # ç½‘æ˜“äº‘coverä¸‹è½½æŒ‰é’®
            cover_download_text = "âœ… ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå¼€å¯" if self.netease_cover_download else "âŒ ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå…³é—­"
            cover_download_button = InlineKeyboardButton(cover_download_text, callback_data="toggle_cover_download")

            reply_markup = InlineKeyboardMarkup([
                [auto_playlist_button],
                [id_tags_button],
                [audio_mode_button],
                [ugc_playlist_button],
                [danmaku_button],
                [thumbnail_button],
                [subtitle_button],
                [timestamp_button],
                [bilibili_thumbnail_button],
                [lyrics_merge_button],
                [artist_download_button],
                [cover_download_button]
            ])
            await query.edit_message_reply_markup(reply_markup=reply_markup)
            await query.answer("å·²åˆ‡æ¢ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶çŠ¶æ€")

        elif callback_data == "toggle_bilibili_thumbnail":
            # åˆ‡æ¢Bç«™å°é¢ä¸‹è½½
            current = self.bilibili_thumbnail_download
            self.bilibili_thumbnail_download = not current
            await self._save_config_async()

            # é‡æ–°ç”Ÿæˆæ‰€æœ‰æŒ‰é’®
            auto_playlist_text = "âœ… Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_auto_playlist else "âŒ Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå…³é—­"
            auto_playlist_button = InlineKeyboardButton(auto_playlist_text, callback_data="toggle_autop")

            id_tags_text = "âœ… æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå¼€å¯" if self.youtube_id_tags else "âŒ æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå…³é—­"
            id_tags_button = InlineKeyboardButton(id_tags_text, callback_data="toggle_id_tags")

            audio_mode_text = "âœ… æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå¼€å¯" if self.youtube_audio_mode else "âŒ æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå…³é—­"
            audio_mode_button = InlineKeyboardButton(audio_mode_text, callback_data="toggle_audio_mode")

            ugc_playlist_text = "âœ… Bç«™UGCä¸‹è½½ï¼šå¼€å¯" if self.bilibili_ugc_playlist else "âŒ Bç«™UGCä¸‹è½½ï¼šå…³é—­"
            ugc_playlist_button = InlineKeyboardButton(ugc_playlist_text, callback_data="toggle_ugc_playlist")

            danmaku_text = "âœ… Bç«™å¼¹å¹•ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_danmaku_download else "âŒ Bç«™å¼¹å¹•ä¸‹è½½ï¼šå…³é—­"
            danmaku_button = InlineKeyboardButton(danmaku_text, callback_data="toggle_danmaku")

            thumbnail_text = "âœ… æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.youtube_thumbnail_download else "âŒ æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå…³é—­"
            thumbnail_button = InlineKeyboardButton(thumbnail_text, callback_data="toggle_thumbnail")

            subtitle_text = "âœ… æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå¼€å¯" if self.youtube_subtitle_download else "âŒ æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå…³é—­"
            subtitle_button = InlineKeyboardButton(subtitle_text, callback_data="toggle_subtitle")

            timestamp_text = "âœ… æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå¼€å¯" if self.youtube_timestamp_naming else "âŒ æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå…³é—­"
            timestamp_button = InlineKeyboardButton(timestamp_text, callback_data="toggle_timestamp")

            bilibili_thumbnail_text = "âœ… Bç«™å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_thumbnail_download else "âŒ Bç«™å°é¢ä¸‹è½½ï¼šå…³é—­"
            bilibili_thumbnail_button = InlineKeyboardButton(bilibili_thumbnail_text, callback_data="toggle_bilibili_thumbnail")

            # ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶æŒ‰é’®
            lyrics_merge_text = "âœ… ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå¼€å¯" if self.netease_lyrics_merge else "âŒ ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå…³é—­"
            lyrics_merge_button = InlineKeyboardButton(lyrics_merge_text, callback_data="toggle_lyrics_merge")

            # ç½‘æ˜“äº‘artistä¸‹è½½æŒ‰é’®
            artist_download_text = "âœ… ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå¼€å¯" if self.netease_artist_download else "âŒ ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå…³é—­"
            artist_download_button = InlineKeyboardButton(artist_download_text, callback_data="toggle_artist_download")

            # ç½‘æ˜“äº‘coverä¸‹è½½æŒ‰é’®
            cover_download_text = "âœ… ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå¼€å¯" if self.netease_cover_download else "âŒ ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå…³é—­"
            cover_download_button = InlineKeyboardButton(cover_download_text, callback_data="toggle_cover_download")

            reply_markup = InlineKeyboardMarkup([
                [auto_playlist_button],
                [id_tags_button],
                [audio_mode_button],
                [ugc_playlist_button],
                [danmaku_button],
                [thumbnail_button],
                [subtitle_button],
                [timestamp_button],
                [bilibili_thumbnail_button],
                [lyrics_merge_button],
                [artist_download_button],
                [cover_download_button]
            ])
            await query.edit_message_reply_markup(reply_markup=reply_markup)
            await query.answer("å·²åˆ‡æ¢Bç«™å°é¢ä¸‹è½½çŠ¶æ€")

        elif callback_data == "toggle_lyrics_merge":
            # åˆ‡æ¢ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶
            current = self.netease_lyrics_merge
            self.netease_lyrics_merge = not current
            await self._save_config_async()

            # é‡æ–°ç”Ÿæˆæ‰€æœ‰æŒ‰é’®
            auto_playlist_text = "âœ… Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_auto_playlist else "âŒ Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå…³é—­"
            auto_playlist_button = InlineKeyboardButton(auto_playlist_text, callback_data="toggle_autop")

            id_tags_text = "âœ… æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå¼€å¯" if self.youtube_id_tags else "âŒ æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå…³é—­"
            id_tags_button = InlineKeyboardButton(id_tags_text, callback_data="toggle_id_tags")

            audio_mode_text = "âœ… æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå¼€å¯" if self.youtube_audio_mode else "âŒ æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå…³é—­"
            audio_mode_button = InlineKeyboardButton(audio_mode_text, callback_data="toggle_audio_mode")

            ugc_playlist_text = "âœ… Bç«™UGCä¸‹è½½ï¼šå¼€å¯" if self.bilibili_ugc_playlist else "âŒ Bç«™UGCä¸‹è½½ï¼šå…³é—­"
            ugc_playlist_button = InlineKeyboardButton(ugc_playlist_text, callback_data="toggle_ugc_playlist")

            danmaku_text = "âœ… Bç«™å¼¹å¹•ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_danmaku_download else "âŒ Bç«™å¼¹å¹•ä¸‹è½½ï¼šå…³é—­"
            danmaku_button = InlineKeyboardButton(danmaku_text, callback_data="toggle_danmaku")

            thumbnail_text = "âœ… æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.youtube_thumbnail_download else "âŒ æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå…³é—­"
            thumbnail_button = InlineKeyboardButton(thumbnail_text, callback_data="toggle_thumbnail")

            subtitle_text = "âœ… æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå¼€å¯" if self.youtube_subtitle_download else "âŒ æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå…³é—­"
            subtitle_button = InlineKeyboardButton(subtitle_text, callback_data="toggle_subtitle")

            timestamp_text = "âœ… æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå¼€å¯" if self.youtube_timestamp_naming else "âŒ æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå…³é—­"
            timestamp_button = InlineKeyboardButton(timestamp_text, callback_data="toggle_timestamp")

            bilibili_thumbnail_text = "âœ… Bç«™å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_thumbnail_download else "âŒ Bç«™å°é¢ä¸‹è½½ï¼šå…³é—­"
            bilibili_thumbnail_button = InlineKeyboardButton(bilibili_thumbnail_text, callback_data="toggle_bilibili_thumbnail")

            lyrics_merge_text = "âœ… ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå¼€å¯" if self.netease_lyrics_merge else "âŒ ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå…³é—­"
            lyrics_merge_button = InlineKeyboardButton(lyrics_merge_text, callback_data="toggle_lyrics_merge")

            # ç½‘æ˜“äº‘artistä¸‹è½½æŒ‰é’®
            artist_download_text = "âœ… ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå¼€å¯" if self.netease_artist_download else "âŒ ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå…³é—­"
            artist_download_button = InlineKeyboardButton(artist_download_text, callback_data="toggle_artist_download")

            # ç½‘æ˜“äº‘coverä¸‹è½½æŒ‰é’®
            cover_download_text = "âœ… ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå¼€å¯" if self.netease_cover_download else "âŒ ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå…³é—­"
            cover_download_button = InlineKeyboardButton(cover_download_text, callback_data="toggle_cover_download")

            reply_markup = InlineKeyboardMarkup([
                [auto_playlist_button],
                [id_tags_button],
                [audio_mode_button],
                [ugc_playlist_button],
                [danmaku_button],
                [thumbnail_button],
                [subtitle_button],
                [timestamp_button],
                [bilibili_thumbnail_button],
                [lyrics_merge_button],
                [artist_download_button],
                [cover_download_button]
            ])
            await query.edit_message_reply_markup(reply_markup=reply_markup)
            await query.answer("å·²åˆ‡æ¢ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶çŠ¶æ€")

        elif callback_data == "toggle_artist_download":
            # åˆ‡æ¢ç½‘æ˜“äº‘artistä¸‹è½½
            current = self.netease_artist_download
            self.netease_artist_download = not current
            await self._save_config_async()

            # é‡æ–°ç”Ÿæˆæ‰€æœ‰æŒ‰é’®
            auto_playlist_text = "âœ… Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_auto_playlist else "âŒ Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå…³é—­"
            auto_playlist_button = InlineKeyboardButton(auto_playlist_text, callback_data="toggle_autop")

            id_tags_text = "âœ… æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå¼€å¯" if self.youtube_id_tags else "âŒ æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå…³é—­"
            id_tags_button = InlineKeyboardButton(id_tags_text, callback_data="toggle_id_tags")

            audio_mode_text = "âœ… æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå¼€å¯" if self.youtube_audio_mode else "âŒ æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå…³é—­"
            audio_mode_button = InlineKeyboardButton(audio_mode_text, callback_data="toggle_audio_mode")

            ugc_playlist_text = "âœ… Bç«™UGCä¸‹è½½ï¼šå¼€å¯" if self.bilibili_ugc_playlist else "âŒ Bç«™UGCä¸‹è½½ï¼šå…³é—­"
            ugc_playlist_button = InlineKeyboardButton(ugc_playlist_text, callback_data="toggle_ugc_playlist")

            danmaku_text = "âœ… Bç«™å¼¹å¹•ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_danmaku_download else "âŒ Bç«™å¼¹å¹•ä¸‹è½½ï¼šå…³é—­"
            danmaku_button = InlineKeyboardButton(danmaku_text, callback_data="toggle_danmaku")

            thumbnail_text = "âœ… æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.youtube_thumbnail_download else "âŒ æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå…³é—­"
            thumbnail_button = InlineKeyboardButton(thumbnail_text, callback_data="toggle_thumbnail")

            subtitle_text = "âœ… æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå¼€å¯" if self.youtube_subtitle_download else "âŒ æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå…³é—­"
            subtitle_button = InlineKeyboardButton(subtitle_text, callback_data="toggle_subtitle")

            timestamp_text = "âœ… æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå¼€å¯" if self.youtube_timestamp_naming else "âŒ æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå…³é—­"
            timestamp_button = InlineKeyboardButton(timestamp_text, callback_data="toggle_timestamp")

            bilibili_thumbnail_text = "âœ… Bç«™å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_thumbnail_download else "âŒ Bç«™å°é¢ä¸‹è½½ï¼šå…³é—­"
            bilibili_thumbnail_button = InlineKeyboardButton(bilibili_thumbnail_text, callback_data="toggle_bilibili_thumbnail")

            lyrics_merge_text = "âœ… ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå¼€å¯" if self.netease_lyrics_merge else "âŒ ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå…³é—­"
            lyrics_merge_button = InlineKeyboardButton(lyrics_merge_text, callback_data="toggle_lyrics_merge")

            # ç½‘æ˜“äº‘artistä¸‹è½½æŒ‰é’®
            artist_download_text = "âœ… ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå¼€å¯" if self.netease_artist_download else "âŒ ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå…³é—­"
            artist_download_button = InlineKeyboardButton(artist_download_text, callback_data="toggle_artist_download")

            # ç½‘æ˜“äº‘coverä¸‹è½½æŒ‰é’®
            cover_download_text = "âœ… ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå¼€å¯" if self.netease_cover_download else "âŒ ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå…³é—­"
            cover_download_button = InlineKeyboardButton(cover_download_text, callback_data="toggle_cover_download")

            reply_markup = InlineKeyboardMarkup([
                [auto_playlist_button],
                [id_tags_button],
                [audio_mode_button],
                [ugc_playlist_button],
                [danmaku_button],
                [thumbnail_button],
                [subtitle_button],
                [timestamp_button],
                [bilibili_thumbnail_button],
                [lyrics_merge_button],
                [artist_download_button],
                [cover_download_button]
            ])
            await query.edit_message_reply_markup(reply_markup=reply_markup)
            await query.answer("å·²åˆ‡æ¢ç½‘æ˜“äº‘artistä¸‹è½½çŠ¶æ€")

        elif callback_data == "toggle_cover_download":
            # åˆ‡æ¢ç½‘æ˜“äº‘coverä¸‹è½½
            current = self.netease_cover_download
            self.netease_cover_download = not current
            await self._save_config_async()

            # é‡æ–°ç”Ÿæˆæ‰€æœ‰æŒ‰é’®
            auto_playlist_text = "âœ… Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_auto_playlist else "âŒ Bç«™å¤šPè‡ªåŠ¨ä¸‹è½½ï¼šå…³é—­"
            auto_playlist_button = InlineKeyboardButton(auto_playlist_text, callback_data="toggle_autop")

            id_tags_text = "âœ… æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå¼€å¯" if self.youtube_id_tags else "âŒ æ²¹ç®¡è‡ªåŠ¨æ·»åŠ æ ‡ç­¾ï¼šå…³é—­"
            id_tags_button = InlineKeyboardButton(id_tags_text, callback_data="toggle_id_tags")

            audio_mode_text = "âœ… æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå¼€å¯" if self.youtube_audio_mode else "âŒ æ²¹ç®¡éŸ³é¢‘æ¨¡å¼ï¼šå…³é—­"
            audio_mode_button = InlineKeyboardButton(audio_mode_text, callback_data="toggle_audio_mode")

            ugc_playlist_text = "âœ… Bç«™UGCä¸‹è½½ï¼šå¼€å¯" if self.bilibili_ugc_playlist else "âŒ Bç«™UGCä¸‹è½½ï¼šå…³é—­"
            ugc_playlist_button = InlineKeyboardButton(ugc_playlist_text, callback_data="toggle_ugc_playlist")

            danmaku_text = "âœ… Bç«™å¼¹å¹•ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_danmaku_download else "âŒ Bç«™å¼¹å¹•ä¸‹è½½ï¼šå…³é—­"
            danmaku_button = InlineKeyboardButton(danmaku_text, callback_data="toggle_danmaku")

            thumbnail_text = "âœ… æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.youtube_thumbnail_download else "âŒ æ²¹ç®¡å°é¢ä¸‹è½½ï¼šå…³é—­"
            thumbnail_button = InlineKeyboardButton(thumbnail_text, callback_data="toggle_thumbnail")

            subtitle_text = "âœ… æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå¼€å¯" if self.youtube_subtitle_download else "âŒ æ²¹ç®¡å­—å¹•ä¸‹è½½ï¼šå…³é—­"
            subtitle_button = InlineKeyboardButton(subtitle_text, callback_data="toggle_subtitle")

            timestamp_text = "âœ… æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå¼€å¯" if self.youtube_timestamp_naming else "âŒ æ²¹ç®¡æ—¶é—´æˆ³å‘½åï¼šå…³é—­"
            timestamp_button = InlineKeyboardButton(timestamp_text, callback_data="toggle_timestamp")

            bilibili_thumbnail_text = "âœ… Bç«™å°é¢ä¸‹è½½ï¼šå¼€å¯" if self.bilibili_thumbnail_download else "âŒ Bç«™å°é¢ä¸‹è½½ï¼šå…³é—­"
            bilibili_thumbnail_button = InlineKeyboardButton(bilibili_thumbnail_text, callback_data="toggle_bilibili_thumbnail")

            lyrics_merge_text = "âœ… ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå¼€å¯" if self.netease_lyrics_merge else "âŒ ç½‘æ˜“äº‘æ­Œè¯åˆå¹¶ï¼šå…³é—­"
            lyrics_merge_button = InlineKeyboardButton(lyrics_merge_text, callback_data="toggle_lyrics_merge")

            # ç½‘æ˜“äº‘artistä¸‹è½½æŒ‰é’®
            artist_download_text = "âœ… ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå¼€å¯" if self.netease_artist_download else "âŒ ç½‘æ˜“äº‘artistä¸‹è½½ï¼šå…³é—­"
            artist_download_button = InlineKeyboardButton(artist_download_text, callback_data="toggle_artist_download")

            # ç½‘æ˜“äº‘coverä¸‹è½½æŒ‰é’®
            cover_download_text = "âœ… ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå¼€å¯" if self.netease_cover_download else "âŒ ç½‘æ˜“äº‘coverä¸‹è½½ï¼šå…³é—­"
            cover_download_button = InlineKeyboardButton(cover_download_text, callback_data="toggle_cover_download")

            reply_markup = InlineKeyboardMarkup([
                [auto_playlist_button],
                [id_tags_button],
                [audio_mode_button],
                [ugc_playlist_button],
                [danmaku_button],
                [thumbnail_button],
                [subtitle_button],
                [timestamp_button],
                [bilibili_thumbnail_button],
                [lyrics_merge_button],
                [artist_download_button],
                [cover_download_button]
            ])
            await query.edit_message_reply_markup(reply_markup=reply_markup)
            await query.answer("å·²åˆ‡æ¢ç½‘æ˜“äº‘coverä¸‹è½½çŠ¶æ€")

    async def cancel_task_callback(
        self, update: Update, context: ContextTypes.DEFAULT_TYPE
    ):
        """å¤„ç†å–æ¶ˆä¸‹è½½ä»»åŠ¡çš„æŒ‰é’®ç‚¹å‡»"""
        query = update.callback_query
        user_id = query.from_user.id

        # æƒé™æ£€æŸ¥
        if not self._check_user_permission(user_id):
            await query.answer("âŒ æ‚¨æ²¡æœ‰æƒé™ä½¿ç”¨æ­¤æœºå™¨äºº")
            return

        await query.answer()

        # è·å–ä»»åŠ¡ ID
        task_id = query.data.split(":")[1]

        # å–æ¶ˆå¯¹åº”çš„ä¸‹è½½ä»»åŠ¡
        cancelled = await self.cancel_download_task(task_id)

        if cancelled:
            # ç¼–è¾‘åŸæ¶ˆæ¯ä¸ºå·²å–æ¶ˆ
            await query.edit_message_text(f"ğŸš« ä¸‹è½½ä»»åŠ¡å·²å–æ¶ˆï¼ˆID: {task_id}ï¼‰")
        else:
            # ä»»åŠ¡ä¸å­˜åœ¨æˆ–å·²ç»è¢«å–æ¶ˆ
            await query.edit_message_text(f"âš ï¸ ä»»åŠ¡ä¸å­˜åœ¨æˆ–å·²è¢«å–æ¶ˆï¼ˆID: {task_id}ï¼‰")

    async def add_download_task(self, task_id: str, task: asyncio.Task, user_id: int = None, status_message=None):
        """æ·»åŠ ä¸‹è½½ä»»åŠ¡åˆ°ç®¡ç†å™¨ä¸­"""
        async with self.task_lock:
            self.download_tasks[task_id] = {
                "task": task,
                "cancelled": False,
                "start_time": time.time(),
                "user_id": user_id,
                "status_message": status_message,
                "chat_id": status_message.chat_id if status_message else None,
                "message_id": status_message.message_id if status_message else None,
            }
            logger.info(f"ğŸ“ æ·»åŠ ä¸‹è½½ä»»åŠ¡: {task_id} (ç”¨æˆ·: {user_id})")

    async def cancel_download_task(self, task_id: str) -> bool:
        """å–æ¶ˆæŒ‡å®šçš„ä¸‹è½½ä»»åŠ¡"""
        async with self.task_lock:
            if task_id in self.download_tasks:
                task_info = self.download_tasks[task_id]
                if not task_info["cancelled"]:
                    task_info["cancelled"] = True
                    task_info["task"].cancel()
                    logger.info(f"ğŸš« å–æ¶ˆä¸‹è½½ä»»åŠ¡: {task_id}")
                    return True
                else:
                    logger.warning(f"âš ï¸ ä»»åŠ¡ {task_id} å·²ç»è¢«å–æ¶ˆ")
                    return False
            else:
                logger.warning(f"âš ï¸ æœªæ‰¾åˆ°ä»»åŠ¡: {task_id}")
                return False

    async def remove_download_task(self, task_id: str):
        """ä»ç®¡ç†å™¨ä¸­ç§»é™¤ä¸‹è½½ä»»åŠ¡"""
        async with self.task_lock:
            if task_id in self.download_tasks:
                del self.download_tasks[task_id]
                logger.info(f"ğŸ—‘ï¸ ç§»é™¤ä¸‹è½½ä»»åŠ¡: {task_id}")

    def is_task_cancelled(self, task_id: str) -> bool:
        """æ£€æŸ¥ä»»åŠ¡æ˜¯å¦å·²è¢«å–æ¶ˆ"""
        if task_id in self.download_tasks:
            return self.download_tasks[task_id]["cancelled"]
        return False

    async def download_user_media(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """
        é€šè¿‡ Telethon å¤„ç†ç”¨æˆ·å‘é€æˆ–è½¬å‘çš„åª’ä½“æ–‡ä»¶ï¼Œä»¥æ”¯æŒå¤§æ–‡ä»¶ä¸‹è½½ã€‚
        """
        import re
        user_id = update.message.from_user.id

        # æƒé™æ£€æŸ¥
        if not self._check_user_permission(user_id):
            await update.message.reply_text("âŒ æ‚¨æ²¡æœ‰æƒé™ä½¿ç”¨æ­¤æœºå™¨äºº")
            return

        message = update.message
        chat_id = message.chat_id

        if not self.user_client:
            await message.reply_text("âŒ åª’ä½“ä¸‹è½½åŠŸèƒ½æœªå¯ç”¨ï¼ˆTelethon æœªé…ç½®ï¼‰ï¼Œè¯·è”ç³»ç®¡ç†å‘˜ã€‚")
            return

        # --- ç´§æ€¥ä¿®å¤: ç¡®ä¿ self.bot_id å·²è®¾ç½® ---
        if not self.bot_id:
            try:
                logger.warning("self.bot_id æœªè®¾ç½®ï¼Œæ­£åœ¨å°è¯•è·å–...")
                bot_info = await context.bot.get_me()
                self.bot_id = bot_info.id
                logger.info(f"æˆåŠŸè·å–åˆ° bot_id: {self.bot_id}")
            except Exception as e:
                logger.error(f"ç´§æ€¥è·å– bot_id å¤±è´¥: {e}", exc_info=True)
                await message.reply_text(f"âŒ å†…éƒ¨åˆå§‹åŒ–é”™è¯¯ï¼šæ— æ³•è·å–æœºå™¨äººè‡ªèº«IDã€‚è¯·ç¨åé‡è¯•ã€‚")
                return
        # æå–åª’ä½“ä¿¡æ¯
        attachment = message.effective_attachment
        if not attachment:
            await message.reply_text("â“ è¯·å‘é€æˆ–è½¬å‘ä¸€ä¸ªåª’ä½“æ–‡ä»¶ã€‚")
            return

        file_name = getattr(attachment, 'file_name', 'unknown_file')
        # ä¼˜å…ˆå¤„ç†.torrentæ–‡ä»¶
        if file_name and file_name.lower().endswith('.torrent'):
            logger.info(f"ğŸ”— æ£€æµ‹åˆ°ç§å­æ–‡ä»¶: {file_name}")
            status_message = await message.reply_text("ğŸ”— æ­£åœ¨å¤„ç†ç§å­æ–‡ä»¶...")
            try:
                file_path = await context.bot.get_file(attachment.file_id)
                torrent_data = await file_path.download_as_bytearray()
                success = await self.add_torrent_file_to_qb(torrent_data, file_name)
                if success:
                    await status_message.edit_text("âœ… **ç£åŠ›é“¾æ¥/ç§å­æ–‡ä»¶å·²æˆåŠŸæ·»åŠ åˆ° qBittorrentï¼**\n\nğŸ“ ä»»åŠ¡å·²æ·»åŠ åˆ°ä¸‹è½½é˜Ÿåˆ—\nğŸ” æ‚¨å¯ä»¥åœ¨ qBittorrent ä¸­æŸ¥çœ‹ä¸‹è½½è¿›åº¦\nğŸ’¡ æç¤ºï¼šä¸‹è½½å®Œæˆåæ–‡ä»¶ä¼šä¿å­˜åˆ°é…ç½®çš„ä¸‹è½½ç›®å½•", parse_mode=None)
                else:
                    await status_message.edit_text("âŒ æ·»åŠ åˆ°qBittorrentå¤±è´¥ï¼", parse_mode=None)
            except Exception as e:
                logger.exception(f"æ·»åŠ ç§å­æ–‡ä»¶åˆ°qBittorrentå‡ºé”™: {e}")
                await status_message.edit_text(f"âŒ æ·»åŠ ç§å­æ–‡ä»¶å‡ºé”™: {e}", parse_mode=None)
            return
        # å¦‚æœ Bot API æ²¡æœ‰æ–‡ä»¶åï¼Œå°è¯•ä»æ¶ˆæ¯æ–‡æœ¬ä¸­æå–
        if not file_name or file_name == 'unknown_file':
            logger.info(f"Bot API æ¶ˆæ¯æ–‡æœ¬: '{message.text}'")
            if message.text and message.text.strip():
                file_name = message.text.strip()
                logger.info(f"ä»æ¶ˆæ¯æ–‡æœ¬ä¸­æå–æ–‡ä»¶å: {file_name}")
            else:
                logger.info("Bot API æ¶ˆæ¯æ–‡æœ¬ä¸ºç©ºæˆ–åªåŒ…å«ç©ºç™½å­—ç¬¦")

        # æ–‡ä»¶åå¤„ç†ï¼šé¦–è¡Œå»#ï¼Œç©ºæ ¼å˜_ï¼›æ­£æ–‡ç©ºæ ¼å˜_ï¼›æœ«è¡Œå…¨#æ ‡ç­¾åˆ™å»#æ‹¼æ¥ï¼Œæ‰€æœ‰éƒ¨åˆ†ç”¨_æ‹¼æ¥
        if file_name and file_name != 'unknown_file':
            lines = file_name.splitlines()
            parts = []
            # å¤„ç†é¦–è¡Œ
            if lines:
                first = lines[0].lstrip('#').strip().replace(' ', '_')
                if first:
                    parts.append(first)
            # å¤„ç†æ­£æ–‡
            for l in lines[1:-1]:
                l = l.strip().replace(' ', '_')
                if l:
                    parts.append(l)
            # å¤„ç†æœ«è¡Œï¼ˆå…¨æ˜¯#æ ‡ç­¾ï¼‰
            if len(lines) > 1 and all(x.startswith('#') for x in lines[-1].split()):
                tags = [x.lstrip('#').strip().replace(' ', '_') for x in lines[-1].split() if x.lstrip('#').strip()]
                if tags:
                    parts.extend(tags)
            else:
                # æœ«è¡Œä¸æ˜¯å…¨#æ ‡ç­¾ï¼Œä¹Ÿå½“æ­£æ–‡å¤„ç†
                if len(lines) > 1:
                    last = lines[-1].strip().replace(' ', '_')
                    if last:
                        parts.append(last)
            file_name = '_'.join(parts)
        if not file_name:
            file_name = 'unknown_file'
        file_size = getattr(attachment, 'file_size', 0)
        file_unique_id = getattr(attachment, 'file_unique_id', 'unknown_id')
        total_mb = file_size / (1024 * 1024) if file_size else 0

        # è®°å½• bot ç«¯æ”¶åˆ°çš„æ¶ˆæ¯ä¿¡æ¯
        bot_message_timestamp = message.date
        logger.info(
            f"Bot API æ”¶åˆ°åª’ä½“: name='{file_name}', size={file_size}, "
            f"time={bot_message_timestamp.isoformat()}, unique_id='{file_unique_id}'"
        )
        status_message = await message.reply_text("æ­£åœ¨åˆ†ææ¶ˆæ¯ï¼Œè¯·ç¨å€™...")
        try:
            # åœ¨ç”¨æˆ·å®¢æˆ·ç«¯ï¼ˆuser_clientï¼‰ä¸­æŸ¥æ‰¾åŒ¹é…çš„æ¶ˆæ¯
            telethon_message = None
            audio_bitrate = None
            audio_duration = None
            video_width = None
            video_height = None
            video_duration = None
            time_window_seconds = 5 # å…è®¸5ç§’çš„æ—¶é—´è¯¯å·®

            # ç›®æ ‡æ˜¯ä¸æœºå™¨äººçš„ç§èŠ
            try:
                # é¦–å…ˆå°è¯•ä½¿ç”¨bot_idè·å–å®ä½“
                target_entity = await self.user_client.get_entity(self.bot_id)
            except ValueError as e:
                logger.warning(f"æ— æ³•é€šè¿‡bot_idè·å–å®ä½“: {e}")
                try:
                    # å¤‡ç”¨æ–¹æ¡ˆ1: å°è¯•ä½¿ç”¨botç”¨æˆ·å
                    bot_info = await context.bot.get_me()
                    bot_username = bot_info.username
                    if bot_username:
                        logger.info(f"å°è¯•ä½¿ç”¨botç”¨æˆ·åè·å–å®ä½“: @{bot_username}")
                        target_entity = await self.user_client.get_entity(bot_username)
                    else:
                        raise ValueError("Botæ²¡æœ‰ç”¨æˆ·å")
                except Exception as e2:
                    logger.warning(f"æ— æ³•é€šè¿‡ç”¨æˆ·åè·å–å®ä½“: {e2}")
                    try:
                        # å¤‡ç”¨æ–¹æ¡ˆ2: ä½¿ç”¨ "me" è·å–ä¸è‡ªå·±çš„å¯¹è¯
                        logger.info("å°è¯•ä½¿ç”¨ 'me' è·å–å¯¹è¯")
                        target_entity = await self.user_client.get_entity("me")
                    except Exception as e3:
                        logger.error(f"æ‰€æœ‰è·å–å®ä½“çš„æ–¹æ³•éƒ½å¤±è´¥äº†: {e3}")
                        await status_message.edit_text(
                            "âŒ æ— æ³•è®¿é—®æ¶ˆæ¯å†å²ï¼Œå¯èƒ½æ˜¯Telethonä¼šè¯é—®é¢˜ã€‚è¯·è”ç³»ç®¡ç†å‘˜ã€‚"
                        )
                        return

            async for msg in self.user_client.iter_messages(target_entity, limit=20):
                # å…¼å®¹ä¸¤ç§åª’ä½“ç±»å‹: document (è§†é¢‘/æ–‡ä»¶) å’Œ audio (ä½œä¸ºéŸ³é¢‘å‘é€)
                media_to_check = msg.media.document if hasattr(msg.media, 'document') else msg.media

                if media_to_check and hasattr(media_to_check, 'size') and media_to_check.size == file_size:
                    if abs((msg.date - bot_message_timestamp).total_seconds()) < time_window_seconds:
                        telethon_message = msg
                        logger.info(f"æ‰¾åˆ°åŒ¹é…æ¶ˆæ¯ï¼Œå¼€å§‹æå–åª’ä½“å±æ€§...")
                        logger.info(f"Telethon æ¶ˆæ¯å®Œæ•´ä¿¡æ¯: {telethon_message}")
                        logger.info(f"Telethon æ¶ˆæ¯æ–‡æœ¬å±æ€§: '{telethon_message.text}'")
                        logger.info(f"Telethon æ¶ˆæ¯åŸå§‹æ–‡æœ¬: '{telethon_message.raw_text}'")

                        # æ£€æŸ¥æ˜¯å¦ä¸ºéŸ³é¢‘å¹¶æå–å…ƒæ•°æ®
                        if hasattr(media_to_check, 'attributes'):
                            logger.info(f"åª’ä½“å±æ€§åˆ—è¡¨: {[type(attr).__name__ for attr in media_to_check.attributes]}")

                            for attr in media_to_check.attributes:
                                logger.info(f"æ£€æŸ¥å±æ€§: {type(attr).__name__} - {attr}")

                                # éŸ³é¢‘å±æ€§
                                if isinstance(attr, types.DocumentAttributeAudio):
                                    if hasattr(attr, 'bitrate'):
                                        audio_bitrate = attr.bitrate
                                    if hasattr(attr, 'duration'):
                                        audio_duration = attr.duration
                                    logger.info(f"æå–åˆ°éŸ³é¢‘å…ƒæ•°æ®: ç ç‡={audio_bitrate}, æ—¶é•¿={audio_duration}")

                                # è§†é¢‘å±æ€§
                                elif isinstance(attr, types.DocumentAttributeVideo):
                                    if hasattr(attr, 'w') and hasattr(attr, 'h'):
                                        video_width = attr.w
                                        video_height = attr.h
                                        logger.info(f"æå–åˆ°è§†é¢‘å…ƒæ•°æ®: åˆ†è¾¨ç‡={video_width}x{video_height}")

                                    if hasattr(attr, 'duration'):
                                        video_duration = attr.duration
                                        logger.info(f"æå–åˆ°è§†é¢‘æ—¶é•¿: {video_duration}ç§’")

                                # æ–‡æ¡£å±æ€§ï¼ˆå¯èƒ½åŒ…å«æ–‡ä»¶åç­‰ä¿¡æ¯ï¼‰
                                elif isinstance(attr, types.DocumentAttributeFilename):
                                    logger.info(f"æå–åˆ°æ–‡ä»¶å: {attr.file_name}")
                                    # ä½¿ç”¨ä» Telethon æå–çš„æ–‡ä»¶åï¼Œå¦‚æœä¹‹å‰æ²¡æœ‰è·å–åˆ°æ–‡ä»¶å
                                    if not file_name or file_name == 'unknown_file':
                                        file_name = attr.file_name
                                        logger.info(f"ä½¿ç”¨ Telethon æ–‡ä»¶å: {file_name}")

                                # éŸ³é¢‘å±æ€§
                                if isinstance(attr, types.DocumentAttributeAudio):
                                    if hasattr(attr, 'bitrate'):
                                        audio_bitrate = attr.bitrate
                                    if hasattr(attr, 'duration'):
                                        audio_duration = attr.duration
                                    logger.info(f"æå–åˆ°éŸ³é¢‘å…ƒæ•°æ®: ç ç‡={audio_bitrate}, æ—¶é•¿={audio_duration}")

                                # è§†é¢‘å±æ€§
                                elif isinstance(attr, types.DocumentAttributeVideo):
                                    if hasattr(attr, 'w') and hasattr(attr, 'h'):
                                        video_width = attr.w
                                        video_height = attr.h
                                        logger.info(f"æå–åˆ°è§†é¢‘å…ƒæ•°æ®: åˆ†è¾¨ç‡={video_width}x{video_height}")

                                    if hasattr(attr, 'duration'):
                                        video_duration = attr.duration
                                        logger.info(f"æå–åˆ°è§†é¢‘æ—¶é•¿: {video_duration}ç§’")

                        break # æ‰¾åˆ°åŒ¹é…é¡¹ï¼Œè·³å‡ºå¾ªç¯

            # å¦‚æœè¿˜æ²¡æœ‰æ–‡ä»¶åï¼Œå°è¯•ä» Telethon æ¶ˆæ¯æ–‡æœ¬ä¸­æå–
            if (not file_name or file_name == 'unknown_file') and telethon_message:
                logger.info(f"Telethon æ¶ˆæ¯æ–‡æœ¬: '{telethon_message.text}'")
                if telethon_message.text and telethon_message.text.strip():
                    raw_text = telethon_message.text.strip()
                    logger.info(f"ä» Telethon æ¶ˆæ¯æ–‡æœ¬ä¸­æå–åŸå§‹æ–‡æœ¬: {raw_text}")
                    
                    # æ¸…ç†æ¶ˆæ¯æ–‡æœ¬ï¼Œæå–å¯èƒ½çš„æ ‡é¢˜
                    # ç§»é™¤å¸¸è§çš„æ ‡ç­¾å’Œç¬¦å·
                    clean_text = re.sub(r'[#@]\w+', '', raw_text).strip()
                    # ç§»é™¤å¤šä½™çš„ç©ºæ ¼å’Œæ¢è¡Œ
                    clean_text = re.sub(r'\s+', ' ', clean_text).strip()
                    # é™åˆ¶é•¿åº¦
                    if len(clean_text) > 50:
                        clean_text = clean_text[:50]
                    
                    if clean_text:
                        # ä½¿ç”¨æ¸…ç†åçš„æ–‡æœ¬ä½œä¸ºæ–‡ä»¶å
                        file_name = clean_text
                        logger.info(f"ä½¿ç”¨æ¸…ç†åçš„æ–‡æœ¬ä½œä¸ºæ–‡ä»¶å: {file_name}")
                    else:
                        # å¦‚æœæ¸…ç†åä¸ºç©ºï¼Œä½¿ç”¨åŸå§‹æ–‡æœ¬çš„ç¬¬ä¸€è¡Œ
                        first_line = raw_text.splitlines()[0].strip()
                        if first_line:
                            # ç§»é™¤#å·ä½†ä¿ç•™å…¶ä»–å†…å®¹
                            first_line = re.sub(r'^#+\s*', '', first_line).strip()
                            if first_line:
                                file_name = first_line
                                logger.info(f"ä½¿ç”¨ç¬¬ä¸€è¡Œä½œä¸ºæ–‡ä»¶å: {file_name}")
                            else:
                                file_name = 'unknown_file'
                        else:
                            file_name = 'unknown_file'
                    
                    if file_name == 'unknown_file':
                        logger.info("æ— æ³•ä»æ¶ˆæ¯æ–‡æœ¬ä¸­æå–æœ‰æ•ˆæ–‡ä»¶å")
                    else:
                        logger.info(f"æœ€ç»ˆæå–çš„æ–‡ä»¶å: {file_name}")
                else:
                    logger.info("Telethon æ¶ˆæ¯æ–‡æœ¬ä¸ºç©ºæˆ–åªåŒ…å«ç©ºç™½å­—ç¬¦")

            # å…œåº•æœºåˆ¶ï¼šå¦‚æœè¿˜æ˜¯æ²¡æœ‰æ–‡ä»¶åï¼Œä½¿ç”¨æ–‡æ¡£IDç”Ÿæˆæ–‡ä»¶å
            if not file_name or file_name == 'unknown_file':
                if telethon_message and hasattr(telethon_message.media, 'document'):
                    doc_id = telethon_message.media.document.id
                    logger.info(f"å…œåº•æœºåˆ¶è§¦å‘ - æ–‡ä»¶å¤§å°: {file_size} bytes, è§†é¢‘åˆ†è¾¨ç‡: {video_width}x{video_height}, éŸ³é¢‘æ—¶é•¿: {audio_duration}")
                    
                    # æ ¹æ®æ£€æµ‹åˆ°çš„æ–‡ä»¶ç±»å‹ç”Ÿæˆæ–‡ä»¶å
                    if video_width is not None and video_height is not None:
                        # å›é€€åˆ°ä½¿ç”¨æ–‡æ¡£IDï¼Œä½†æ·»åŠ åˆ†è¾¨ç‡ä¿¡æ¯
                        file_name = f"video_{video_width}x{video_height}_{doc_id}.mp4"
                        logger.info(f"ä½¿ç”¨åˆ†è¾¨ç‡+IDä½œä¸ºè§†é¢‘æ–‡ä»¶å: {file_name}")
                    elif audio_duration is not None and audio_bitrate is not None:
                        # å›é€€åˆ°ä½¿ç”¨æ–‡æ¡£IDï¼Œä½†æ·»åŠ æ—¶é•¿ä¿¡æ¯
                        duration_min = int(audio_duration // 60)
                        duration_sec = int(audio_duration % 60)
                        file_name = f"audio_{duration_min:02d}_{duration_sec:02d}_{doc_id}.mp3"
                        logger.info(f"ä½¿ç”¨æ—¶é•¿+IDä½œä¸ºéŸ³é¢‘æ–‡ä»¶å: {file_name}")
                    else:
                        # å¦‚æœæ— æ³•ç¡®å®šç±»å‹ï¼Œä½†æ–‡ä»¶å¤§å°è¾ƒå¤§ï¼Œå¾ˆå¯èƒ½æ˜¯è§†é¢‘æ–‡ä»¶
                        if file_size > 1024 * 1024:  # å¤§äº1MB
                            file_name = f"video_{doc_id}.mp4"
                            logger.info(f"æ–‡ä»¶å¤§å°è¾ƒå¤§({file_size} bytes)ï¼Œæ¨æµ‹ä¸ºè§†é¢‘æ–‡ä»¶ï¼Œä½¿ç”¨ .mp4 æ‰©å±•å")
                        else:
                            file_name = f"file_{doc_id}.bin"
                            logger.info(f"æ–‡ä»¶å¤§å°è¾ƒå°({file_size} bytes)ï¼Œä½¿ç”¨ .bin æ‰©å±•å")
                    logger.info(f"æœ€ç»ˆç”Ÿæˆçš„æ–‡ä»¶å: {file_name}")

            # æ ¹æ®åª’ä½“ç±»å‹ç¡®å®šä¸‹è½½è·¯å¾„
            # æ”¹è¿›éŸ³é¢‘æ£€æµ‹ï¼šä¸ä»…æ£€æŸ¥DocumentAttributeAudioï¼Œä¹Ÿæ£€æŸ¥æ–‡ä»¶æ‰©å±•å
            is_audio_file = False
            if audio_duration is not None and audio_bitrate is not None:
                is_audio_file = True
            elif file_name and any(file_name.lower().endswith(ext) for ext in ['.mp3', '.m4a', '.flac', '.wav', '.ogg', '.aac', '.wma', '.opus']):
                is_audio_file = True
                logger.info(f"é€šè¿‡æ–‡ä»¶æ‰©å±•åæ£€æµ‹åˆ°éŸ³é¢‘æ–‡ä»¶: {file_name}")

            # æ”¹è¿›è§†é¢‘æ£€æµ‹ï¼šä¸ä»…æ£€æŸ¥DocumentAttributeVideoï¼Œä¹Ÿæ£€æŸ¥æ–‡ä»¶æ‰©å±•å
            is_video_file = False
            if video_width is not None and video_height is not None:
                is_video_file = True
            elif file_name and any(file_name.lower().endswith(ext) for ext in ['.mp4', '.avi', '.mkv', '.mov', '.wmv', '.flv', '.webm', '.m4v', '.3gp', '.ts']):
                is_video_file = True
                logger.info(f"é€šè¿‡æ–‡ä»¶æ‰©å±•åæ£€æµ‹åˆ°è§†é¢‘æ–‡ä»¶: {file_name}")

            if is_audio_file:
                # éŸ³é¢‘æ–‡ä»¶æ”¾åœ¨telegram/musicæ–‡ä»¶å¤¹
                download_path = os.path.join(self.downloader.download_path, "telegram", "music")
                logger.info(f"æ£€æµ‹åˆ°éŸ³é¢‘æ–‡ä»¶ï¼Œä¸‹è½½è·¯å¾„: {download_path}")
            elif is_video_file:
                # è§†é¢‘æ–‡ä»¶æ”¾åœ¨telegram/videosæ–‡ä»¶å¤¹
                download_path = os.path.join(self.downloader.download_path, "telegram", "videos")
                logger.info(f"æ£€æµ‹åˆ°è§†é¢‘æ–‡ä»¶ï¼Œä¸‹è½½è·¯å¾„: {download_path}")
            else:
                # å…¶ä»–æ–‡ä»¶æ”¾åœ¨telegramæ–‡ä»¶å¤¹
                download_path = os.path.join(self.downloader.download_path, "telegram")
                logger.info(f"æ£€æµ‹åˆ°å…¶ä»–åª’ä½“æ–‡ä»¶ï¼Œä¸‹è½½è·¯å¾„: {download_path}")

            os.makedirs(download_path, exist_ok=True)
            if telethon_message:
                logger.info(f"æ‰¾åˆ°åŒ¹é…çš„Telethonæ¶ˆæ¯: {telethon_message.id}ï¼Œå¼€å§‹ä¸‹è½½...")

                # æ·»åŠ è¯¦ç»†çš„è°ƒè¯•ä¿¡æ¯
                logger.info(f"æ¶ˆæ¯ç±»å‹: {type(telethon_message)}")
                logger.info(f"æ¶ˆæ¯åª’ä½“: {type(telethon_message.media) if telethon_message.media else 'None'}")
                if telethon_message.media:
                    logger.info(f"åª’ä½“å±æ€§: {dir(telethon_message.media)}")
                    if hasattr(telethon_message.media, 'document'):
                        logger.info(f"Document: {telethon_message.media.document}")
                    else:
                        logger.info(f"ç›´æ¥åª’ä½“: {telethon_message.media}")

                # --- ä¸‹è½½å›è°ƒ (ç»Ÿä¸€ä¸ºè¯¦ç»†æ ·å¼) ---
                last_update_time = time.time()
                last_downloaded = 0
                async def progress(current, total):
                    nonlocal last_update_time, last_downloaded
                    now = time.time()

                    if now - last_update_time < 5 and current != total:
                        return

                    diff_time = now - last_update_time
                    diff_bytes = current - last_downloaded
                    last_update_time = now
                    last_downloaded = current

                    speed_bytes_s = diff_bytes / diff_time if diff_time > 0 else 0
                    speed_mb_s = speed_bytes_s / (1024 * 1024)
                    eta_str = "æœªçŸ¥"
                    if speed_bytes_s > 0:
                        remaining_bytes = total - current
                        try:
                            eta_seconds = remaining_bytes / speed_bytes_s
                            minutes, seconds = divmod(int(eta_seconds), 60)
                            eta_str = f"{minutes:02d}:{seconds:02d}"
                        except (OverflowError, ValueError):
                            eta_str = "æœªçŸ¥"

                    downloaded_mb = current / (1024 * 1024)
                    total_mb = total / (1024 * 1024)
                    # ä¿®å¤ï¼šæ£€æŸ¥file_nameæ˜¯å¦ä¸ºNone
                    display_filename = file_name if file_name else "æœªçŸ¥æ–‡ä»¶"
                    percent = current * 100 / total if total > 0 else 0
                    bar = self._make_progress_bar(percent)
                    
                    progress_text = (
                        f"ğŸ“ æ–‡ä»¶ï¼š{display_filename}\n"
                        f"ğŸ’¾ å¤§å°ï¼š{downloaded_mb:.2f}MB / {total_mb:.2f}MB\n"
                        f"âš¡ é€Ÿåº¦ï¼š{speed_mb_s:.2f}MB/s\n"
                        f"â³ é¢„è®¡å‰©ä½™ï¼š{eta_str}\n"
                        f"ğŸ“Š è¿›åº¦ï¼š{bar}"
                    )
                    try:
                        if current != total:
                            await context.bot.edit_message_text(
                                text=progress_text,
                                chat_id=chat_id,
                                message_id=status_message.message_id,
                                parse_mode=None
                            )
                    except Exception as e:
                        if "Message is not modified" not in str(e):
                            logger.warning(f"æ›´æ–°TGä¸‹è½½è¿›åº¦æ—¶å‡ºé”™: {e}")

                try:
                    # ç”Ÿæˆå”¯ä¸€æ–‡ä»¶åï¼Œé˜²æ­¢è¦†ç›–
                    def get_unique_filename(base_path, filename):
                        name, ext = os.path.splitext(filename)
                        counter = 1
                        unique_filename = filename
                        while os.path.exists(os.path.join(base_path, unique_filename)):
                            unique_filename = f"{name}_{counter}{ext}"
                            counter += 1
                        return unique_filename

                    unique_file_name = get_unique_filename(download_path, file_name)
                    downloaded_file = await self.user_client.download_media(
                        telethon_message,
                        file=os.path.join(download_path, unique_file_name),
                        progress_callback=progress
                    )
                    if downloaded_file:
                        # ä¸‹è½½æˆåŠŸï¼Œè·å–æ–‡ä»¶ä¿¡æ¯
                        file_size_mb = os.path.getsize(downloaded_file) / (1024 * 1024)

                        # æ£€æŸ¥æ˜¯å¦ä¸ºéŸ³é¢‘æ–‡ä»¶
                        file_extension = os.path.splitext(downloaded_file)[1].lower()
                        is_audio_file = file_extension in ['.mp3', '.flac', '.wav', '.aac', '.ogg', '.m4a', '.wma']

                        logger.info(f"ğŸµ éŸ³é¢‘æ–‡ä»¶æ£€æµ‹: æ–‡ä»¶æ‰©å±•å={file_extension}, æ˜¯å¦ä¸ºéŸ³é¢‘æ–‡ä»¶={is_audio_file}")
                        logger.info(f"ğŸµ Telegramå…ƒæ•°æ®: ç ç‡={audio_bitrate}, æ—¶é•¿={audio_duration}")

                        # å¯¹äºéŸ³é¢‘æ–‡ä»¶ï¼Œå¼ºåˆ¶å°è¯•è·å–éŸ³é¢‘ä¿¡æ¯
                        if is_audio_file:
                            try:
                                logger.info(f"ğŸµ å¼€å§‹æå–éŸ³é¢‘æ–‡ä»¶ä¿¡æ¯: {downloaded_file}")
                                media_info = self.downloader.get_media_info(downloaded_file)
                                logger.info(f"ğŸµ get_media_infoè¿”å›: {media_info}")

                                # å¦‚æœæ²¡æœ‰ç ç‡ä¿¡æ¯ï¼Œä»æ–‡ä»¶ä¸­æå–
                                if not audio_bitrate and media_info.get('bit_rate'):
                                    # ä»å­—ç¬¦ä¸²ä¸­æå–æ•°å­—ï¼Œå¦‚ "320 kbps" -> 320
                                    bit_rate_str = str(media_info.get('bit_rate', ''))
                                    import re
                                    match = re.search(r'(\d+)', bit_rate_str)
                                    if match:
                                        audio_bitrate = int(match.group(1))
                                        logger.info(f"âœ… ä»æ–‡ä»¶æå–åˆ°éŸ³é¢‘ç ç‡: {audio_bitrate}kbps")
                                    else:
                                        logger.warning(f"âš ï¸ æ— æ³•ä»ç ç‡å­—ç¬¦ä¸²æå–æ•°å­—: {bit_rate_str}")

                                # å¦‚æœæ²¡æœ‰æ—¶é•¿ä¿¡æ¯ï¼Œä»æ–‡ä»¶ä¸­æå–
                                if not audio_duration and media_info.get('duration'):
                                    duration_from_file = media_info.get('duration')
                                    # æ£€æŸ¥æ˜¯å¦ä¸ºæ ¼å¼åŒ–çš„æ—¶é—´å­—ç¬¦ä¸²ï¼ˆå¦‚ "03:47"ï¼‰
                                    if isinstance(duration_from_file, str) and ':' in duration_from_file:
                                        # è§£ææ—¶é—´å­—ç¬¦ä¸²ä¸ºç§’æ•°
                                        try:
                                            time_parts = duration_from_file.split(':')
                                            if len(time_parts) == 2:  # MM:SS
                                                minutes, seconds = map(int, time_parts)
                                                audio_duration = minutes * 60 + seconds
                                            elif len(time_parts) == 3:  # HH:MM:SS
                                                hours, minutes, seconds = map(int, time_parts)
                                                audio_duration = hours * 3600 + minutes * 60 + seconds
                                            else:
                                                audio_duration = float(duration_from_file)
                                        except ValueError:
                                            logger.warning(f"âš ï¸ æ— æ³•è§£ææ—¶é•¿å­—ç¬¦ä¸²: {duration_from_file}")
                                    else:
                                        # ç›´æ¥ä½¿ç”¨æ•°å­—æ—¶é•¿
                                        audio_duration = float(duration_from_file)
                                    logger.info(f"âœ… ä»æ–‡ä»¶æå–åˆ°éŸ³é¢‘æ—¶é•¿: {audio_duration}ç§’")

                                # å¦‚æœä»ç„¶æ²¡æœ‰è·å–åˆ°ä¿¡æ¯ï¼Œå°è¯•ä½¿ç”¨ffprobe
                                if not audio_bitrate or not audio_duration:
                                    logger.info(f"ğŸ” å°è¯•ä½¿ç”¨ffprobeè·å–éŸ³é¢‘ä¿¡æ¯")
                                    try:
                                        import subprocess
                                        import json

                                        cmd = [
                                            'ffprobe', '-loglevel', 'quiet', '-print_format', 'json',
                                            '-show_format', '-show_streams', downloaded_file
                                        ]
                                        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)

                                        if result.returncode == 0:
                                            probe_data = json.loads(result.stdout)
                                            logger.info(f"ğŸ” ffprobeè¿”å›æ•°æ®: {probe_data}")

                                            # ä»streamsä¸­è·å–éŸ³é¢‘ä¿¡æ¯
                                            for stream in probe_data.get('streams', []):
                                                if stream.get('codec_type') == 'audio':
                                                    if not audio_bitrate and 'bit_rate' in stream:
                                                        audio_bitrate = int(int(stream['bit_rate']) / 1000)  # è½¬æ¢ä¸ºkbps
                                                        logger.info(f"âœ… ffprobeä»streamsè·å–åˆ°ç ç‡: {audio_bitrate}kbps")
                                                    break

                                            # ä»formatä¸­è·å–ç ç‡å’Œæ—¶é•¿ä¿¡æ¯
                                            if 'format' in probe_data:
                                                format_info = probe_data['format']

                                                # å¦‚æœstreamsä¸­æ²¡æœ‰ç ç‡ä¿¡æ¯ï¼Œå°è¯•ä»formatä¸­è·å–
                                                if not audio_bitrate and 'bit_rate' in format_info:
                                                    audio_bitrate = int(int(format_info['bit_rate']) / 1000)  # è½¬æ¢ä¸ºkbps
                                                    logger.info(f"âœ… ffprobeä»formatè·å–åˆ°ç ç‡: {audio_bitrate}kbps")

                                                # è·å–æ—¶é•¿ä¿¡æ¯
                                                if (not audio_duration or not isinstance(audio_duration, (int, float))) and 'duration' in format_info:
                                                    audio_duration = float(format_info['duration'])
                                                    logger.info(f"âœ… ffprobeè·å–åˆ°æ—¶é•¿: {audio_duration}ç§’")
                                        else:
                                            logger.warning(f"âš ï¸ ffprobeæ‰§è¡Œå¤±è´¥: {result.stderr}")
                                    except Exception as ffprobe_error:
                                        logger.warning(f"âš ï¸ ffprobeæ‰§è¡Œå¼‚å¸¸: {ffprobe_error}")

                            except Exception as e:
                                logger.warning(f"âŒ æ— æ³•ä»æ–‡ä»¶æå–éŸ³é¢‘ä¿¡æ¯: {e}")

                        # ç¡®ä¿ audio_duration æ˜¯æ•°å­—ç±»å‹
                        if audio_duration and isinstance(audio_duration, str) and ':' in audio_duration:
                            # å¦‚æœæ˜¯æ—¶é—´å­—ç¬¦ä¸²æ ¼å¼ï¼Œè§£æä¸ºç§’æ•°
                            try:
                                time_parts = audio_duration.split(':')
                                if len(time_parts) == 2:  # MM:SS
                                    minutes, seconds = map(int, time_parts)
                                    audio_duration = minutes * 60 + seconds
                                elif len(time_parts) == 3:  # HH:MM:SS
                                    hours, minutes, seconds = map(int, time_parts)
                                    audio_duration = hours * 3600 + minutes * 60 + seconds
                                logger.info(f"ğŸ”§ è§£ææ—¶é•¿å­—ç¬¦ä¸² '{':'.join(time_parts)}' ä¸º {audio_duration} ç§’")
                            except ValueError as e:
                                logger.warning(f"âš ï¸ æ— æ³•è§£ææ—¶é•¿å­—ç¬¦ä¸² '{audio_duration}': {e}")

                        logger.info(f"ğŸµ æœ€ç»ˆéŸ³é¢‘ä¿¡æ¯: ç ç‡={audio_bitrate}, æ—¶é•¿={audio_duration}")

                        # æ„å»ºæˆåŠŸæ¶ˆæ¯
                        success_text = f"âœ… æ–‡ä»¶ä¸‹è½½å®Œæˆ\n\n"
                        success_text += f"ğŸ“ æ–‡ä»¶å: {file_name}\n"
                        success_text += f"ğŸ’¾ æ–‡ä»¶å¤§å°: {file_size_mb:.2f}MB\n"

                        # å¦‚æœæœ‰è§†é¢‘åˆ†è¾¨ç‡ä¿¡æ¯ï¼Œæ˜¾ç¤ºåœ¨æ–‡ä»¶å¤§å°ä¸‹é¢
                        if video_width and video_height:
                            # åˆ¤æ–­åˆ†è¾¨ç‡ç­‰çº§
                            resolution_label = ""
                            max_dimension = max(video_width, video_height)
                            if max_dimension >= 3840:  # 4K
                                resolution_label = " (4K)"
                            elif max_dimension >= 2560:  # 2K
                                resolution_label = " (2K)"
                            elif max_dimension >= 1920:  # 1080p
                                resolution_label = " (1080p)"
                            elif max_dimension >= 1280:  # 720p
                                resolution_label = " (720p)"
                            elif max_dimension >= 854:   # 480p
                                resolution_label = " (480p)"

                            success_text += f"ğŸ¥ åˆ†è¾¨ç‡: {video_width}x{video_height}{resolution_label}\n"

                        # å¦‚æœæ˜¯éŸ³é¢‘æ–‡ä»¶ï¼Œæ˜¾ç¤ºç ç‡ä¿¡æ¯
                        if is_audio_file and audio_bitrate:
                            success_text += f"ğŸµ ç ç‡: {audio_bitrate}kbps\n"

                        # æ˜¾ç¤ºæ—¶é•¿ä¿¡æ¯ï¼ˆéŸ³é¢‘æˆ–è§†é¢‘ï¼‰
                        duration_to_show = audio_duration if is_audio_file else video_duration
                        if duration_to_show:
                            minutes, seconds = divmod(int(duration_to_show), 60)
                            duration_str = f"{minutes:02d}:{seconds:02d}"
                            success_text += f"â±ï¸ æ—¶é•¿: {duration_str}\n"

                        success_text += f"ğŸ“ ä¿å­˜è·¯å¾„: {os.path.dirname(downloaded_file)}"

                        await context.bot.edit_message_text(
                            text=success_text,
                            chat_id=chat_id,
                            message_id=status_message.message_id,
                                parse_mode=None
                        )
                        logger.info(f"âœ… åª’ä½“æ–‡ä»¶ä¸‹è½½å®Œæˆ: {downloaded_file}")
                    else:
                        await context.bot.edit_message_text(
                            text="âŒ ä¸‹è½½å¤±è´¥ï¼šæ— æ³•è·å–æ–‡ä»¶",
                            chat_id=chat_id,
                            message_id=status_message.message_id
                        )
                        logger.error("âŒ åª’ä½“æ–‡ä»¶ä¸‹è½½å¤±è´¥ï¼šæ— æ³•è·å–æ–‡ä»¶")

                except Exception as e:
                    logger.error(f"âŒ åª’ä½“æ–‡ä»¶ä¸‹è½½å¤±è´¥: {e}", exc_info=True)
                    await context.bot.edit_message_text(
                        text=f"âŒ ä¸‹è½½å¤±è´¥: {str(e)}",
                        chat_id=chat_id,
                        message_id=status_message.message_id
                    )
            else:
                await context.bot.edit_message_text(
                    text="âŒ æ— æ³•æ‰¾åˆ°åŒ¹é…çš„åª’ä½“æ¶ˆæ¯ï¼Œè¯·é‡è¯•",
                    chat_id=chat_id,
                    message_id=status_message.message_id
                )
                logger.error("âŒ æ— æ³•æ‰¾åˆ°åŒ¹é…çš„Telethonæ¶ˆæ¯")

        except Exception as e:
            logger.error(f"âŒ å¤„ç†åª’ä½“æ¶ˆæ¯æ—¶å‡ºé”™: {e}", exc_info=True)
            await context.bot.edit_message_text(
                text=f"âŒ å¤„ç†å¤±è´¥: {str(e)}",
                chat_id=chat_id,
                message_id=status_message.message_id
            )

    async def error_handler(self, update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
        """è®°å½•æ‰€æœ‰ PTB æŠ›å‡ºçš„é”™è¯¯å¹¶å¤„ç†ç½‘ç»œé”™è¯¯"""
        error = context.error
        error_msg = str(error)
        error_type = type(error).__name__

        # æ£€æŸ¥æ˜¯å¦ä¸ºç½‘ç»œç›¸å…³é”™è¯¯
        is_network_error = any(keyword in error_msg.lower() for keyword in [
            'connection', 'timeout', 'network', 'remote', 'protocol',
            'httpx', 'telegram', 'api', 'server', 'unavailable',
            'connecterror', 'timeoutexception', 'httperror', 'ssl',
            'dns', 'resolve', 'unreachable', 'refused', 'reset',
            'broken pipe', 'connection reset', 'connection aborted',
            'read timeout', 'write timeout', 'connect timeout',
            'pool timeout', 'proxy', 'gateway', 'service unavailable'
        ])

        if is_network_error:
            logger.warning(f"ğŸŒ æ£€æµ‹åˆ°ç½‘ç»œé”™è¯¯: {error_type}: {error_msg}")
            logger.info("ğŸ”„ ç½‘ç»œé”™è¯¯å°†ç”±å¥åº·æ£€æŸ¥æœºåˆ¶è‡ªåŠ¨å¤„ç†")
        else:
            logger.error(f"âŒ PTB é”™è¯¯: {error_type}: {error_msg}", exc_info=error)

        # å¯¹äºä¸¥é‡çš„ç½‘ç»œé”™è¯¯ï¼Œè§¦å‘ç«‹å³å¥åº·æ£€æŸ¥
        if is_network_error and any(critical in error_msg.lower() for critical in [
            'connection reset', 'connection aborted', 'broken pipe', 'ssl'
        ]):
            logger.warning("ğŸš¨ æ£€æµ‹åˆ°ä¸¥é‡ç½‘ç»œé”™è¯¯ï¼Œè§¦å‘ç«‹å³å¥åº·æ£€æŸ¥")
            # è¿™é‡Œå¯ä»¥è§¦å‘ç«‹å³çš„å¥åº·æ£€æŸ¥ï¼Œä½†è¦é¿å…é€’å½’è°ƒç”¨

    def _make_progress_bar(self, percent: float) -> str:
        """ç”Ÿæˆè¿›åº¦æ¡"""
        bar_length = 20
        filled_length = int(bar_length * percent / 100)
        bar = "â–ˆ" * filled_length + "â–‘" * (bar_length - filled_length)
        return f"[{bar}] {percent:.1f}%"


class GlobalProgressManager:
    """å…¨å±€è¿›åº¦ç®¡ç†å™¨ï¼Œç»Ÿä¸€ç®¡ç†æ‰€æœ‰ä¸‹è½½ä»»åŠ¡çš„è¿›åº¦æ›´æ–°"""

    def __init__(self):
        self.last_update_time = time.time()
        self.update_interval = 15  # å…¨å±€æ›´æ–°é—´éš”15ç§’
        self.active_downloads = {}  # å­˜å‚¨æ´»è·ƒä¸‹è½½ä»»åŠ¡
        self.lock = asyncio.Lock()

    async def update_progress(
        self, task_id: str, progress_data: dict, context, status_message
    ):
        """æ›´æ–°å•ä¸ªä»»åŠ¡çš„è¿›åº¦"""
        async with self.lock:
            self.active_downloads[task_id] = progress_data

            now = time.time()
            if now - self.last_update_time < self.update_interval:
                return  # æœªåˆ°æ›´æ–°æ—¶é—´

            # æ„å»ºæ±‡æ€»è¿›åº¦æ¶ˆæ¯
            await self._send_summary_progress(context, status_message)
            self.last_update_time = now

    async def _send_summary_progress(self, context, status_message):
        """å‘é€æ±‡æ€»è¿›åº¦æ¶ˆæ¯"""
        if not self.active_downloads:
            return

        total_tasks = len(self.active_downloads)
        completed_tasks = sum(
            1
            for data in self.active_downloads.values()
            if data.get("status") == "finished"
        )

        # æ„å»ºè¿›åº¦æ¶ˆæ¯
        progress_lines = []
        progress_lines.append(f"ğŸ“¦ **æ‰¹é‡ä¸‹è½½è¿›åº¦** ({completed_tasks}/{total_tasks})")

        # æ˜¾ç¤ºå‰3ä¸ªæ´»è·ƒä»»åŠ¡
        active_tasks = [
            data
            for data in self.active_downloads.values()
            if data.get("status") == "downloading"
        ][:3]

        for i, data in enumerate(active_tasks, 1):
            filename = os.path.basename(data.get("filename", "æœªçŸ¥æ–‡ä»¶"))
            progress = data.get("progress", 0)
            speed = data.get("speed", 0)

            if speed and speed > 0:
                speed_mb = speed / (1024 * 1024)
                speed_str = f"{speed_mb:.1f}MB/s"
            else:
                speed_str = "æœªçŸ¥"

            progress_lines.append(f"{i}. `{filename}` - {progress:.1f}% ({speed_str})")

        if len(active_tasks) < total_tasks - completed_tasks:
            remaining = total_tasks - completed_tasks - len(active_tasks)
            progress_lines.append(f"... è¿˜æœ‰ {remaining} ä¸ªä»»åŠ¡è¿›è¡Œä¸­")

        progress_text = "\n".join(progress_lines)

        try:
            await context.bot.edit_message_text(
                text=progress_text,
                chat_id=status_message.chat_id,
                message_id=status_message.message_id,
                                parse_mode=None,
            )
        except Exception as e:
            if "Message is not modified" not in str(e) and "Flood control" not in str(
                e
            ):
                logger.warning(f"æ›´æ–°æ±‡æ€»è¿›åº¦å¤±è´¥: {e}")

    def remove_task(self, task_id: str):
        """ç§»é™¤å®Œæˆçš„ä»»åŠ¡"""
        if task_id in self.active_downloads:
            del self.active_downloads[task_id]


# å…¨å±€è¿›åº¦ç®¡ç†å™¨å®ä¾‹
global_progress_manager = GlobalProgressManager()


async def test_network_connectivity():
    """æµ‹è¯•ç½‘ç»œè¿æ¥æ€§"""
    import httpx
    test_urls = [
        "https://api.telegram.org",
        "https://www.google.com",
        "https://1.1.1.1"
    ]

    for url in test_urls:
        try:
            async with httpx.AsyncClient(timeout=10.0) as client:
                response = await client.get(url)
                if response.status_code == 200:
                    logger.debug(f"ğŸŸ¢ ç½‘ç»œè¿æ¥æµ‹è¯•æˆåŠŸ: {url}")
                    return True
        except Exception as e:
            logger.warning(f"ğŸŸ¡ ç½‘ç»œè¿æ¥æµ‹è¯•å¤±è´¥: {url} - {e}")
            continue

    logger.error(f"ğŸ”´ æ‰€æœ‰ç½‘ç»œè¿æ¥æµ‹è¯•éƒ½å¤±è´¥")
    return False

async def main():
    """ä¸»å‡½æ•° (å¼‚æ­¥)"""
    # å¯åŠ¨æ—¶ç¯å¢ƒæ£€æŸ¥
    logger.info("ğŸ” å¼€å§‹å¯åŠ¨å‰ç¯å¢ƒæ£€æŸ¥...")

    # è¯»å– TOML é…ç½®æ–‡ä»¶
    toml_config = {}
    if load_toml_config:
        toml_config = load_toml_config()
        if toml_config:
            logger.info("âœ… æˆåŠŸè¯»å– TOML é…ç½®æ–‡ä»¶")
            print_config_summary(toml_config)
        else:
            logger.warning("âš ï¸ TOML é…ç½®æ–‡ä»¶ä¸å­˜åœ¨æˆ–è¯»å–å¤±è´¥ï¼Œå°†ä½¿ç”¨ç¯å¢ƒå˜é‡")
    else:
        logger.warning("âš ï¸ é…ç½®è¯»å–å™¨ä¸å¯ç”¨ï¼Œå°†ä½¿ç”¨ç¯å¢ƒå˜é‡")

    # è·å– Telegram é…ç½®
    if toml_config and load_toml_config:
        telegram_config = get_telegram_config(toml_config)
        proxy_config = get_proxy_config(toml_config)
        
        # ä» TOML é…ç½®è·å– Telegram å‚æ•°
        bot_token = telegram_config.get('bot_token', '') or os.getenv("TELEGRAM_BOT_TOKEN", "")
        allowed_user_ids = telegram_config.get('allowed_user_ids', '') or os.getenv("TELEGRAM_BOT_ALLOWED_USER_IDS", "")
        api_id = telegram_config.get('api_id', '') or os.getenv("TELEGRAM_BOT_API_ID", "")
        api_hash = telegram_config.get('api_hash', '') or os.getenv("TELEGRAM_BOT_API_HASH", "")
        proxy_host = proxy_config.get('proxy_host', '') or os.getenv("PROXY_HOST", "")
        
        # è®¾ç½®ä¸ºç¯å¢ƒå˜é‡ä»¥ä¿æŒå…¶ä»–ä»£ç çš„å…¼å®¹æ€§
        if proxy_host:
            os.environ['PROXY_HOST'] = proxy_host
            logger.info(f"ğŸŒ ä» TOML é…ç½®è®¾ç½®ä»£ç†: {proxy_host}")
        if api_id:
            os.environ['TELEGRAM_BOT_API_ID'] = str(api_id)
            logger.info(f"ğŸ”‘ ä» TOML é…ç½®è®¾ç½® API ID: {api_id}")
        if api_hash:
            os.environ['TELEGRAM_BOT_API_HASH'] = api_hash
            logger.info(f"ğŸ” ä» TOML é…ç½®è®¾ç½® API Hash: {api_hash[:10]}...")
        if allowed_user_ids:
            os.environ['TELEGRAM_BOT_ALLOWED_USER_IDS'] = str(allowed_user_ids)
            logger.info(f"ğŸ‘¥ ä» TOML é…ç½®è®¾ç½®å…è®¸çš„ç”¨æˆ·ID: {allowed_user_ids}")
    else:
        # å›é€€åˆ°ç¯å¢ƒå˜é‡
        bot_token = os.getenv("TELEGRAM_BOT_TOKEN", "")
        logger.info("ğŸ”§ ä½¿ç”¨ç¯å¢ƒå˜é‡é…ç½®")

    # æ£€æŸ¥å…³é”®é…ç½®
    if not bot_token:
        logger.error("âŒ è¯·åœ¨ TOML é…ç½®æ–‡ä»¶æˆ–ç¯å¢ƒå˜é‡ä¸­è®¾ç½® TELEGRAM_BOT_TOKEN")
        sys.exit(1)

    # ç½‘ç»œè¿æ¥æµ‹è¯•å’Œå¥åº·æ£€æŸ¥
    logger.info("ğŸ” å¼€å§‹ç½‘ç»œè¿æ¥æµ‹è¯•...")
    if not await test_network_connectivity():
        logger.warning("âš ï¸ ç½‘ç»œè¿æ¥æµ‹è¯•å¤±è´¥ï¼Œä½†å°†ç»§ç»­å°è¯•å¯åŠ¨")
        # ä¸è¦ç›´æ¥é€€å‡ºï¼Œç»§ç»­å°è¯•å¯åŠ¨ï¼Œå¯èƒ½æ˜¯æµ‹è¯•URLçš„é—®é¢˜

    # å¥åº·æ£€æŸ¥åŠŸèƒ½å·²åˆ é™¤ï¼Œé¿å…äº‹ä»¶å¾ªç¯å†²çª
    logger.info("å¥åº·æ£€æŸ¥åŠŸèƒ½å·²ç¦ç”¨ï¼Œé¿å…äº‹ä»¶å¾ªç¯å†²çª")
    # ç¡¬ç¼–ç ä¸‹è½½è·¯å¾„ä¸º /downloads
    download_path = "/downloads"
    
    # ç»Ÿä¸€cookiesç›®å½•é…ç½®
    cookies_base_dir = "/app/cookies"
    x_cookies_path = os.getenv("X_COOKIES") or f"{cookies_base_dir}/x_cookies.txt"
    b_cookies_path = os.getenv("BILIBILI_COOKIES") or os.getenv("B_COOKIES") or f"{cookies_base_dir}/bilibili_cookies.txt"
    youtube_cookies_path = os.getenv("YOUTUBE_COOKIES") or f"{cookies_base_dir}/youtube_cookies.txt"
    douyin_cookies_path = os.getenv("DOUYIN_COOKIES") or f"{cookies_base_dir}/douyin_cookies.txt"
    kuaishou_cookies_path = os.getenv("KUAISHOU_COOKIES") or f"{cookies_base_dir}/kuaishou_cookies.txt"
    instagram_cookies_path = os.getenv("INSTAGRAM_COOKIES") or f"{cookies_base_dir}/instagram_cookies.txt"

    logger.info(f"ğŸ“ ä¸‹è½½è·¯å¾„: {download_path}")
    if x_cookies_path:
        logger.info(f"X Cookies è·¯å¾„: {x_cookies_path}")
    if b_cookies_path:
        logger.info(f"Bilibili Cookies è·¯å¾„: {b_cookies_path}")
    if youtube_cookies_path:
        logger.info(f"ğŸª ä½¿ç”¨YouTube cookies: {youtube_cookies_path}")
    if douyin_cookies_path:
        logger.info(f"ğŸ¬ ä½¿ç”¨æŠ–éŸ³ cookies: {douyin_cookies_path}")
        # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if os.path.exists(douyin_cookies_path):
            file_size = os.path.getsize(douyin_cookies_path)
            logger.info(f"âœ… æŠ–éŸ³ cookies æ–‡ä»¶å­˜åœ¨ï¼Œå¤§å°: {file_size} å­—èŠ‚")

            # è¯»å–å¹¶æ˜¾ç¤ºå‰å‡ è¡Œå†…å®¹
            try:
                with open(douyin_cookies_path, 'r', encoding='utf-8') as f:
                    lines = f.readlines()
                    logger.info(f"ğŸ“„ æŠ–éŸ³ cookies æ–‡ä»¶åŒ…å« {len(lines)} è¡Œ")
                    if lines:
                        logger.info(f"ğŸ“ ç¬¬ä¸€è¡Œå†…å®¹: {lines[0].strip()}")
                        if len(lines) > 1:
                            logger.info(f"ğŸ“ ç¬¬äºŒè¡Œå†…å®¹: {lines[1].strip()}")
            except Exception as e:
                logger.error(f"âŒ è¯»å–æŠ–éŸ³ cookies æ–‡ä»¶å¤±è´¥: {e}")
        else:
            logger.warning(f"âš ï¸ æŠ–éŸ³ cookies æ–‡ä»¶ä¸å­˜åœ¨: {douyin_cookies_path}")
    else:
        logger.warning("âš ï¸ æœªè®¾ç½® DOUYIN_COOKIES ç¯å¢ƒå˜é‡")

    # æ£€æŸ¥å¿«æ‰‹cookies
    if kuaishou_cookies_path:
        logger.info(f"âš¡ ä½¿ç”¨å¿«æ‰‹ cookies: {kuaishou_cookies_path}")
        # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if os.path.exists(kuaishou_cookies_path):
            file_size = os.path.getsize(kuaishou_cookies_path)
            logger.info(f"âœ… å¿«æ‰‹ cookies æ–‡ä»¶å­˜åœ¨ï¼Œå¤§å°: {file_size} å­—èŠ‚")

            # è¯»å–å¹¶æ˜¾ç¤ºå‰å‡ è¡Œå†…å®¹
            try:
                with open(kuaishou_cookies_path, 'r', encoding='utf-8') as f:
                    lines = f.readlines()
                    logger.info(f"ğŸ“„ å¿«æ‰‹ cookies æ–‡ä»¶åŒ…å« {len(lines)} è¡Œ")
                    if lines:
                        logger.info(f"ğŸ“ ç¬¬ä¸€è¡Œå†…å®¹: {lines[0].strip()}")
                        if len(lines) > 1:
                            logger.info(f"ğŸ“ ç¬¬äºŒè¡Œå†…å®¹: {lines[1].strip()}")
            except Exception as e:
                logger.error(f"âŒ è¯»å–å¿«æ‰‹ cookies æ–‡ä»¶å¤±è´¥: {e}")
        else:
            logger.warning(f"âš ï¸ å¿«æ‰‹ cookies æ–‡ä»¶ä¸å­˜åœ¨: {kuaishou_cookies_path}")
    else:
        logger.warning("âš ï¸ æœªè®¾ç½® KUAISHOU_COOKIES ç¯å¢ƒå˜é‡")

    # ç¡®ä¿ä¸‹è½½ç›®å½•å­˜åœ¨
    download_path_obj = Path(download_path)
    download_path_obj.mkdir(parents=True, exist_ok=True)
    
    # ç¡®ä¿cookiesç›®å½•å­˜åœ¨
    cookies_dir = Path(cookies_base_dir)
    cookies_dir.mkdir(parents=True, exist_ok=True)
    logger.info(f"ğŸ“ ç¡®ä¿cookiesç›®å½•å­˜åœ¨: {cookies_base_dir}")
    
    # ç¡®ä¿ AppleMusic å­ç›®å½•å­˜åœ¨
    apple_music_path = download_path_obj / "AppleMusic"
    apple_music_path.mkdir(parents=True, exist_ok=True)
    logger.info(f"ğŸ“ ç¡®ä¿ä¸‹è½½ç›®å½•å­˜åœ¨: {download_path}")
    logger.info(f"ğŸ“ ç¡®ä¿ AppleMusic å­ç›®å½•å­˜åœ¨: {apple_music_path}")
    
    # åˆ›å»ºä¸‹è½½å™¨å’Œæœºå™¨äºº
    downloader = VideoDownloader(
        download_path, x_cookies_path, b_cookies_path, youtube_cookies_path, douyin_cookies_path, kuaishou_cookies_path, None, instagram_cookies_path
    )
    bot = TelegramBot(bot_token, downloader)

    # å°† bot å®ä¾‹æ³¨å†Œåˆ° Flask åº”ç”¨ï¼Œä¾› Web æ¥å£ä½¿ç”¨
    app._bot_instance = bot

    # åœ¨åå°çº¿ç¨‹ä¸­å¯åŠ¨ Flask åº”ç”¨ï¼ˆä»…ç”¨äº Telegram ä¼šè¯ç”Ÿæˆï¼‰
    def run_flask():
        try:
            # ç¡¬ç¼–ç ç«¯å£ä¸º8530
            web_port = 8530

            logger.info(f"ğŸŒ å¯åŠ¨å†…ç½®FlaskæœåŠ¡ï¼ˆä»…ç”¨äº Telegram ä¼šè¯ç”Ÿæˆï¼‰")
            logger.info(f"   ğŸ” Webç«¯å£: {web_port} (åŒ…å« /setup)")

            app.run(host="0.0.0.0", port=web_port, debug=False, use_reloader=False)
        except Exception as e:
            logger.error(f"âŒ Flaskå¯åŠ¨å¤±è´¥: {e}")

    flask_thread = threading.Thread(target=run_flask, daemon=True)
    flask_thread.start()
    logger.info("âœ… Flask Telegram ä¼šè¯ç”ŸæˆæœåŠ¡å·²å¯åŠ¨")

    # ç›´æ¥å¯åŠ¨æœºå™¨äºº
    logger.info("ğŸš€ å¯åŠ¨Telegram Bot...")
    await bot.run()
    logger.info("âœ… Telegram Botå¯åŠ¨æˆåŠŸï¼")

    # ==================== Bç«™æ”¶è—å¤¹è®¢é˜…åŠŸèƒ½ ====================




if __name__ == "__main__":
    try:
        # å¿ƒè·³æ›´æ–°å·²åˆ é™¤  # åˆå§‹åŒ–å¿ƒè·³
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        logger.info("æœºå™¨äººå·²åœæ­¢ã€‚")





























